<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>unity热更新Lua | 零の領域</title><meta name="author" content="Fragmentary"><meta name="copyright" content="Fragmentary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="热更新的原理为什么使用Lua作为热更新语言，不用C#​    热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。 ​    LUA是解释型语言，并不需要事">
<meta property="og:type" content="article">
<meta property="og:title" content="unity热更新Lua">
<meta property="og:url" content="http://example.com/2024/07/22/0037-lua/index.html">
<meta property="og:site_name" content="零の領域">
<meta property="og:description" content="热更新的原理为什么使用Lua作为热更新语言，不用C#​    热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。 ​    LUA是解释型语言，并不需要事">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/p_66349124.png">
<meta property="article:published_time" content="2024-07-22T09:28:17.000Z">
<meta property="article:modified_time" content="2025-07-18T12:59:39.219Z">
<meta property="article:author" content="Fragmentary">
<meta property="article:tag" content="lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/p_66349124.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/22/0037-lua/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'unity热更新Lua',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-18 20:59:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/pixiv_cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/p_66349124.png')"><nav id="nav"><span id="blog-info"><a href="/" title="零の領域"><span class="site-name">零の領域</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">unity热更新Lua</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-22T09:28:17.000Z" title="发表于 2024-07-22 17:28:17">2024-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-18T12:59:39.219Z" title="更新于 2025-07-18 20:59:39">2025-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="unity热更新Lua"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="热更新的原理"><a href="#热更新的原理" class="headerlink" title="热更新的原理"></a>热更新的原理</h2><h3 id="为什么使用Lua作为热更新语言，不用C"><a href="#为什么使用Lua作为热更新语言，不用C" class="headerlink" title="为什么使用Lua作为热更新语言，不用C#"></a>为什么使用Lua作为热更新语言，不用C#</h3><p>​    热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。</p>
<p>​    LUA是解释型语言，并不需要事先编译成块，而是运行时动态解释执行的。这样LUA就和普通的游戏资源如图片，文本没有区别，因此可以在运行时直接从WEB服务器上下载到持久化目录并被其它LUA文件调用。</p>
<h3 id="不用C-热更的原因"><a href="#不用C-热更的原因" class="headerlink" title="不用C#热更的原因"></a>不用C#热更的原因</h3><p>​    准确的说，C#在安卓上可以实现热更新，但在苹果上却不能。</p>
<p>​    那C#为什么不做成解释型语言呢？因为C#的定位是一个追求效率且功能强大的编译型语言。在安卓上可以通过C#的语言特性-反射机制实现动态代码加载从而实现热更新。<br>​<br>​    具体做法是：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。<br>​<br>​    但苹果对反射机制有限制，不能实现这样的热更。为什么限制反射机制？安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/murongxiaopifu/p/4278947.html">谁偷了我的热更新？Mono，JIT，iOS - 慕容小匹夫 - 博客园 (cnblogs.com)</a></p>
<h3 id="Lua热更"><a href="#Lua热更" class="headerlink" title="Lua热更"></a>Lua热更</h3><p>大家或许会想，Lua到底可以做什么呢？在《Lua游戏开发》一书中作者已经告诉了我们答案：</p>
<p>1、编辑游戏的用户界面<br>2、定义、存储和管理基础游戏数据<br>3、管理实时游戏事件<br>4、创建和维护开发者友好的游戏存储和载入系统<br>5、编写游戏的人工智能系统<br>6、创建功能原型，可以之后用高性能语言移植</p>
<p>lua一大作用就是提供代码热更新</p>
<p>那么怎么实现热更新呢？</p>
<ul>
<li><p>导出函数require（mode_name）</p>
</li>
<li><p>查询全局缓存表package.loaded</p>
</li>
<li><p>通过package.searchers查找加载器</p>
</li>
<li><p>package.loaded<br>存储已经被加载的模块：当require一个mode_name模块得到的结果不为假时，require返回这个存储的值。require从package.loader中获得的值仅仅是对那张表（模块）的引用，改变这个值并不会改变require使用的表（模块）。</p>
</li>
<li><p>package.preload<br>保存一些特殊模块的加载器：这里面的值仅仅是对那张表（模块）的引用，改变这个值并不会改变require使用的表（模块）。</p>
</li>
<li><p>package.searchers<br>require查找加载器的表：这个表内的每一项都是一个查找器函数。当加载一个模块时，require按次序调用这些查找器，传入modname作为唯一参数。此方法会返回一个函数（模块的加载器）和一个传给这个加载器的参数。或返回一个描述为什么没有找到这个模块的字符串或者nil。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xufeng0991/article/details/52473602">https://blog.csdn.net/xufeng0991/article/details/52473602</a></p>
<h3 id="lua-热更代码原理"><a href="#lua-热更代码原理" class="headerlink" title="lua 热更代码原理"></a>lua 热更代码原理</h3><ul>
<li>第一种: lua中的require会阻止多次加载相同的模块。<ul>
<li>所以当需要更新系统的时候,要卸载掉响应的模块。</li>
<li>(把package.loaded里对应模块名下设置为nil,以保证下次require重新加载)并把全局表中的对应的模块表置nil。</li>
<li>同时把数据记录在专用的全局表下，并用 local 去引用它。</li>
<li>初始化这些数据的时候，首先应该检查他们是否被初始化过了。</li>
<li>这样来保证数据不被更新过程重置。</li>
</ul>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadup</span><span class="params">(module_name)</span></span></span><br><span class="line">    <span class="comment">-- 强制清除已加载标记</span></span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">loaded</span>[module_name] = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">-- 重新加载模块</span></span><br><span class="line">    <span class="built_in">require</span>(module_name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>第二种 正确解法</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadup</span><span class="params">(module_name)</span></span></span><br><span class="line">    <span class="comment">-- 获取旧模块引用</span></span><br><span class="line">    <span class="keyword">local</span> old_module = <span class="built_in">_G</span>[module_name]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 清除加载标记并重新加载</span></span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">loaded</span>[module_name] = <span class="literal">nil</span></span><br><span class="line">    <span class="built_in">require</span>(module_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 获取新模块内容</span></span><br><span class="line">    <span class="keyword">local</span> new_module = <span class="built_in">_G</span>[module_name]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 保留旧表引用，更新字段内容</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(new_module) <span class="keyword">do</span></span><br><span class="line">        old_module[k] = v  <span class="comment">-- 用新值覆盖旧表字段</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 还原加载标记</span></span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">loaded</span>[module_name] = old_module</span><br><span class="line">    <span class="comment">-- 恢复全局表引用</span></span><br><span class="line">    <span class="built_in">_G</span>[module_name] = old_module</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>为什么第一种不行</li>
</ul>
<ol>
<li>旧引用未更新，局部变量仍指向旧表。</li>
<li>数据重置导致状态丢失。</li>
<li>元表未继承的问题。</li>
<li>内存泄漏，旧表未被正确替换，导致多份实例存在</li>
</ol>
<h2 id="Lua互相调用"><a href="#Lua互相调用" class="headerlink" title="Lua互相调用"></a>Lua互相调用</h2><h3 id="C-与Lua互调过程及性能分析"><a href="#C-与Lua互调过程及性能分析" class="headerlink" title="C#与Lua互调过程及性能分析"></a>C#与Lua互调过程及性能分析</h3><ul>
<li>C#调用Lua的过程</li>
</ul>
<ol>
<li><strong>C#生成Bridge文件</strong>：C#代码生成一个Bridge文件，作为与Lua交互的桥梁。</li>
<li><strong>Bridge调用dll文件</strong>：Bridge文件调用由C语言编写的dll文件。</li>
<li><strong>dll文件执行Lua代码</strong>：dll文件加载并执行Lua代码。</li>
</ol>
<p>总结：C# -&gt; Bridge -&gt; dll -&gt; Lua</p>
<ul>
<li>Lua调用C#的过程</li>
</ul>
<ol>
<li><strong>生成Wrap文件</strong>：先生成一个Wrap文件（中间文件/配置文件）。</li>
<li><strong>注册字段和方法</strong>：Wrap文件将C#的字段和方法注册到Lua虚拟机中（解释器如LuaJIT）。</li>
<li>**Lua通过Wrap调用C#**：Lua代码通过Wrap文件调用C#的字段和方法。</li>
</ol>
<p>总结：Lua -&gt; Wrap -&gt; C#</p>
<p>性能分析</p>
<p>Lua调用C#时，性能较慢的原因主要有两点：</p>
<ol>
<li><strong>对象获取消耗</strong>：Lua调用C#时，需要在<code>ObjectTranslator</code>中获取C#对象，这一步操作有一定的性能消耗。</li>
<li><strong>Userdata类型设置元表</strong>：获取对象后，Lua需要将<code>Userdata</code>类型的对象设置元表（<code>Setmetatable</code>），以便在Lua层中访问具体的属性和方法（如<code>localPosition</code>），这一步也有较大的性能消耗。</li>
</ol>
<p>总结：Lua调用C#的性能瓶颈主要在于对象获取和元表设置的过程。</p>
<p>Wrap文件：每一个Wrap文件都是对一个C#类的包装。</p>
<ul>
<li>交互过程</li>
</ul>
<p>C# Call Lua交互过程<br>C#文件先调用Lua的解析器底层的dll库（C语言编写），再由DLL文件执行相应的Lua文件</p>
<p>Lua Call C# 交互过程<br>1.Wrap方式：首先生成C#源文件对应的Wrap文件，Lua文件会调用生成的Wrap文件，再由Wrap文件去调用C#文件。<br>2.反射方式：当索引系统API、DLL库或者第三方库，如果无法将代码具体实现进行代码生成，可通过反射来获取，执行效率较低。</p>
<ul>
<li>交互原理</li>
</ul>
<p>C#与Lua交互原理：虚拟栈！！！<br>交互通过虚拟栈实现，栈的索引分为正数和负数，如果索引是正数，则1表示栈底，如果索引是负数，则-1表示在栈顶</p>
<p>C# Call Lua交互原理<br>C#先将数据放入栈中，然后Lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#</p>
<p>Lua Call C#交互原理<br>C#源文件生成Wrap文件、或C#源文件生成C模块，将Wrap文件和C模块注册到Lua的解析器中，最后再由Lua去调用这个模块的函数~</p>
<p>从内存方面解释：</p>
<p>说白了就是对栈进行操作<br>C# Call Lua：C#把请求或数据放在栈顶，然后lua从栈顶取出该数据，在lua中做出相应处理（查询，改变），然后把处理结果放回栈顶，最后C#再从栈顶取出lua处理完的数据，完成交互。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54476817/article/details/132654801">Lua与C#的相互调用（xLua）_c# lua-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_14914623/article/details/89513031">C#与Lua交互过程及原理_lua和c#如何交互-CSDN博客</a></p>
<h3 id="C和lua的互相调用"><a href="#C和lua的互相调用" class="headerlink" title="C和lua的互相调用"></a>C和lua的互相调用</h3><ul>
<li><p>如果我们想要理解Lua语言与其它语言交互的实质，我们首先就要理解Lua堆栈。</p>
</li>
<li><p>简单来说，Lua语言之所以能和C/C++进行交互，主要是因为存在这样一个无处不在的虚拟栈。</p>
</li>
<li><p>栈的特点是先进后出，在Lua语言中，Lua堆栈是一种索引可以是正数或者负数的结构，并规定正数1永远表示栈底，负数-1永远表示栈顶。</p>
</li>
<li><p>换句话说呢，在不知道栈大小的情况下，我们可以通过索引-1取得栈底元素、通过索引1取得栈顶元素。</p>
</li>
</ul>
<ul>
<li><p>C和Lua之间的差异<br>1.Lua有垃圾回收机制，C需要显示释放内存<br>2.Lua是动态类型，弱类型语言【运行时确认】，C是静态类型，强类型语言。【编译时确认】</p>
</li>
<li><p>C与Lua的通信使用了虚拟栈结构！！！<br>以下是简单的虚拟栈概念！<br>将2个数据压入虚拟栈</p>
</li>
</ul>
<p>当使用正数索引时，表示从栈底开始，一直到栈顶 ，使用负数索引时表示从栈顶开始，一直到栈底。<br>通过指定索引来出栈和入栈</p>
<ul>
<li><p>C#调用Lua</p>
<p>是依靠C作为中间语言，通过C#调用C，C再调用Lua实现的 而框架中的tolua.dll等也就是借助LuaInterface封装的C语言动态库</p>
</li>
</ul>
<p>使用C++调用Lua时我们可以直接利用C++中的Lua环境来直接Lua脚本，例如我们在外部定义了一个lua脚本文件，我们现在需要使用C++来访问这个脚本该怎么做呢？在这里我们可以使用luaL_loadfile()、luaL_dofile()这两个方法个方法来实现，其区别是前者仅加载脚本文件而后者会在加载的同时调用脚本文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化Lua状态机并加载基础库  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_lua</span><span class="params">(lua_State* L)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	luaL_openlibs(L); <span class="comment">// 打开所有标准库  </span></span><br><span class="line">	<span class="comment">// 以下函数是Lua 5.1及之前版本的，但在Lua 5.2及之后版本已被废弃，因为luaL_openlibs已经包括了这些库  </span></span><br><span class="line">	<span class="comment">// luaopen_base(L); // 打开基础库（已废弃）  </span></span><br><span class="line">	<span class="comment">// luaopen_table(L); // 打开表库（已废弃）  </span></span><br><span class="line">	<span class="comment">// luaopen_string(L); // 打开字符串库（已废弃）  </span></span><br><span class="line">	<span class="comment">// luaopen_math(L); // 打开数学库（已废弃）  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C函数：加法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_add</span><span class="params">(lua_State* L)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> a = lua_tonumber(L, <span class="number">-2</span>); <span class="comment">// 获取栈顶第二个元素（即第一个参数）  </span></span><br><span class="line">	<span class="type">int</span> b = lua_tonumber(L, <span class="number">-1</span>); <span class="comment">// 获取栈顶元素（即第二个参数）  </span></span><br><span class="line">	<span class="type">int</span> c = a + b;  </span><br><span class="line">	lua_pushnumber(L, c); <span class="comment">// 将结果压入栈顶  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回给Lua一个结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C函数：自增  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_step</span><span class="params">(lua_State* L)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> a = lua_tonumber(L, <span class="number">-1</span>); <span class="comment">// 获取栈顶元素  </span></span><br><span class="line">	<span class="type">int</span> c = a + <span class="number">1</span>;  </span><br><span class="line">	lua_pushnumber(L, c); <span class="comment">// 将结果压入栈顶  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回给Lua一个结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注册到Lua的C函数列表  </span></span><br><span class="line">luaL_Reg mylib[] =   </span><br><span class="line">&#123;  </span><br><span class="line">	&#123;<span class="string">&quot;c_add&quot;</span>, c_add&#125;,  </span><br><span class="line">	&#123;<span class="string">&quot;c_step&quot;</span>, c_step&#125;,  </span><br><span class="line">	&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125; <span class="comment">// 列表结束标志  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	lua_State *L = lua_open(); <span class="comment">// 创建一个新的Lua状态机  </span></span><br><span class="line">	init_lua(L); <span class="comment">// 初始化Lua状态机并加载基础库  </span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 加载Lua脚本文件  </span></span><br><span class="line">	<span class="keyword">if</span> (luaL_loadfile(L, <span class="string">&quot;test.lua&quot;</span>) != <span class="number">0</span>) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;加载Lua文件失败\n&quot;</span>);  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 运行加载的Lua脚本  </span></span><br><span class="line">	<span class="keyword">if</span> (lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;运行Lua脚本失败: %s\n&quot;</span>, lua_tostring(L, <span class="number">-1</span>));  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 注册C函数到Lua的&quot;mylib&quot;表中  </span></span><br><span class="line">	luaL_register(L, <span class="string">&quot;mylib&quot;</span>, mylib);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// C调用Lua函数  </span></span><br><span class="line">	lua_getglobal(L, <span class="string">&quot;l_ff&quot;</span>); <span class="comment">// 获取全局变量&quot;l_ff&quot;（假设是Lua中定义的函数）  </span></span><br><span class="line">	lua_pushnumber(L, <span class="number">2</span>); <span class="comment">// 压入第一个参数  </span></span><br><span class="line">	lua_pushnumber(L, <span class="number">3</span>); <span class="comment">// 压入第二个参数  </span></span><br><span class="line">	<span class="keyword">if</span> (lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123; <span class="comment">// 调用Lua函数，传入2个参数，期望返回1个结果  </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;调用Lua函数失败: %s\n&quot;</span>, lua_tostring(L, <span class="number">-1</span>));  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="type">int</span> res = lua_tonumber(L, <span class="number">-1</span>); <span class="comment">// 从栈顶获取Lua函数返回的结果  </span></span><br><span class="line">	lua_pop(L, <span class="number">1</span>); <span class="comment">// 弹出栈顶元素，清理栈  </span></span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;在C中得到的结果: %d\n&quot;</span>, res);  </span><br><span class="line">  </span><br><span class="line">	lua_close(L); <span class="comment">// 关闭Lua状态机  </span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Lua调用C<br>调用之前需要注册，将函数地址告知Lua<br>LuaFramework的框架中Lua要调用Unity自带的API或者我们自己写的脚本之前要先生成对应的XXXWrap文件，就是如上面例子一样，需要在lua里进行注册。</li>
</ul>
<p> 首先我们在C++中定义一个方法，该方法必须以Lua_State作为参数，返回值类型为int，表示要返回的值的数目。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua函数：l_ff  </span></span><br><span class="line"><span class="comment">-- 接受两个参数a和b  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l_ff</span><span class="params">(a, b)</span></span>  </span><br><span class="line">	<span class="comment">-- 调用C库中的c_add函数，将a和b相加，结果加1后赋值给局部变量c  </span></span><br><span class="line">	<span class="keyword">local</span> c = mylib.c_add(a, b) + <span class="number">1</span>  </span><br><span class="line">	<span class="comment">-- 打印变量c的值  </span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;在Lua中: &quot;</span>, c)  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">-- 调用C库中的c_step函数，将变量c的值加1后赋值给局部变量d  </span></span><br><span class="line">	<span class="keyword">local</span> d = mylib.c_step(c)  </span><br><span class="line">	<span class="comment">-- 打印变量d的值  </span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;在Lua中: &quot;</span>, d)  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">-- 返回变量d的值给调用者  </span></span><br><span class="line">	<span class="keyword">return</span> d  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>这些api的名字很怪异，常常没法从名字知道这个函数是做什么的。</p>
<p>lua_getglobal是从lua脚本里面取一个全局变量放到堆栈上（c和lua之间是通过虚拟的堆栈来互相沟通的）。</p>
<p>lua_pushnumber是把一个数字放到堆栈上。</p>
<p>lua_pcall是从当前堆栈进行函数调用。</p>
<p>lua_tonumber这个是把堆栈中的某个值作为int取出来（因为l_ff有返回值，因此堆栈最顶上就是函数的返回值）</p>
<p>在函数c_add里面，lua_pushnumber才是lua调用的返回值（在lua里面，同样是把把栈最顶上的位置当作返回值）</p>
<p>总结：</p>
<ul>
<li>Lua和C++是通过一个虚拟栈来交互的。</li>
<li>C++调用Lua实际上是：由C++先把数据放入栈中，由Lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回C++。</li>
<li>Lua调C++也一样：先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwwsq/article/details/7835619">C和lua的互相调用_conky lua 互相调用-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sevenyuan/p/4511808.html">Lua和C++交互详细总结 - Bill Yuan - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/slysky/p/7919114.html">整理]Unity3D游戏开发之Lua - Ming明、 - 博客园 (cnblogs.com)</a></p>
<h2 id="Lua数据结构"><a href="#Lua数据结构" class="headerlink" title="Lua数据结构"></a>Lua数据结构</h2><h3 id="Lua表格（Table）"><a href="#Lua表格（Table）" class="headerlink" title="Lua表格（Table）"></a>Lua表格（Table）</h3><p>Table的简单组成：<br>1.哈希表 用来存储Key-Value 键值对，当哈希表上有冲突的时候，会通过链表的方式组织冲突元素<br>2.数组 用来存储 数据（包括数字，表等）</p>
<ul>
<li><p><strong>数组部分</strong>:从1开始作为整数数字索引，这种设计使得数组能够提供紧凑且高效的随机访问。数组的存储位置位于 TValue *array 中，而数组的长度信息则存储在 int sizearray 中。</p>
</li>
<li><p><strong>哈希表</strong>：存储在 Node *node，哈希表的大小用 lu_byte lsizenode 表示，lsizenode表示的是2的几次幂，而不是实际大小，因为哈希表的大小一定是 2 的整数次幂。哈希冲突后，采取<strong>开放定址法</strong>，应对 <strong>hash 碰撞</strong>。</p>
</li>
</ul>
<p>每个 Table 结构最多由三块连续内存构成：</p>
<ul>
<li>一个 <strong>table</strong> 结构本身</li>
<li>一块存放了连续整数索引的<strong>数组</strong></li>
<li>以及一块大小为2的整数次幂的<strong>哈希表</strong></li>
</ul>
<p>在 Lua 中，table 会将部分整形 key 作为下标放在<strong>数组</strong>中，而其余的整形 key 和其他类型的 key 则都放在 <strong>hash 表</strong>中。</p>
<p> table中的hash表的实现结合了以上两种方法的一些特性：</p>
<ul>
<li>table 中的 hash 表实现结合了链地址法（拉链法）和开放定址法的特性。</li>
<li>它的查找和插入操作的复杂度与链地址法相当，而内存开销则近似于开放定址法。</li>
</ul>
<p>语法相关:</p>
<ul>
<li>table 是 Lua 的一种数据结构，用于帮助我们创建不同的数据类型，如：数组、字典等；</li>
<li>table 是一个关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil，所有索引值都需要用 “[“和”]” 括起来；如果是字符串，还可以去掉引号和中括号； 即如果没有[]括起，则认为是字符串索引，Lua table 是不固定大小的，你可以根据自己需要进行扩容；</li>
<li>table 的默认初始索引一般以 1 开始，如果不写索引，则索引就会被认为是数字，并按顺序自动从1往后编；</li>
<li>table 的变量只是一个地址引用，对 table 的操作不会产生数据影响；</li>
<li>table 不会固定长度大小，有新数据插入时长度会自动增长；</li>
<li>table 里保存数据可以是任何类型，包括function和table</li>
<li>table所有元素之间，总是用逗号 “，” 隔开</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y1196645376/article/details/94348873">【Lua 5.3源码】table实现分析_lua解析table-CSDN博客</a></p>
<h2 id="table-补充"><a href="#table-补充" class="headerlink" title="table 补充"></a>table 补充</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef union Value &#123;</span><br><span class="line">  GCObject *gc;    /* collectable objects */</span><br><span class="line">  void *p;         /* light userdata */</span><br><span class="line">  int b;           /* booleans */</span><br><span class="line">  lua_CFunction f; /* light C functions */</span><br><span class="line">  lua_Integer i;   /* integer numbers */</span><br><span class="line">  lua_Number n;    /* float numbers */</span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line">struct lua_TValue &#123;</span><br><span class="line">  Value value_; </span><br><span class="line">  int tt_;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdn.net/20150330193313656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWF4aW11c1pob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="Lua元表-Metatable"><a href="#Lua元表-Metatable" class="headerlink" title="Lua元表 (Metatable)"></a>Lua元表 (Metatable)</h3><ul>
<li>什么是元表</li>
</ul>
<p>在Lua table中我们可以访问对应的key来得到value值，但是却无法对两个table进行操作。因此Lua 提供了<strong>元表(Metatable)<strong>，允许我们改变table的行为，每个行为关联了对应的元方法。通俗来说，</strong>元表就像是一个“操作指南”</strong>，里面包含了一系列操作的解决方案，例如 <strong>_index</strong>方法就是定义了这个表在索引失败的情况下该怎么办，**_add<strong>方法就是告诉table在相加的时候应该怎么做。这里面的</strong>_index<strong>，</strong>_add<strong>就是</strong>元方法**。</p>
<ul>
<li>有两个很重要的函数来处理元表：</li>
</ul>
<p>**setmetatable(table,metatable):**对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</p>
<p>**getmetatable(table):**返回对象的元表(metatable)。</p>
<ul>
<li>什么是元方法</li>
</ul>
<p>很多人对Lua中的元表和元方法都会有一个这样的误解：“<strong>如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员</strong>”。如果说这样去理解的话，就大错特错了，实际上即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil，原因就是B的**_index元方法<strong>没有赋值。别忘了我们之前说过的：“元表是一个操作指南”，定义了元表，只是有了操作指南，但不应该在操作指南里面去查找元素，而</strong>_index方法则是“操作指南”的“索引失败时该怎么办**。</p>
<p>下面是一些Lua表中可以重新定义的元方法:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__add</span>(a, b) <span class="comment">--加法</span></span><br><span class="line"><span class="built_in">__sub</span>(a, b) <span class="comment">--减法</span></span><br><span class="line"><span class="built_in">__mul</span>(a, b) <span class="comment">--乘法</span></span><br><span class="line"><span class="built_in">__div</span>(a, b) <span class="comment">--除法</span></span><br><span class="line"><span class="built_in">__mod</span>(a, b) <span class="comment">--取模</span></span><br><span class="line"><span class="built_in">__pow</span>(a, b) <span class="comment">--乘幂</span></span><br><span class="line"><span class="built_in">__unm</span>(a) <span class="comment">--相反数</span></span><br><span class="line"><span class="built_in">__concat</span>(a, b) <span class="comment">--连接</span></span><br><span class="line"><span class="built_in">__len</span>(a) <span class="comment">--长度</span></span><br><span class="line"><span class="built_in">__eq</span>(a, b) <span class="comment">--相等</span></span><br><span class="line"><span class="built_in">__lt</span>(a, b) <span class="comment">--小于</span></span><br><span class="line"><span class="built_in">__le</span>(a, b) <span class="comment">--小于等于</span></span><br><span class="line"><span class="built_in">__index</span>(a, b) <span class="comment">--索引查询</span></span><br><span class="line"><span class="built_in">__newindex</span>(a, b, c) <span class="comment">--索引更新（PS：不懂的话，后面会有讲）</span></span><br><span class="line"><span class="built_in">__call</span>(a, ...) <span class="comment">--执行方法调用</span></span><br><span class="line"><span class="built_in">__tostring</span>(a) <span class="comment">--字符串输出</span></span><br><span class="line"><span class="built_in">__metatable</span> <span class="comment">--保护元表</span></span><br></pre></td></tr></table></figure>



<ul>
<li>Lua的表元素查找机制</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">father = &#123;  </span><br><span class="line">    prop1=<span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line">father.<span class="built_in">__index</span> = father <span class="comment">-- 把father的__index方法指向它本身</span></span><br><span class="line">son = &#123;  </span><br><span class="line">    prop2=<span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">setmetatable</span>(son, father) <span class="comment">--把son的metatable设置为father  </span></span><br><span class="line"><span class="built_in">print</span> (son.prop1)</span><br><span class="line"><span class="comment">-- 输出为1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设father.__index = father 这句话不存在的话执行结果为nil，</p>
<p>这正印证了上面所说的，只设置元表是不管用的</p>
</blockquote>
<ul>
<li>在上面的例子中，当访问son.prop1时，son中是没有prop1这个成员的。接着Lua解释器发现son设置了元表：father</li>
<li><strong>需要注意的是：此时Lua并不是直接在fahter中找到名为prop1的成员，而是先调用father的__index方法</strong></li>
<li>如果fahter的**_index<strong>方法为nil，则直接返回nil（也就是</strong>father.__index = father** 这句话不存在）</li>
<li>但是如果**_index<strong>指向了一张表（上面的例子中father的</strong>_index**指向了自己本身也就是 <strong>father.__index = father</strong>）</li>
<li>那么就会到**_index**方法所指向的这个表中去查找名为prop1的成员,最终，我们在father表中找到了prop1成员</li>
<li>这里的**_index<strong>方法除了可以是一个表，也可以是一个函数，如果是函数的话，</strong>_index**方法被调用时会返回该函数的返回值</li>
</ul>
<p>总结 : Lua查找一个表元素的规则可以归纳为如下几个步骤：</p>
<ul>
<li>Step1:在表自身中查找，如果找到了就返回该元素，如果没找到则执行Step2；</li>
<li>Step2:判断该表是否有元表（操作指南），如果没有元表，则直接返回nil，如果有元表则继续执行Step3；</li>
<li>Step3:判断元表是否设置了有关索引失败的指南（**_index元方法<strong>），如果没有(</strong>_index为ni<strong>l)，则直接返回nil；如果有</strong>_index方法<strong>是一张表，则重复执行Step1-&gt;Step2-&gt;Step3；如果</strong>_index方法**是一个函数，则返回该函数的返回值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/msxh/p/7745553.html">【游戏开发】小白学Lua——从Lua查找表元素的过程看元表、元方法 - 马三小伙儿 - 博客园 (cnblogs.com)</a></p>
<h3 id="index-与-newindex的区别"><a href="#index-与-newindex的区别" class="headerlink" title="_index 与 _newindex的区别"></a>_index 与 _newindex的区别</h3><p>__newindex用于表的更新，__index用于表的查询。</p>
<p>如果访问不存在的数据，由**_index<strong>提供最终结果<br>如果对不存在的数据赋值，由</strong>_newindex**对数据进行赋值</p>
<ul>
<li><p><strong>_index</strong> 元方法可以是一个函数，Lua语言就会以【表】和【不存在键】为参数调用该函数</p>
</li>
<li><p><strong>_index</strong>元方法也可以是一个表，Lua语言就访问这个元表</p>
</li>
<li><p>对表中不存在的值进行赋值的时候，解释器会查找**_newindex**</p>
</li>
<li><p><strong>_newindex</strong> 元方法如果是一个表，Lua语言就对这个元表的字段进行赋值</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meta=&#123;&#125;</span><br><span class="line">meta.<span class="built_in">__newindex</span>=&#123;&#125;</span><br><span class="line">myTable=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable,meta)</span><br><span class="line">myTable.val=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable.val)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出 nil</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我myTable.val=1 访问了myTable表中没有的属性val</p>
<p>然后引发了寻找_newinde表 </p>
<p>而_newindex指向了空表 { }</p>
<p>则输出nil</p>
</blockquote>
<h3 id="只读表"><a href="#只读表" class="headerlink" title="只读表"></a>只读表</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetReadOnlyTable</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> meta = &#123;</span><br><span class="line">        <span class="built_in">__index</span> = t,</span><br><span class="line">        <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">            <span class="built_in">error</span>(<span class="string">&quot;Cannot modify read-only table!&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> newTable = &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(newTable, meta)</span><br><span class="line">    <span class="keyword">return</span> newTable</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>index</strong>：索引 table[key]。当 table <strong>不是表</strong>或是表 table 中<strong>不存在</strong> key 这个键时，这个事件被触发。此时，会读出 table 相应的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=209061628&content_type=Article&match_order=1&q=%E5%85%83%E6%96%B9%E6%B3%95&zhida_source=entity">元方法</a>。这个事件的元方法其实可以是一个函数也可以是一张表。如果它是一个函数，则以 table 和 key 作为参数调用它。如果它是一张表，最终的结果就是以 key <strong>取索引这张表的结果</strong>。（这个索引过程是走常规的流程，而不是直接索引，所以这次索引有可能引发另一次元方法。）</li>
<li><strong>newindex</strong>：索引赋值 table[key] = value。和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=209061628&content_type=Article&match_order=1&q=%E7%B4%A2%E5%BC%95%E4%BA%8B%E4%BB%B6&zhida_source=entity">索引事件</a>类似，它发生在 table <strong>不是表</strong>或是表 table 中<strong>不存在</strong> key 这个键的时候。此时，会读出 table 相应的元方法。同索引过程那样，这个事件的元方法即可以是函数，也可以是一张表。如果是一个函数，则以 table、key 和 value 为参数传入。如果是一张表，Lua <strong>对这张表做索引赋值操作</strong>。（这个索引过程是走常规的流程，而不是直接索引赋值，所以这次索引赋值有可能引发另一次元方法。）一旦有了<strong>newindex</strong>元方法，Lua 就不再做最初的赋值操作。（如果有必要，在元方法内部可以调用 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=209061628&content_type=Article&match_order=1&q=rawset&zhida_source=entity">rawset</a> 来做赋值。）</li>
</ul>
<hr>
<h3 id="多人开发避免全局变量泛滥-–-gt-G表只读"><a href="#多人开发避免全局变量泛滥-–-gt-G表只读" class="headerlink" title="多人开发避免全局变量泛滥 –&gt;  _G表只读"></a>多人开发避免全局变量泛滥 –&gt;  _G表只读</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置全局表的元方法，限制全局变量操作</span></span><br><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>, &#123;</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(_, key)</span></span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;禁止创建新全局变量，非法键: &quot;</span> .. key)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(_, key)</span></span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;禁止访问未定义的全局变量，非法键: &quot;</span> .. key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="rawset与-rawget-的区别"><a href="#rawset与-rawget-的区别" class="headerlink" title="_rawset与**_rawget**的区别"></a><strong>_rawset</strong>与**_rawget**的区别</h3><table>
<thead>
<tr>
<th align="center">元方法</th>
<th align="center">描述</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>_rawget</strong></td>
<td align="center">访问table中的元素时，直接获取元素的值，不经过**_index**元方法。</td>
<td align="center">当不想通过**_index<strong>元方法查询值，而是直接获取table中元素的原始值时，使用</strong>_rawget**。</td>
</tr>
<tr>
<td align="center"><strong>_rawset</strong></td>
<td align="center">更新table中的元素时，直接设置新值，不执行**_newindex**元方法。</td>
<td align="center">当不想执行**_newindex<strong>元方法，而是直接设置table中元素的新值时，使用</strong>_rawset**。</td>
</tr>
</tbody></table>
<h3 id="遍历-pairs-和-ipairs区别"><a href="#遍历-pairs-和-ipairs区别" class="headerlink" title="遍历:pairs 和 ipairs区别??"></a>遍历:pairs 和 ipairs区别??</h3><ul>
<li> 自定义索引</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;[<span class="number">0</span>]=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">-1</span>]=<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">-1</span>]) <span class="comment">--4</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])  <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>])  <span class="comment">--3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>])  <span class="comment">--5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为底层实现的原因 导致索引就处理一位，其他的按照顺序放入数组中</p>
</blockquote>
<p>也就是：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>数值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>4</td>
<td>自定义索引-1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>自定义索引0</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>第一个自定义索引0额外的属性2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>第一个自定义索引0额外的属性3</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>第二个自定义索引-1额外的属性5</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>pairs</td>
<td>迭代 table，可以遍历表中所有的 key 可以返回 nil</td>
<td>pairs会遍历所有key，对于key的类型没有要求，遇到nil时可以跳过，不会影响后面的遍历，既可以遍历数组部分，又能遍历哈希部分。</td>
</tr>
<tr>
<td>ipairs</td>
<td>迭代数组，不能返回 nil,如果遇到 nil 则退出</td>
<td>ipairs只会从1开始，步进1，只能遍历数组部分， 中间不是数字的key忽略, 到第一个不连续的数字为止（不含），遍历时只能取key为整数值，遇到nil时终止遍历。</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;[<span class="number">1</span>]=<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>]=<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>]=<span class="number">5</span>,[<span class="number">6</span>]=<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ipairs&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index..<span class="string">&quot;_&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pairs&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key..<span class="string">&quot;_&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--答案是ipairs [2 4 3] , pairs [2 4 3 6 5] 无序 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这边存在一点问题,对于[1]=1,2 这个怎么处理</p>
</blockquote>
<p>输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipairs</span></span><br><span class="line"><span class="number">1</span>_2</span><br><span class="line"><span class="number">2</span>_4</span><br><span class="line"><span class="number">3</span>_3</span><br><span class="line"><span class="built_in">pairs</span></span><br><span class="line"><span class="number">1</span>_2</span><br><span class="line"><span class="number">3</span>_3</span><br><span class="line"><span class="number">5</span>_5</span><br><span class="line"><span class="number">6</span>_6</span><br><span class="line"><span class="number">2</span>_4</span><br></pre></td></tr></table></figure>







<blockquote>
<p>所以当ipairs遍历table时，从键值对索引值[1]开始连续递增，当键值对索引值[ ]断开或遇到nil时退出，所以上面的例子中ipairs遍历出的结果是2，4，3。</p>
</blockquote>
<blockquote>
<p>而pairs遍历时，会遍历表中的所有键值对，先按照索引值输出数组，在输出其它键值对，且元素是根据哈希算法来排序的，得到的不一定是连续的，所以pairs遍历出的结果是2，4，3，6，5。</p>
</blockquote>
<ul>
<li>对于数字和表混合的内容俩者又有什么区别呢</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> testTab =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">-- &#x27;纯表&#x27;</span></span><br><span class="line"><span class="keyword">local</span> testTab1 = &#123;a = <span class="number">1</span>, b = <span class="number">2</span>, c =<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">-- &#x27;杂表1&#x27;</span></span><br><span class="line"><span class="keyword">local</span> testTab2 = &#123;<span class="string">&quot;zi&quot;</span>,a = <span class="number">5</span>,b = <span class="number">10</span>, c = <span class="number">15</span>,<span class="string">&quot;miao&quot;</span>,<span class="string">&quot;chumo&quot;</span>&#125;;</span><br><span class="line"><span class="comment">-- &#x27;杂表2&#x27;</span></span><br><span class="line"><span class="keyword">local</span> testTab3 = &#123;<span class="string">&quot;zi&quot;</span>,a = <span class="number">5</span>,b = <span class="number">10</span>, c = <span class="number">15</span>,<span class="string">&quot;miao&quot;</span>,<span class="literal">nil</span>,<span class="string">&quot;chumo&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ipairs testTab </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">pairs  testTab</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">--------------------------</span><br><span class="line">ipairs testTab1 </span><br><span class="line">pairs  testTab1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">--------------------------</span><br><span class="line">ipairs testTab2 </span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">chumo</span><br><span class="line">pairs  testTab2</span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">chumo</span><br><span class="line">5</span><br><span class="line">15</span><br><span class="line">10</span><br><span class="line">--------------------------</span><br><span class="line">ipairs testTab3 </span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">pairs  testTab3</span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">chumo</span><br><span class="line">5</span><br><span class="line">15</span><br><span class="line">10</span><br><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwlcsdn000/article/details/81291756">Lua系列–pairs和ipairs_lua pairs-CSDN博客</a></p>
<h2 id="Lua内存分布"><a href="#Lua内存分布" class="headerlink" title="Lua内存分布"></a>Lua内存分布</h2><h3 id="Lua深拷贝和浅拷贝"><a href="#Lua深拷贝和浅拷贝" class="headerlink" title="Lua深拷贝和浅拷贝"></a>Lua深拷贝和浅拷贝</h3><ul>
<li><p>如何实现浅拷贝<br>使用 = 运算符进行浅拷贝<br>分2种情况</p>
<ul>
<li>拷贝对象是string、number、bool基本类型。拷贝的过程就是复制黏贴！修改新拷贝出来的对象，不会影响原先对象的值，两者互不干涉</li>
<li>拷贝对象是table表，拷贝出来的对象和原先对象时同一个对象，占用同一个对象，只是一个人两个名字，类似C#引用地址，指向同一个堆里的数据~，两者任意改变都会影响对方.</li>
</ul>
</li>
<li><p>如何实现深拷贝</p>
<p>复制对象的基本类型，也复制源对象中的对象</p>
<p>常常需用对Table表进行深拷贝，赋值一个全新的一模一样的对象，但不是同一个表</p>
<p>Lua没有实现，封装一个函数，递归拷贝table中所有元素，以及设置metetable元表</p>
<p>如果key和value都不包含table属性，那么每次在泛型for内调用的Func就直接由if判断返回具体的key和value</p>
<p>如果有包含多重table属性，那么这段if判断就是用来解开下一层table的，最后层层递归返回。</p>
<p>核心逻辑：使用递归遍历表中的所有元素。</p>
<ul>
<li>先看copy方法中的代码，如果这个类型不是表的话，就没有遍历的必要，可以直接作为返回值赋值；</li>
<li>当前传入的变量是表，就新建一个表来存储老表中的数据，下面就是遍历老表，并分别将k,v赋值给新建的这个表，完成赋值后，将老表的元表赋值给新表。</li>
<li>在对k,v进行赋值时，同样要调用copy方法来判断一下是不是表，如果是表就要创建一个新表来接收表中的数据，以此类推并接近无限递归。</li>
</ul>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> numTest1=<span class="number">5</span></span><br><span class="line"><span class="keyword">local</span> numTest2=numTest1 <span class="comment">--使用 == 进行浅拷贝</span></span><br><span class="line"><span class="keyword">local</span> numTest2=<span class="number">10</span> <span class="comment">--修改numTest2，不会改变numTest1</span></span><br><span class="line"><span class="built_in">print</span>(numTest1) </span><br><span class="line"><span class="comment">--答案 5</span></span><br><span class="line"><span class="built_in">print</span>(numTest2) </span><br><span class="line"><span class="comment">--答案 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tab=&#123;&#125;</span><br><span class="line">tab[<span class="string">&quot;好好学习&quot;</span>]=<span class="string">&quot;游戏开发&quot;</span></span><br><span class="line">tab[<span class="string">&quot;热更&quot;</span>]=<span class="string">&quot;Xlua&quot;</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key..<span class="string">&quot;对应&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> temp = tab</span><br><span class="line">tab[<span class="string">&quot;好好学习&quot;</span>]=<span class="string">&quot;热更&quot;</span></span><br><span class="line">tab[<span class="string">&quot;热更&quot;</span>]=<span class="string">&quot;好好学习&quot;</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key..<span class="string">&quot;对应&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--输出答案，tab和temp都发生了改变</span></span><br><span class="line"><span class="comment">--热更对应Xlua</span></span><br><span class="line"><span class="comment">--好好学习对应游戏开发</span></span><br><span class="line"></span><br><span class="line">t=&#123;name=<span class="string">&quot;asd&quot;</span>,hp=<span class="number">100</span>,table1=&#123;<span class="built_in">table</span>=&#123;na=<span class="string">&quot;aaaaaaaa&quot;</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--实现深拷贝的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_Table</span><span class="params">(obj)</span></span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">(obj)</span></span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">type</span>(obj)  ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span>						<span class="comment">--对应代码梳理“1”  （代码梳理在下面）</span></span><br><span class="line">				<span class="keyword">return</span> obj;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">local</span> newTable=&#123;&#125;;									<span class="comment">--对应代码梳理“2”</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(obj) <span class="keyword">do</span></span><br><span class="line">				newTable[copy(k)]=copy(v);						<span class="comment">--对应代码梳理“3”</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">setmetatable</span>(newTable,<span class="built_in">getmetatable</span>(obj));</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> copy(obj)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a=copy_Table(t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1.先看copy方法中的代码，如果这个类型不是表的话，就没有遍历的必要，可以直接作为返回值赋值；</span></span><br><span class="line"><span class="comment">--2.当前传入的变量是表，就新建一个表来存储老表中的数据，下面就是遍历老表，并分别将k,v赋值给新建的这个表，完成赋值后，将老表的元表赋值给新表。</span></span><br><span class="line"><span class="comment">--3.在对k,v进行赋值时，同样要调用copy方法来判断一下是不是表，如果是表就要创建一个新表来接收表中的数据，以此类推并接近无限递归。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011229164/article/details/106816260?ops_request_misc=&request_id=&biz_id=102&utm_term=lua%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%AF%A6%E8%A7%A3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-106816260.pc_search_positive">Lua:实现和理解深拷贝_lua复制文件代码-CSDN博客</a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">deepCopy</span>(<span class="params"><span class="built_in">object</span></span>)</span></span><br><span class="line"><span class="function">    local lookup_table</span> = &#123;&#125;  -- 用于记录已拷贝的表（解决循环引用）</span><br><span class="line">    </span><br><span class="line">    local function _copy(obj)</span><br><span class="line">        -- 基础类型直接返回</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">type</span>(<span class="params">obj</span>) ~</span>= <span class="string">&quot;table&quot;</span> then</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        </span><br><span class="line">        -- 已拷贝过的对象直接返回</span><br><span class="line">        elseif lookup_table[obj] then</span><br><span class="line">            <span class="keyword">return</span> lookup_table[obj]</span><br><span class="line">        </span><br><span class="line">        -- 处理新表</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            local new_table = &#123;&#125;</span><br><span class="line">            lookup_table[obj] = new_table  -- 记录已拷贝的表</span><br><span class="line">            </span><br><span class="line">            -- 递归拷贝键值对（需同时处理 key 和 <span class="keyword">value</span>）</span><br><span class="line">            <span class="keyword">for</span> key, <span class="function"><span class="keyword">value</span> <span class="keyword">in</span> <span class="title">pairs</span>(<span class="params">obj</span>) <span class="keyword">do</span></span></span><br><span class="line"><span class="function">                new_table[_<span class="title">copy</span>(<span class="params">key</span>)]</span> = _copy(<span class="keyword">value</span>)</span><br><span class="line">            end</span><br><span class="line">            </span><br><span class="line">            -- 继承原表的元表（保留特殊行为）</span><br><span class="line">            <span class="keyword">return</span> setmetatable(new_table, getmetatable(obj))</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _copy(<span class="built_in">object</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="Upvalue"><a href="#Upvalue" class="headerlink" title="Upvalue"></a>Upvalue</h3><p>为下一节的闭包做准备：</p>
<ul>
<li>在lua中，会生成一个全局栈，所有的upvalue都会指向该栈中的值，若对应的参数离开的作用域，栈中的值也会被释放，upvalue的指针会指向自己，等待被gc</li>
<li>闭包运行时,会通过创建指向upvalue的指针,并循环upvalue linked list,找到所需要的外部变量进行运行</li>
<li>一个upvalue有两种状态: open和closed。当一个upvalue被创建时,它是open的，并且它的指针指向Lua栈中对应的变量。当Lua关闭了一个upvalue， upvalue指向的值被复制到upvalue结构内部，并且指针也相应进行调整</li>
</ul>
<h4 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h4><ol>
<li><p><strong>Upvalue 定义</strong></p>
<ul>
<li>闭包引用的<strong>外部局部变量</strong>（非函数参数或内部局部变量）。</li>
<li>当函数引用其外部作用域的局部变量时，该变量成为闭包的 Upvalue。</li>
</ul>
</li>
<li><p><strong>Upvalue 状态</strong></p>
<ul>
<li><p>Open 状态</p>
<ul>
<li><p>初始状态，直接指向 Lua 全局栈中的变量值。</p>
</li>
<li><p>变量存活期间，Upvalue 通过指针访问栈数据。</p>
</li>
</ul>
</li>
<li><p>Closed 状态</p>
<ul>
<li>外部变量离开作用域时触发状态转换。</li>
<li>值从栈复制到 Upvalue 内部存储，指针调整为指向内部数据。</li>
<li>等待垃圾回收（GC）释放内存。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>存储机制</strong></p>
<ul>
<li>Lua 维护<strong>全局栈</strong>管理局部变量，Upvalue 初始指向栈中位置。</li>
<li>闭包运行时通过<strong>循环 Upvalue 链表</strong>定位所需外部变量。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> x = <span class="number">10</span>  <span class="comment">-- x 成为 inner 的 Upvalue</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(x)  <span class="comment">-- 访问 Upvalue</span></span><br><span class="line">        x = x + <span class="number">1</span> <span class="comment">-- 修改 Upvalue</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> myInner = outer()  <span class="comment">-- outer 执行结束，x 离开作用域</span></span><br><span class="line">myInner()  <span class="comment">-- 输出 10（Closed Upvalue 内部存储值）</span></span><br><span class="line">myInner()  <span class="comment">-- 输出 11（修改 Closed Upvalue 的值）</span></span><br></pre></td></tr></table></figure>

<h4 id="三、关键过程解析"><a href="#三、关键过程解析" class="headerlink" title="三、关键过程解析"></a>三、关键过程解析</h4><ol>
<li><strong>Upvalue 捕获</strong><ul>
<li><code>inner</code> 在 <code>outer</code> 内部定义时，自动捕获外部变量 <code>x</code> 作为 Upvalue。</li>
<li>初始阶段，Upvalue 处于 <strong>Open 状态</strong>，直接指向 <code>outer</code> 栈帧中的 <code>x</code>。</li>
</ul>
</li>
<li><strong>状态转换</strong><ul>
<li>当 outer 执行完毕，其栈帧销毁：<ul>
<li>Upvalue <code>x</code> 转为 <strong>Closed 状态</strong>，值从栈复制到内部存储。</li>
<li>后续闭包调用通过 Closed Upvalue 访问数据。</li>
</ul>
</li>
</ul>
</li>
<li><strong>闭包持久性</strong><ul>
<li>即使 <code>outer</code> 已结束，闭包仍通过 Closed Upvalue 维持 <code>x</code> 的生命周期。</li>
<li>多次调用闭包可跨作用域读写同一 Upvalue 存储值。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="四、机制总结"><a href="#四、机制总结" class="headerlink" title="四、机制总结"></a>四、机制总结</h4><table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>行为</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>闭包定义时</td>
<td>创建 Open Upvalue 指向栈变量</td>
<td>变量存活期内直接引用栈数据</td>
</tr>
<tr>
<td>外部作用域结束</td>
<td>Upvalue 转为 Closed，复制值到内部存储</td>
<td>解除栈依赖，独立维护数据</td>
</tr>
<tr>
<td>闭包多次调用</td>
<td>通过 Closed Upvalue 读写内部存储</td>
<td>跨调用保持状态一致性</td>
</tr>
</tbody></table>
<blockquote>
<p>此机制使 Lua 闭包能高效管理外部变量，平衡内存安全与灵活性。</p>
</blockquote>
<h3 id="lua闭包"><a href="#lua闭包" class="headerlink" title="lua闭包"></a>lua闭包</h3><p>闭包=函数+引用环境<br>子函数可以使用父函数中的局部变量，这种行为可以理解为闭包！</p>
<p>1、闭包的数据隔离<br>不同实例上的两个不同闭包，闭包中的upvalue变量各自独立，从而实现数据隔离</p>
<p>2、闭包的数据共享<br>两个闭包共享一份变量upvalue，引用的是更外部函数的局部变量（即Upvlaue）,变量是同一个，引用也指向同一个地方，从而实现对共享数据进行访问和修改。</p>
<p>3、利用闭包实现简单的迭代器<br>迭代器只是一个生成器，他自己本身不带循环。我们还需要在循环里面去调用它才行。<br>1）while…do循环，每次调用迭代器都会产生一个新的闭包，闭包内部包括了upvalue(t,i,n)，闭包根据上一次的记录，返回下一个元素，实现迭代<br>2）for…in循环，只会产生一个闭包函数，后面每一次迭代都是使用该闭包函数。内部保存迭代函数、状态常量、控制变量。</p>
<hr>
<p>闭包：通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数（就是工厂）产生的一个实例函数</p>
<p>闭包组成：外部函数+外部函数创建的upvalue+内部函数（闭包函数）</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzy-frisrtblog/p/5864209.html">Lua的闭包详解（终于搞懂了） - 风雨缠舟 - 博客园 (cnblogs.com)</a></p>
<hr>
<p>闭包总结闭包的主要作用有两个，</p>
<p>一是简洁，不需要在不使用时生成对象，也不需要函数名；</p>
<p>二是捕获外部变量形成不同的调用环境</p>
<p>闭包原理概述：</p>
<p>闭包(函数)编译时会生成原型(prototype) ,包含参数、调试信息、虚拟机指令等一系列该闭包的源信息,其中在递归编辑内层函数时,会为内层函数生成指令,同时为该内层函数需要的所有upvalue创建表,以便之后调用时进行upvalue值搜索</p>
<p>在lua中，会生成一个全局栈，所有的upvalue都会指向该栈中的值，若对应的参数离开的作用域，栈中的值也会被释放，upvalue的指针会指向自己，等待被gc</p>
<p>闭包运行时，会通过创建指向upvalue的指针，并循环upvalue linked list，找到所需要的外部变量进行运行</p>
<h3 id="lua的GC算法"><a href="#lua的GC算法" class="headerlink" title="lua的GC算法"></a>lua的GC算法</h3><p>1、Lua的GC垃圾回收机制算法<br>Lua的GC使用了标记清除算法Mark and Sweep</p>
<p>标记：每一次执行GC前，从根节点开始遍历每一个相关节点，进行标记<br>清除：标记完成后，遍历对象链表，然后对需要执行清除标记的对象，进行清除</p>
<p>使用三色法：白，灰，黑，作为对象的三种状态<br>新白：可以回收的对象；新创建的对象，初始状态是新白，但不会被清除<br>旧白：可以回收的对象；lua只会清除旧白，GC后，会更新新白<br>灰色：等待回收的对象：该对象已被GC访问过，但该对象引用的其它对象还未标记<br>黑色：不可回收的对象</p>
<p>简单流程：<br>1.根对象开始标记，将白色对象重置为灰色对象，加入灰色链表<br>2.如果灰色链表不为空，取出一个对象，重置为黑色，并遍历相关引用的对象，重置为黑色<br>3.如果灰色链表为空，清除一次灰色链表<br>4.根据不同类型对象分布回收，类型的存储表<br>5.判断是否遍历到链表尾<br>6.判断对象是否为白色<br>7.将对象重置为白色<br>8.释放资源</p>
<p>伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 初始化阶段  </span><br><span class="line">将所有对象颜色设置为白色  </span><br><span class="line">创建一个灰色对象列表(<span class="type">List</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> 遍历root节点及其所有子对象：  </span><br><span class="line">     <span class="keyword">if</span> 如果对象颜色为白色：  </span><br><span class="line">          将对象颜色设置为灰色  </span><br><span class="line">          将对象添加到灰色对象列表的尾部  </span><br><span class="line">  </span><br><span class="line">// 标记阶段  </span><br><span class="line"><span class="keyword">while</span> 当灰色对象列表不为空时：  </span><br><span class="line">        从灰色对象列表中取出一个对象  </span><br><span class="line">        将对象颜色设置为黑色  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">while</span> 遍历该对象的所有引用对象：  </span><br><span class="line">    <span class="keyword">if</span> 如果引用对象颜色为白色：  </span><br><span class="line">         将引用对象颜色设置为灰色  </span><br><span class="line">         将引用对象添加到灰色对象链表(insert to head)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 回收阶段  </span><br><span class="line">遍历所有对象：  </span><br><span class="line">    <span class="keyword">if</span> 如果对象颜色为白色：  </span><br><span class="line">        该对象没有被引用，执行回收操作（释放内存等）</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	那么重新塞入到对象链表中，等待下一轮GC</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>Lua通过借助grey链表，依次利用reallymarkobject对对象进行了颜色的标记，之后通过遍历alloc链表，依次利用sweeplist清除需要回收的对象。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LJY_rookie/article/details/108141615">lua的GC原理_lua 那些炒作会触发gc-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144875092">Lua设计与实现–GC篇 - 知乎 (zhihu.com)</a></p>
<h3 id="lua协程"><a href="#lua协程" class="headerlink" title="lua协程"></a>lua协程</h3><table>
<thead>
<tr>
<th>coroutine.create()</th>
<th>创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</th>
</tr>
</thead>
<tbody><tr>
<td>coroutine.resume()</td>
<td>重启 coroutine，和 create 配合使用</td>
</tr>
<tr>
<td>coroutine.yield()</td>
<td>挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td>
</tr>
<tr>
<td>coroutine.status()</td>
<td>查看 coroutine 的状态 注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序</td>
</tr>
<tr>
<td>coroutine.wrap（）</td>
<td>创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td>
</tr>
<tr>
<td>coroutine.running()</td>
<td>返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 coroutine 的线程号</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- coroutine_test.lua 文件</span></span><br><span class="line"><span class="comment">-- 创建了一个新的协同程序对象 co，其中协同程序函数打印传入的参数 i</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 使用 coroutine.resume 启动协同程序 co 的执行，并传入参数 1。协同程序开始执行，打印输出为 1</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>)   <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 coroutine.status 检查协同程序 co 的状态，输出为 dead，表示协同程序已经执行完毕</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))  <span class="comment">-- dead</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 coroutine.wrap 创建了一个协同程序包装器，将协同程序函数转换为一个可直接调用的函数对象</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">co(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"><span class="comment">-- 创建了另一个协同程序对象 co2，其中的协同程序函数通过循环打印数字 1 到 10，在循环到 3 的时候输出当前协同程序的状态和正在运行的线程</span></span><br><span class="line">co2 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co2))  <span class="comment">--running</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>()) <span class="comment">--thread:XXXXXX</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连续调用 coroutine.resume 启动协同程序 co2 的执行</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co2) <span class="comment">--1</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co2) <span class="comment">--2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co2) <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 coroutine.status 检查协同程序 co2 的状态，输出为 suspended，表示协同程序暂停执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co2))   <span class="comment">-- suspended</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>())</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fragmentary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/22/0037-lua/">http://example.com/2024/07/22/0037-lua/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">零の領域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua/">lua</a></div><div class="post_share"><div class="social-share" data-image="/img/p_66349124.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/25/0038-CPP-STL/" title="C++ 之STL"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 之STL</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/19/0036-U3dSave-SO/" title="数据可持续化-ScriptableObject"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据可持续化-ScriptableObject</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/07/09/0070-lua5.4/" title="Lua 5.4 源码"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="title">Lua 5.4 源码</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/pixiv_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fragmentary</div><div class="author-info__description">一个摸鱼人的日常博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fragmentary1002"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Fragmentary1002" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://space.bilibili.com/165064718?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fa-solid fa-tv"></i></a><a class="social-icon" href="https://www.youtube.com/@mentaryFrag" target="_blank" title="youtube"><i class="fa-brands fa-youtube"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是一个博客~ 好吧这是我的学习笔记 一个Unity客户端开发者的日常</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">热更新的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Lua%E4%BD%9C%E4%B8%BA%E7%83%AD%E6%9B%B4%E6%96%B0%E8%AF%AD%E8%A8%80%EF%BC%8C%E4%B8%8D%E7%94%A8C"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用Lua作为热更新语言，不用C#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8C-%E7%83%AD%E6%9B%B4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.2.</span> <span class="toc-text">不用C#热更的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E7%83%AD%E6%9B%B4"><span class="toc-number">1.3.</span> <span class="toc-text">Lua热更</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua-%E7%83%AD%E6%9B%B4%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">lua 热更代码原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Lua互相调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8ELua%E4%BA%92%E8%B0%83%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">C#与Lua互调过程及性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%92%8Clua%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">C和lua的互相调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Lua数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%A1%A8%E6%A0%BC%EF%BC%88Table%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">Lua表格（Table）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table-%E8%A1%A5%E5%85%85"><span class="toc-number">4.</span> <span class="toc-text">table 补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E5%85%83%E8%A1%A8-Metatable"><span class="toc-number">4.1.</span> <span class="toc-text">Lua元表 (Metatable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-%E4%B8%8E-newindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">_index 与 _newindex的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">只读表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91%E9%81%BF%E5%85%8D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B3%9B%E6%BB%A5-%E2%80%93-gt-G%E8%A1%A8%E5%8F%AA%E8%AF%BB"><span class="toc-number">4.4.</span> <span class="toc-text">多人开发避免全局变量泛滥 –&gt;  _G表只读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rawset%E4%B8%8E-rawget-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.</span> <span class="toc-text">_rawset与**_rawget**的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-pairs-%E5%92%8C-ipairs%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.</span> <span class="toc-text">遍历:pairs 和 ipairs区别??</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">5.</span> <span class="toc-text">Lua内存分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.</span> <span class="toc-text">Lua深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Upvalue"><span class="toc-number">5.2.</span> <span class="toc-text">Upvalue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.1.</span> <span class="toc-text">一、核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">二、代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">三、关键过程解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93"><span class="toc-number">5.2.4.</span> <span class="toc-text">四、机制总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E9%97%AD%E5%8C%85"><span class="toc-number">5.3.</span> <span class="toc-text">lua闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E7%9A%84GC%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">lua的GC算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">lua协程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/24/0076-UEPython/" title="UE Python"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE Python"/></a><div class="content"><a class="title" href="/2025/08/24/0076-UEPython/" title="UE Python">UE Python</a><time datetime="2025-08-24T11:29:00.747Z" title="发表于 2025-08-24 19:29:00">2025-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/0075-UEDs/" title="UE 联机"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE 联机"/></a><div class="content"><a class="title" href="/2025/08/08/0075-UEDs/" title="UE 联机">UE 联机</a><time datetime="2025-08-07T16:00:00.000Z" title="发表于 2025-08-08 00:00:00">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/03/0073-UEBase/" title="UE基础"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE基础"/></a><div class="content"><a class="title" href="/2025/08/03/0073-UEBase/" title="UE基础">UE基础</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/03/0074-UELyra/" title="UE Lyra"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE Lyra"/></a><div class="content"><a class="title" href="/2025/08/03/0074-UELyra/" title="UE Lyra">UE Lyra</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/27/0072-UEAPI/" title="UE常见API"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE常见API"/></a><div class="content"><a class="title" href="/2025/07/27/0072-UEAPI/" title="UE常见API">UE常见API</a><time datetime="2025-07-27T01:16:49.000Z" title="发表于 2025-07-27 09:16:49">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Fragmentary</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>