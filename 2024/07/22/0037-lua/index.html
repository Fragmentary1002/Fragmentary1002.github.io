<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>unity热更新Lua | 零の領域</title><meta name="author" content="Fragmentary"><meta name="copyright" content="Fragmentary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lua热更新的原理为什么使用Lua作为热更新语言，不用C#​    热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。 ​    LUA是解释型语言，并不">
<meta property="og:type" content="article">
<meta property="og:title" content="unity热更新Lua">
<meta property="og:url" content="http://example.com/2024/07/22/0037-lua/index.html">
<meta property="og:site_name" content="零の領域">
<meta property="og:description" content="Lua热更新的原理为什么使用Lua作为热更新语言，不用C#​    热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。 ​    LUA是解释型语言，并不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/p_66349124.png">
<meta property="article:published_time" content="2024-07-22T09:28:17.000Z">
<meta property="article:modified_time" content="2025-03-04T15:49:07.383Z">
<meta property="article:author" content="Fragmentary">
<meta property="article:tag" content="unity-热更">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/p_66349124.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/22/0037-lua/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'unity热更新Lua',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-04 23:49:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/pixiv_cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/p_66349124.png')"><nav id="nav"><span id="blog-info"><a href="/" title="零の領域"><span class="site-name">零の領域</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">unity热更新Lua</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-22T09:28:17.000Z" title="发表于 2024-07-22 17:28:17">2024-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-04T15:49:07.383Z" title="更新于 2025-03-04 23:49:07">2025-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="unity热更新Lua"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><h2 id="热更新的原理"><a href="#热更新的原理" class="headerlink" title="热更新的原理"></a>热更新的原理</h2><h3 id="为什么使用Lua作为热更新语言，不用C"><a href="#为什么使用Lua作为热更新语言，不用C" class="headerlink" title="为什么使用Lua作为热更新语言，不用C#"></a>为什么使用Lua作为热更新语言，不用C#</h3><p>​    热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。</p>
<p>​    LUA是解释型语言，并不需要事先编译成块，而是运行时动态解释执行的。这样LUA就和普通的游戏资源如图片，文本没有区别，因此可以在运行时直接从WEB服务器上下载到持久化目录并被其它LUA文件调用。</p>
<h3 id="不用C-热更的原因"><a href="#不用C-热更的原因" class="headerlink" title="不用C#热更的原因"></a>不用C#热更的原因</h3><p>​    准确的说，C#在安卓上可以实现热更新，但在苹果上却不能。</p>
<p>​    那C#为什么不做成解释型语言呢？因为C#的定位是一个追求效率且功能强大的编译型语言。在安卓上可以通过C#的语言特性-反射机制实现动态代码加载从而实现热更新。<br>​<br>​    具体做法是：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。<br>​<br>​    但苹果对反射机制有限制，不能实现这样的热更。为什么限制反射机制？安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/murongxiaopifu/p/4278947.html">谁偷了我的热更新？Mono，JIT，iOS - 慕容小匹夫 - 博客园 (cnblogs.com)</a></p>
<h2 id="Lua数据结构"><a href="#Lua数据结构" class="headerlink" title="Lua数据结构"></a>Lua数据结构</h2><h3 id="Lua表格（Table）"><a href="#Lua表格（Table）" class="headerlink" title="Lua表格（Table）"></a>Lua表格（Table）</h3><p>Table的简单组成：<br>1.哈希表 用来存储Key-Value 键值对，当哈希表上有冲突的时候，会通过链表的方式组织冲突元素<br>2.数组 用来存储 数据（包括数字，表等）</p>
<ul>
<li><p><strong>数组部分</strong>:从1开始作为整数数字索引，这种设计使得数组能够提供紧凑且高效的随机访问。数组的存储位置位于 TValue *array 中，而数组的长度信息则存储在 int sizearray 中。</p>
</li>
<li><p><strong>哈希表</strong>：存储在 Node *node，哈希表的大小用 lu_byte lsizenode 表示，lsizenode表示的是2的几次幂，而不是实际大小，因为哈希表的大小一定是 2 的整数次幂。哈希冲突后，采取<strong>开放定址法</strong>，应对 <strong>hash 碰撞</strong>。</p>
</li>
</ul>
<p>每个 Table 结构最多由三块连续内存构成：</p>
<ul>
<li>一个 <strong>table</strong> 结构本身</li>
<li>一块存放了连续整数索引的<strong>数组</strong></li>
<li>以及一块大小为2的整数次幂的<strong>哈希表</strong></li>
</ul>
<p>在 Lua 中，table 会将部分整形 key 作为下标放在<strong>数组</strong>中，而其余的整形 key 和其他类型的 key 则都放在 <strong>hash 表</strong>中。</p>
<p> table中的hash表的实现结合了以上两种方法的一些特性：</p>
<ul>
<li>table 中的 hash 表实现结合了链地址法（拉链法）和开放定址法的特性。</li>
<li>它的查找和插入操作的复杂度与链地址法相当，而内存开销则近似于开放定址法。</li>
</ul>
<p>语法相关:</p>
<ul>
<li>table 是 Lua 的一种数据结构，用于帮助我们创建不同的数据类型，如：数组、字典等；</li>
<li>table 是一个关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil，所有索引值都需要用 “[“和”]” 括起来；如果是字符串，还可以去掉引号和中括号； 即如果没有[]括起，则认为是字符串索引，Lua table 是不固定大小的，你可以根据自己需要进行扩容；</li>
<li>table 的默认初始索引一般以 1 开始，如果不写索引，则索引就会被认为是数字，并按顺序自动从1往后编；</li>
<li>table 的变量只是一个地址引用，对 table 的操作不会产生数据影响；</li>
<li>table 不会固定长度大小，有新数据插入时长度会自动增长；</li>
<li>table 里保存数据可以是任何类型，包括function和table</li>
<li>table所有元素之间，总是用逗号 “，” 隔开</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y1196645376/article/details/94348873">【Lua 5.3源码】table实现分析_lua解析table-CSDN博客</a></p>
<h3 id="Lua元表-Metatable"><a href="#Lua元表-Metatable" class="headerlink" title="Lua元表 (Metatable)"></a>Lua元表 (Metatable)</h3><ul>
<li>什么是元表</li>
</ul>
<p>在Lua table中我们可以访问对应的key来得到value值，但是却无法对两个table进行操作。因此Lua 提供了<strong>元表(Metatable)<strong>，允许我们改变table的行为，每个行为关联了对应的元方法。通俗来说，</strong>元表就像是一个“操作指南”</strong>，里面包含了一系列操作的解决方案，例如 <strong>_index</strong>方法就是定义了这个表在索引失败的情况下该怎么办，**_add<strong>方法就是告诉table在相加的时候应该怎么做。这里面的</strong>_index<strong>，</strong>_add<strong>就是</strong>元方法**。</p>
<ul>
<li>有两个很重要的函数来处理元表：</li>
</ul>
<p>**setmetatable(table,metatable):**对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</p>
<p>**getmetatable(table):**返回对象的元表(metatable)。</p>
<ul>
<li>什么是元方法</li>
</ul>
<p>很多人对Lua中的元表和元方法都会有一个这样的误解：“<strong>如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员</strong>”。如果说这样去理解的话，就大错特错了，实际上即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil，原因就是B的**_index元方法<strong>没有赋值。别忘了我们之前说过的：“元表是一个操作指南”，定义了元表，只是有了操作指南，但不应该在操作指南里面去查找元素，而</strong>_index方法则是“操作指南”的“索引失败时该怎么办**。</p>
<p>下面是一些Lua表中可以重新定义的元方法:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__add</span>(a, b) <span class="comment">--加法</span></span><br><span class="line"><span class="built_in">__sub</span>(a, b) <span class="comment">--减法</span></span><br><span class="line"><span class="built_in">__mul</span>(a, b) <span class="comment">--乘法</span></span><br><span class="line"><span class="built_in">__div</span>(a, b) <span class="comment">--除法</span></span><br><span class="line"><span class="built_in">__mod</span>(a, b) <span class="comment">--取模</span></span><br><span class="line"><span class="built_in">__pow</span>(a, b) <span class="comment">--乘幂</span></span><br><span class="line"><span class="built_in">__unm</span>(a) <span class="comment">--相反数</span></span><br><span class="line"><span class="built_in">__concat</span>(a, b) <span class="comment">--连接</span></span><br><span class="line"><span class="built_in">__len</span>(a) <span class="comment">--长度</span></span><br><span class="line"><span class="built_in">__eq</span>(a, b) <span class="comment">--相等</span></span><br><span class="line"><span class="built_in">__lt</span>(a, b) <span class="comment">--小于</span></span><br><span class="line"><span class="built_in">__le</span>(a, b) <span class="comment">--小于等于</span></span><br><span class="line"><span class="built_in">__index</span>(a, b) <span class="comment">--索引查询</span></span><br><span class="line"><span class="built_in">__newindex</span>(a, b, c) <span class="comment">--索引更新（PS：不懂的话，后面会有讲）</span></span><br><span class="line"><span class="built_in">__call</span>(a, ...) <span class="comment">--执行方法调用</span></span><br><span class="line"><span class="built_in">__tostring</span>(a) <span class="comment">--字符串输出</span></span><br><span class="line"><span class="built_in">__metatable</span> <span class="comment">--保护元表</span></span><br></pre></td></tr></table></figure>



<ul>
<li>Lua的表元素查找机制</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">father = &#123;  </span><br><span class="line">    prop1=<span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line">father.<span class="built_in">__index</span> = father <span class="comment">-- 把father的__index方法指向它本身</span></span><br><span class="line">son = &#123;  </span><br><span class="line">    prop2=<span class="number">1</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">setmetatable</span>(son, father) <span class="comment">--把son的metatable设置为father  </span></span><br><span class="line"><span class="built_in">print</span> (son.prop1)</span><br><span class="line"><span class="comment">-- 输出为1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设father.__index = father 这句话不存在的话执行结果为nil，</p>
<p>这正印证了上面所说的，只设置元表是不管用的</p>
</blockquote>
<ul>
<li>在上面的例子中，当访问son.prop1时，son中是没有prop1这个成员的。接着Lua解释器发现son设置了元表：father</li>
<li><strong>需要注意的是：此时Lua并不是直接在fahter中找到名为prop1的成员，而是先调用father的__index方法</strong></li>
<li>如果fahter的**_index<strong>方法为nil，则直接返回nil（也就是</strong>father.__index = father** 这句话不存在）</li>
<li>但是如果**_index<strong>指向了一张表（上面的例子中father的</strong>_index**指向了自己本身也就是 <strong>father.__index = father</strong>）</li>
<li>那么就会到**_index**方法所指向的这个表中去查找名为prop1的成员,最终，我们在father表中找到了prop1成员</li>
<li>这里的**_index<strong>方法除了可以是一个表，也可以是一个函数，如果是函数的话，</strong>_index**方法被调用时会返回该函数的返回值</li>
</ul>
<p>总结 : Lua查找一个表元素的规则可以归纳为如下几个步骤：</p>
<ul>
<li>Step1:在表自身中查找，如果找到了就返回该元素，如果没找到则执行Step2；</li>
<li>Step2:判断该表是否有元表（操作指南），如果没有元表，则直接返回nil，如果有元表则继续执行Step3；</li>
<li>Step3:判断元表是否设置了有关索引失败的指南（**_index元方法<strong>），如果没有(</strong>_index为ni<strong>l)，则直接返回nil；如果有</strong>_index方法<strong>是一张表，则重复执行Step1-&gt;Step2-&gt;Step3；如果</strong>_index方法**是一个函数，则返回该函数的返回值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/msxh/p/7745553.html">【游戏开发】小白学Lua——从Lua查找表元素的过程看元表、元方法 - 马三小伙儿 - 博客园 (cnblogs.com)</a></p>
<h3 id="index-与-newindex的区别"><a href="#index-与-newindex的区别" class="headerlink" title="_index 与 _newindex的区别"></a>_index 与 _newindex的区别</h3><p>__newindex用于表的更新，__index用于表的查询。</p>
<p>如果访问不存在的数据，由**_index<strong>提供最终结果<br>如果对不存在的数据赋值，由</strong>_newindex**对数据进行赋值</p>
<ul>
<li><p> <strong>_index</strong> 元方法可以是一个函数，Lua语言就会以【表】和【不存在键】为参数调用该函数</p>
</li>
<li><p> <strong>_index</strong>元方法也可以是一个表，Lua语言就访问这个元表</p>
</li>
<li><p> 对表中不存在的值进行赋值的时候，解释器会查找**_newindex**</p>
</li>
<li><p><strong>_newindex</strong> 元方法如果是一个表，Lua语言就对这个元表的字段进行赋值</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meta=&#123;&#125;</span><br><span class="line">meta.<span class="built_in">__newindex</span>=&#123;&#125;</span><br><span class="line">myTable=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable,meta)</span><br><span class="line">myTable.val=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable.val)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出 nil</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我myTable.val=1 访问了myTable表中没有的属性val</p>
<p>然后引发了寻找_newinde表 </p>
<p>而_newindex指向了空表 { }</p>
<p>则输出nil</p>
</blockquote>
<ul>
<li><strong>_rawset</strong>与**_rawget**的区别</li>
</ul>
<table>
<thead>
<tr>
<th align="center">元方法</th>
<th align="center">描述</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>_rawget</strong></td>
<td align="center">访问table中的元素时，直接获取元素的值，不经过**_index**元方法。</td>
<td align="center">当不想通过**_index<strong>元方法查询值，而是直接获取table中元素的原始值时，使用</strong>_rawget**。</td>
</tr>
<tr>
<td align="center"><strong>_rawset</strong></td>
<td align="center">更新table中的元素时，直接设置新值，不执行**_newindex**元方法。</td>
<td align="center">当不想执行**_newindex<strong>元方法，而是直接设置table中元素的新值时，使用</strong>_rawset**。</td>
</tr>
</tbody></table>
<ul>
<li>怎么实现一个只读表</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">readonly</span><span class="params">(t)</span></span>  </span><br><span class="line">    <span class="keyword">local</span> newT = &#123;&#125;  </span><br><span class="line">    <span class="keyword">local</span> mt = &#123;  </span><br><span class="line">        <span class="built_in">__index</span> = t,  </span><br><span class="line">        <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>  </span><br><span class="line">            <span class="built_in">error</span>(<span class="string">&quot;别修改我！我是只读的！&quot;</span>)  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">setmetatable</span>(newT, mt)  </span><br><span class="line">    <span class="keyword">return</span> newT  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">local</span> days = readonly(&#123;<span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期日&quot;</span>&#125;)  </span><br><span class="line">days[<span class="number">2</span>] = <span class="string">&quot;星期三哪去了啊？&quot;</span> <span class="comment">-- 这行将会触发错误</span></span><br></pre></td></tr></table></figure>







<h3 id="遍历-pairs-和-ipairs区别"><a href="#遍历-pairs-和-ipairs区别" class="headerlink" title="遍历:pairs 和 ipairs区别??"></a>遍历:pairs 和 ipairs区别??</h3><ul>
<li> 自定义索引</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;[<span class="number">0</span>]=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">-1</span>]=<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">-1</span>]) <span class="comment">--4</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])  <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])  <span class="comment">--2</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>])  <span class="comment">--3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>])  <span class="comment">--5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为底层实现的原因 导致索引就处理一位，其他的按照顺序放入数组中</p>
</blockquote>
<p>也就是：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>数值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>4</td>
<td>自定义索引-1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>自定义索引0</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>第一个自定义索引0额外的属性2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>第一个自定义索引0额外的属性3</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>第二个自定义索引-1额外的属性5</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>pairs</td>
<td>迭代 table，可以遍历表中所有的 key 可以返回 nil</td>
<td>pairs会遍历所有key，对于key的类型没有要求，遇到nil时可以跳过，不会影响后面的遍历，既可以遍历数组部分，又能遍历哈希部分。</td>
</tr>
<tr>
<td>ipairs</td>
<td>迭代数组，不能返回 nil,如果遇到 nil 则退出</td>
<td>ipairs只会从1开始，步进1，只能遍历数组部分， 中间不是数字的key忽略, 到第一个不连续的数字为止（不含），遍历时只能取key为整数值，遇到nil时终止遍历。</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;[<span class="number">1</span>]=<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>]=<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>]=<span class="number">5</span>,[<span class="number">6</span>]=<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ipairs&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index..<span class="string">&quot;_&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pairs&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key..<span class="string">&quot;_&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--答案是ipairs [2 4 3] , pairs [2 4 3 6 5] 无序 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这边存在一点问题,对于[1]=1,2 这个怎么处理</p>
</blockquote>
<p>输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipairs</span></span><br><span class="line"><span class="number">1</span>_2</span><br><span class="line"><span class="number">2</span>_4</span><br><span class="line"><span class="number">3</span>_3</span><br><span class="line"><span class="built_in">pairs</span></span><br><span class="line"><span class="number">1</span>_2</span><br><span class="line"><span class="number">3</span>_3</span><br><span class="line"><span class="number">5</span>_5</span><br><span class="line"><span class="number">6</span>_6</span><br><span class="line"><span class="number">2</span>_4</span><br></pre></td></tr></table></figure>







<blockquote>
<p>所以当ipairs遍历table时，从键值对索引值[1]开始连续递增，当键值对索引值[ ]断开或遇到nil时退出，所以上面的例子中ipairs遍历出的结果是2，4，3。</p>
</blockquote>
<blockquote>
<p>而pairs遍历时，会遍历表中的所有键值对，先按照索引值输出数组，在输出其它键值对，且元素是根据哈希算法来排序的，得到的不一定是连续的，所以pairs遍历出的结果是2，4，3，6，5。</p>
</blockquote>
<ul>
<li>对于数字和表混合的内容俩者又有什么区别呢</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> testTab =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">-- &#x27;纯表&#x27;</span></span><br><span class="line"><span class="keyword">local</span> testTab1 = &#123;a = <span class="number">1</span>, b = <span class="number">2</span>, c =<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">-- &#x27;杂表1&#x27;</span></span><br><span class="line"><span class="keyword">local</span> testTab2 = &#123;<span class="string">&quot;zi&quot;</span>,a = <span class="number">5</span>,b = <span class="number">10</span>, c = <span class="number">15</span>,<span class="string">&quot;miao&quot;</span>,<span class="string">&quot;chumo&quot;</span>&#125;;</span><br><span class="line"><span class="comment">-- &#x27;杂表2&#x27;</span></span><br><span class="line"><span class="keyword">local</span> testTab3 = &#123;<span class="string">&quot;zi&quot;</span>,a = <span class="number">5</span>,b = <span class="number">10</span>, c = <span class="number">15</span>,<span class="string">&quot;miao&quot;</span>,<span class="literal">nil</span>,<span class="string">&quot;chumo&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ipairs testTab </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">pairs  testTab</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">--------------------------</span><br><span class="line">ipairs testTab1 </span><br><span class="line">pairs  testTab1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">--------------------------</span><br><span class="line">ipairs testTab2 </span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">chumo</span><br><span class="line">pairs  testTab2</span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">chumo</span><br><span class="line">5</span><br><span class="line">15</span><br><span class="line">10</span><br><span class="line">--------------------------</span><br><span class="line">ipairs testTab3 </span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">pairs  testTab3</span><br><span class="line">zi</span><br><span class="line">miao</span><br><span class="line">chumo</span><br><span class="line">5</span><br><span class="line">15</span><br><span class="line">10</span><br><span class="line">--------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwlcsdn000/article/details/81291756">Lua系列–pairs和ipairs_lua pairs-CSDN博客</a></p>
<h2 id="Lua类与对象"><a href="#Lua类与对象" class="headerlink" title="Lua类与对象"></a>Lua类与对象</h2><h3 id="Lua中-点和冒号区别"><a href="#Lua中-点和冒号区别" class="headerlink" title="Lua中 点和冒号区别"></a>Lua中 点和冒号区别</h3><p> 点  ：无法传递自身，需要显示传递</p>
<p> 冒号 ：隐式传递自身</p>
<h3 id="类与对象写法"><a href="#类与对象写法" class="headerlink" title="类与对象写法"></a>类与对象写法</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Object = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line">    <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line"></span><br><span class="line">    obj.base = <span class="built_in">self</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 实现方法</span></span><br><span class="line">funciton ChildClass:DoSomething()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Object DoSomething&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ChildClass =Object:subClass(<span class="string">&quot;ChildClass&quot;</span>)</span><br><span class="line"></span><br><span class="line">ChildClass.x=<span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">ChildClass.vector=&#123;&#125;</span><br><span class="line"></span><br><span class="line">funciton ChildClass:OnInit()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重定义父类的方法，相当于override</span></span><br><span class="line">funciton ChildClass:DoSomething()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;ChildClass DoSomething&quot;</span>)</span><br><span class="line">	<span class="built_in">self</span>.OnInit()</span><br><span class="line">	<span class="built_in">self</span>.vector:OtherClassFun()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Class.lua</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--类：属性，构造函数，成员，属性等等</span></span><br><span class="line"><span class="comment">--类的声明，属性，初始值</span></span><br><span class="line">class = &#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125;</span><br><span class="line"><span class="comment">--设置元表的索引，要模拟类，这一步最重要</span></span><br><span class="line">class.<span class="built_in">__index</span> = class <span class="comment">--表的元表索引是自己</span></span><br><span class="line"><span class="comment">--构造方法，习惯性命名new（）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class:new</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = &#123;&#125; <span class="comment">--初始化t，如果没有这一句，会导致类所建立的对象一旦发生改变，其它对象都会改变</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(t, class) <span class="comment">--设置t的元表为class ， 把class设为t的原型</span></span><br><span class="line">    t.x = x <span class="comment">--属性值初始化</span></span><br><span class="line">    t.y = y</span><br><span class="line">    <span class="keyword">return</span> t <span class="comment">--返回自身</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--这里定义类的其它方法，self标识是非常重要的核心点，冒号：隐藏了self参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.x, <span class="built_in">self</span>.y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class:plus</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.x = <span class="built_in">self</span>.x + <span class="number">1</span></span><br><span class="line">    <span class="built_in">self</span>.y = <span class="built_in">self</span>.y + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SubClass.lua</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;Class&quot;</span>)</span><br><span class="line"><span class="comment">--类的继承</span></span><br><span class="line">SubClass = &#123;z = <span class="number">0</span>&#125;</span><br><span class="line"> <span class="comment">--声明新的属性Z</span></span><br><span class="line"><span class="comment">--两步完成类Class的继承</span></span><br><span class="line"><span class="built_in">setmetatable</span>(SubClass, Class)</span><br><span class="line"> <span class="comment">--设置类型是class</span></span><br><span class="line">SubClass.<span class="built_in">__index</span> = SubClass <span class="comment">--设置表的索引为自身</span></span><br><span class="line"><span class="comment">--构造方法，习惯性命名new（）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass:new</span><span class="params">(x, y, z)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = &#123;&#125; <span class="comment">--初始化对象自身</span></span><br><span class="line">    t = Class:new(x, y) <span class="comment">--将对象自身设定为父类，相当于C#里的base</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(t, SubClass) <span class="comment">--将对象自身元表设定为SubClass</span></span><br><span class="line">    t.z = z <span class="comment">--新属性赋值</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--定义一个新的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass:go</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.x = <span class="built_in">self</span>.x + <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--重定义父类的方法，相当于override</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.x, <span class="built_in">self</span>.y, <span class="built_in">self</span>.z)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- main.lua</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;Class&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;SubClass&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> a = Class:new() <span class="comment">-- 首先实例化父类，并调用父类方法</span></span><br><span class="line">a:plus()</span><br><span class="line">a:test()</span><br><span class="line"></span><br><span class="line">a=SubClass:new() <span class="comment">-- 然后实例化子类对象</span></span><br><span class="line">a:plus() <span class="comment">--重写</span></span><br><span class="line">a:go()   <span class="comment">--新增</span></span><br><span class="line">a:test()  <span class="comment">--重写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Lua互相调用"><a href="#Lua互相调用" class="headerlink" title="Lua互相调用"></a>Lua互相调用</h2><h3 id="C和lua的互相调用"><a href="#C和lua的互相调用" class="headerlink" title="C和lua的互相调用"></a>C和lua的互相调用</h3><ul>
<li><p>如果我们想要理解Lua语言与其它语言交互的实质，我们首先就要理解Lua堆栈。</p>
</li>
<li><p>简单来说，Lua语言之所以能和C/C++进行交互，主要是因为存在这样一个无处不在的虚拟栈。</p>
</li>
<li><p>栈的特点是先进后出，在Lua语言中，Lua堆栈是一种索引可以是正数或者负数的结构，并规定正数1永远表示栈底，负数-1永远表示栈顶。</p>
</li>
<li><p>换句话说呢，在不知道栈大小的情况下，我们可以通过索引-1取得栈底元素、通过索引1取得栈顶元素。</p>
</li>
</ul>
<ul>
<li><p>C和Lua之间的差异<br>1.Lua有垃圾回收机制，C需要显示释放内存<br>2.Lua是动态类型，弱类型语言【运行时确认】，C是静态类型，强类型语言。【编译时确认】</p>
</li>
<li><p>C与Lua的通信使用了虚拟栈结构！！！<br>以下是简单的虚拟栈概念！<br>将2个数据压入虚拟栈</p>
</li>
</ul>
<p>当使用正数索引时，表示从栈底开始，一直到栈顶 ，使用负数索引时表示从栈顶开始，一直到栈底。<br>通过指定索引来出栈和入栈</p>
<ul>
<li><p>C#调用Lua</p>
<p>是依靠C作为中间语言，通过C#调用C，C再调用Lua实现的 而框架中的tolua.dll等也就是借助LuaInterface封装的C语言动态库</p>
</li>
</ul>
<p>使用C++调用Lua时我们可以直接利用C++中的Lua环境来直接Lua脚本，例如我们在外部定义了一个lua脚本文件，我们现在需要使用C++来访问这个脚本该怎么做呢？在这里我们可以使用luaL_loadfile()、luaL_dofile()这两个方法个方法来实现，其区别是前者仅加载脚本文件而后者会在加载的同时调用脚本文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化Lua状态机并加载基础库  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_lua</span><span class="params">(lua_State* L)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	luaL_openlibs(L); <span class="comment">// 打开所有标准库  </span></span><br><span class="line">	<span class="comment">// 以下函数是Lua 5.1及之前版本的，但在Lua 5.2及之后版本已被废弃，因为luaL_openlibs已经包括了这些库  </span></span><br><span class="line">	<span class="comment">// luaopen_base(L); // 打开基础库（已废弃）  </span></span><br><span class="line">	<span class="comment">// luaopen_table(L); // 打开表库（已废弃）  </span></span><br><span class="line">	<span class="comment">// luaopen_string(L); // 打开字符串库（已废弃）  </span></span><br><span class="line">	<span class="comment">// luaopen_math(L); // 打开数学库（已废弃）  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C函数：加法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_add</span><span class="params">(lua_State* L)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> a = lua_tonumber(L, <span class="number">-2</span>); <span class="comment">// 获取栈顶第二个元素（即第一个参数）  </span></span><br><span class="line">	<span class="type">int</span> b = lua_tonumber(L, <span class="number">-1</span>); <span class="comment">// 获取栈顶元素（即第二个参数）  </span></span><br><span class="line">	<span class="type">int</span> c = a + b;  </span><br><span class="line">	lua_pushnumber(L, c); <span class="comment">// 将结果压入栈顶  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回给Lua一个结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C函数：自增  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_step</span><span class="params">(lua_State* L)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> a = lua_tonumber(L, <span class="number">-1</span>); <span class="comment">// 获取栈顶元素  </span></span><br><span class="line">	<span class="type">int</span> c = a + <span class="number">1</span>;  </span><br><span class="line">	lua_pushnumber(L, c); <span class="comment">// 将结果压入栈顶  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回给Lua一个结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注册到Lua的C函数列表  </span></span><br><span class="line">luaL_Reg mylib[] =   </span><br><span class="line">&#123;  </span><br><span class="line">	&#123;<span class="string">&quot;c_add&quot;</span>, c_add&#125;,  </span><br><span class="line">	&#123;<span class="string">&quot;c_step&quot;</span>, c_step&#125;,  </span><br><span class="line">	&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125; <span class="comment">// 列表结束标志  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	lua_State *L = lua_open(); <span class="comment">// 创建一个新的Lua状态机  </span></span><br><span class="line">	init_lua(L); <span class="comment">// 初始化Lua状态机并加载基础库  </span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 加载Lua脚本文件  </span></span><br><span class="line">	<span class="keyword">if</span> (luaL_loadfile(L, <span class="string">&quot;test.lua&quot;</span>) != <span class="number">0</span>) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;加载Lua文件失败\n&quot;</span>);  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 运行加载的Lua脚本  </span></span><br><span class="line">	<span class="keyword">if</span> (lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;运行Lua脚本失败: %s\n&quot;</span>, lua_tostring(L, <span class="number">-1</span>));  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 注册C函数到Lua的&quot;mylib&quot;表中  </span></span><br><span class="line">	luaL_register(L, <span class="string">&quot;mylib&quot;</span>, mylib);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// C调用Lua函数  </span></span><br><span class="line">	lua_getglobal(L, <span class="string">&quot;l_ff&quot;</span>); <span class="comment">// 获取全局变量&quot;l_ff&quot;（假设是Lua中定义的函数）  </span></span><br><span class="line">	lua_pushnumber(L, <span class="number">2</span>); <span class="comment">// 压入第一个参数  </span></span><br><span class="line">	lua_pushnumber(L, <span class="number">3</span>); <span class="comment">// 压入第二个参数  </span></span><br><span class="line">	<span class="keyword">if</span> (lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123; <span class="comment">// 调用Lua函数，传入2个参数，期望返回1个结果  </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;调用Lua函数失败: %s\n&quot;</span>, lua_tostring(L, <span class="number">-1</span>));  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="type">int</span> res = lua_tonumber(L, <span class="number">-1</span>); <span class="comment">// 从栈顶获取Lua函数返回的结果  </span></span><br><span class="line">	lua_pop(L, <span class="number">1</span>); <span class="comment">// 弹出栈顶元素，清理栈  </span></span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;在C中得到的结果: %d\n&quot;</span>, res);  </span><br><span class="line">  </span><br><span class="line">	lua_close(L); <span class="comment">// 关闭Lua状态机  </span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Lua调用C<br>调用之前需要注册，将函数地址告知Lua<br>LuaFramework的框架中Lua要调用Unity自带的API或者我们自己写的脚本之前要先生成对应的XXXWrap文件，就是如上面例子一样，需要在lua里进行注册。</li>
</ul>
<p> 首先我们在C++中定义一个方法，该方法必须以Lua_State作为参数，返回值类型为int，表示要返回的值的数目。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua函数：l_ff  </span></span><br><span class="line"><span class="comment">-- 接受两个参数a和b  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l_ff</span><span class="params">(a, b)</span></span>  </span><br><span class="line">	<span class="comment">-- 调用C库中的c_add函数，将a和b相加，结果加1后赋值给局部变量c  </span></span><br><span class="line">	<span class="keyword">local</span> c = mylib.c_add(a, b) + <span class="number">1</span>  </span><br><span class="line">	<span class="comment">-- 打印变量c的值  </span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;在Lua中: &quot;</span>, c)  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">-- 调用C库中的c_step函数，将变量c的值加1后赋值给局部变量d  </span></span><br><span class="line">	<span class="keyword">local</span> d = mylib.c_step(c)  </span><br><span class="line">	<span class="comment">-- 打印变量d的值  </span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;在Lua中: &quot;</span>, d)  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">-- 返回变量d的值给调用者  </span></span><br><span class="line">	<span class="keyword">return</span> d  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>这些api的名字很怪异，常常没法从名字知道这个函数是做什么的。</p>
<p>lua_getglobal是从lua脚本里面取一个全局变量放到堆栈上（c和lua之间是通过虚拟的堆栈来互相沟通的）。</p>
<p>lua_pushnumber是把一个数字放到堆栈上。</p>
<p>lua_pcall是从当前堆栈进行函数调用。</p>
<p>lua_tonumber这个是把堆栈中的某个值作为int取出来（因为l_ff有返回值，因此堆栈最顶上就是函数的返回值）</p>
<p>在函数c_add里面，lua_pushnumber才是lua调用的返回值（在lua里面，同样是把把栈最顶上的位置当作返回值）</p>
<p>总结：</p>
<ul>
<li>Lua和C++是通过一个虚拟栈来交互的。</li>
<li>C++调用Lua实际上是：由C++先把数据放入栈中，由Lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回C++。</li>
<li>Lua调C++也一样：先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwwsq/article/details/7835619">C和lua的互相调用_conky lua 互相调用-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sevenyuan/p/4511808.html">Lua和C++交互详细总结 - Bill Yuan - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/slysky/p/7919114.html">整理]Unity3D游戏开发之Lua - Ming明、 - 博客园 (cnblogs.com)</a></p>
<h3 id="C-与Lua交互过程和原理？"><a href="#C-与Lua交互过程和原理？" class="headerlink" title="C#与Lua交互过程和原理？"></a>C#与Lua交互过程和原理？</h3><p>Wrap文件：每一个Wrap文件都是对一个C#类的包装。</p>
<ul>
<li>交互过程</li>
</ul>
<p>C# Call Lua交互过程<br>C#文件先调用Lua的解析器底层的dll库（C语言编写），再由DLL文件执行相应的Lua文件</p>
<p>Lua Call C# 交互过程<br>1.Wrap方式：首先生成C#源文件对应的Wrap文件，Lua文件会调用生成的Wrap文件，再由Wrap文件去调用C#文件。<br>2.反射方式：当索引系统API、DLL库或者第三方库，如果无法将代码具体实现进行代码生成，可通过反射来获取，执行效率较低。</p>
<ul>
<li>交互原理</li>
</ul>
<p>C#与Lua交互原理：虚拟栈！！！<br>交互通过虚拟栈实现，栈的索引分为正数和负数，如果索引是正数，则1表示栈底，如果索引是负数，则-1表示在栈顶</p>
<p>C# Call Lua交互原理<br>C#先将数据放入栈中，然后Lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#</p>
<p>Lua Call C#交互原理<br>C#源文件生成Wrap文件、或C#源文件生成C模块，将Wrap文件和C模块注册到Lua的解析器中，最后再由Lua去调用这个模块的函数~</p>
<ul>
<li>代码文件方面</li>
</ul>
<p>lua调用C#过程：<br>lua-&gt;wrap-&gt;C#<br>先生成Wrap文件（中间文件/适配文件），wrap文件把字段方法，注册到lua虚拟机中（解释器luajit），然后lua通过wrap就可以调C#了、或者在config文件中添加相应类型也可以</p>
<p>C#调用Lua过程：<br>C#生成Bridge文件，Bridge调dll文件（dll是用C写的库），先调用lua中dll文件，由dll文件执行lua代码<br>C#-&gt;Bridge-&gt;dll-&gt;Lua 或 C#-&gt;dll-&gt;Lua</p>
<p>从内存方面解释：</p>
<p>说白了就是对栈进行操作<br>C# Call Lua：C#把请求或数据放在栈顶，然后lua从栈顶取出该数据，在lua中做出相应处理（查询，改变），然后把处理结果放回栈顶，最后C#再从栈顶取出lua处理完的数据，完成交互。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54476817/article/details/132654801">Lua与C#的相互调用（xLua）_c# lua-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_14914623/article/details/89513031">C#与Lua交互过程及原理_lua和c#如何交互-CSDN博客</a></p>
<h3 id="Lua热更"><a href="#Lua热更" class="headerlink" title="Lua热更"></a>Lua热更</h3><p>大家或许会想，Lua到底可以做什么呢？在《Lua游戏开发》一书中作者已经告诉了我们答案：</p>
<p>1、编辑游戏的用户界面<br>2、定义、存储和管理基础游戏数据<br>3、管理实时游戏事件<br>4、创建和维护开发者友好的游戏存储和载入系统<br>5、编写游戏的人工智能系统<br>6、创建功能原型，可以之后用高性能语言移植</p>
<p>lua一大作用就是提供代码热更新</p>
<p>那么怎么实现热更新呢？</p>
<ul>
<li><p>导出函数require（mode_name）</p>
</li>
<li><p>查询全局缓存表package.loaded</p>
</li>
<li><p>通过package.searchers查找加载器</p>
</li>
<li><p>package.loaded<br>存储已经被加载的模块：当require一个mode_name模块得到的结果不为假时，require返回这个存储的值。require从package.loader中获得的值仅仅是对那张表（模块）的引用，改变这个值并不会改变require使用的表（模块）。</p>
</li>
<li><p>package.preload<br>保存一些特殊模块的加载器：这里面的值仅仅是对那张表（模块）的引用，改变这个值并不会改变require使用的表（模块）。</p>
</li>
<li><p>package.searchers<br>require查找加载器的表：这个表内的每一项都是一个查找器函数。当加载一个模块时，require按次序调用这些查找器，传入modname作为唯一参数。此方法会返回一个函数（模块的加载器）和一个传给这个加载器的参数。或返回一个描述为什么没有找到这个模块的字符串或者nil。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xufeng0991/article/details/52473602">https://blog.csdn.net/xufeng0991/article/details/52473602</a></p>
<h2 id="Lua内存分布"><a href="#Lua内存分布" class="headerlink" title="Lua内存分布"></a>Lua内存分布</h2><h3 id="Lua深拷贝和浅拷贝"><a href="#Lua深拷贝和浅拷贝" class="headerlink" title="Lua深拷贝和浅拷贝"></a>Lua深拷贝和浅拷贝</h3><ul>
<li><p>如何实现浅拷贝<br>使用 = 运算符进行浅拷贝<br>分2种情况</p>
<ul>
<li>拷贝对象是string、number、bool基本类型。拷贝的过程就是复制黏贴！修改新拷贝出来的对象，不会影响原先对象的值，两者互不干涉</li>
<li>拷贝对象是table表，拷贝出来的对象和原先对象时同一个对象，占用同一个对象，只是一个人两个名字，类似C#引用地址，指向同一个堆里的数据~，两者任意改变都会影响对方.</li>
</ul>
</li>
<li><p>如何实现深拷贝</p>
<p>复制对象的基本类型，也复制源对象中的对象</p>
<p>常常需用对Table表进行深拷贝，赋值一个全新的一模一样的对象，但不是同一个表</p>
<p>Lua没有实现，封装一个函数，递归拷贝table中所有元素，以及设置metetable元表</p>
<p>如果key和value都不包含table属性，那么每次在泛型for内调用的Func就直接由if判断返回具体的key和value</p>
<p>如果有包含多重table属性，那么这段if判断就是用来解开下一层table的，最后层层递归返回。</p>
<p>核心逻辑：使用递归遍历表中的所有元素。</p>
<ul>
<li>先看copy方法中的代码，如果这个类型不是表的话，就没有遍历的必要，可以直接作为返回值赋值；</li>
<li>当前传入的变量是表，就新建一个表来存储老表中的数据，下面就是遍历老表，并分别将k,v赋值给新建的这个表，完成赋值后，将老表的元表赋值给新表。</li>
<li>在对k,v进行赋值时，同样要调用copy方法来判断一下是不是表，如果是表就要创建一个新表来接收表中的数据，以此类推并接近无限递归。</li>
</ul>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> numTest1=<span class="number">5</span></span><br><span class="line"><span class="keyword">local</span> numTest2=numTest1 <span class="comment">--使用 == 进行浅拷贝</span></span><br><span class="line"><span class="keyword">local</span> numTest2=<span class="number">10</span> <span class="comment">--修改numTest2，不会改变numTest1</span></span><br><span class="line"><span class="built_in">print</span>(numTest1) </span><br><span class="line"><span class="comment">--答案 5</span></span><br><span class="line"><span class="built_in">print</span>(numTest2) </span><br><span class="line"><span class="comment">--答案 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tab=&#123;&#125;</span><br><span class="line">tab[<span class="string">&quot;好好学习&quot;</span>]=<span class="string">&quot;游戏开发&quot;</span></span><br><span class="line">tab[<span class="string">&quot;热更&quot;</span>]=<span class="string">&quot;Xlua&quot;</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key..<span class="string">&quot;对应&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> temp = tab</span><br><span class="line">tab[<span class="string">&quot;好好学习&quot;</span>]=<span class="string">&quot;热更&quot;</span></span><br><span class="line">tab[<span class="string">&quot;热更&quot;</span>]=<span class="string">&quot;好好学习&quot;</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key..<span class="string">&quot;对应&quot;</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--输出答案，tab和temp都发生了改变</span></span><br><span class="line"><span class="comment">--热更对应Xlua</span></span><br><span class="line"><span class="comment">--好好学习对应游戏开发</span></span><br><span class="line"></span><br><span class="line">t=&#123;name=<span class="string">&quot;asd&quot;</span>,hp=<span class="number">100</span>,table1=&#123;<span class="built_in">table</span>=&#123;na=<span class="string">&quot;aaaaaaaa&quot;</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--实现深拷贝的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_Table</span><span class="params">(obj)</span></span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">(obj)</span></span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">type</span>(obj)  ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span>						<span class="comment">--对应代码梳理“1”  （代码梳理在下面）</span></span><br><span class="line">				<span class="keyword">return</span> obj;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">local</span> newTable=&#123;&#125;;									<span class="comment">--对应代码梳理“2”</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(obj) <span class="keyword">do</span></span><br><span class="line">				newTable[copy(k)]=copy(v);						<span class="comment">--对应代码梳理“3”</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">setmetatable</span>(newTable,<span class="built_in">getmetatable</span>(obj));</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> copy(obj)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a=copy_Table(t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(k,v);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1.先看copy方法中的代码，如果这个类型不是表的话，就没有遍历的必要，可以直接作为返回值赋值；</span></span><br><span class="line"><span class="comment">--2.当前传入的变量是表，就新建一个表来存储老表中的数据，下面就是遍历老表，并分别将k,v赋值给新建的这个表，完成赋值后，将老表的元表赋值给新表。</span></span><br><span class="line"><span class="comment">--3.在对k,v进行赋值时，同样要调用copy方法来判断一下是不是表，如果是表就要创建一个新表来接收表中的数据，以此类推并接近无限递归。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011229164/article/details/106816260?ops_request_misc=&request_id=&biz_id=102&utm_term=lua%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%AF%A6%E8%A7%A3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-106816260.pc_search_positive">Lua:实现和理解深拷贝_lua复制文件代码-CSDN博客</a></p>
<h3 id="lua闭包"><a href="#lua闭包" class="headerlink" title="lua闭包"></a>lua闭包</h3><p>闭包=函数+引用环境<br>子函数可以使用父函数中的局部变量，这种行为可以理解为闭包！</p>
<p>1、闭包的数据隔离<br>不同实例上的两个不同闭包，闭包中的upvalue变量各自独立，从而实现数据隔离</p>
<p>2、闭包的数据共享<br>两个闭包共享一份变量upvalue，引用的是更外部函数的局部变量（即Upvlaue）,变量是同一个，引用也指向同一个地方，从而实现对共享数据进行访问和修改。</p>
<p>3、利用闭包实现简单的迭代器<br>迭代器只是一个生成器，他自己本身不带循环。我们还需要在循环里面去调用它才行。<br>1）while…do循环，每次调用迭代器都会产生一个新的闭包，闭包内部包括了upvalue(t,i,n)，闭包根据上一次的记录，返回下一个元素，实现迭代<br>2）for…in循环，只会产生一个闭包函数，后面每一次迭代都是使用该闭包函数。内部保存迭代函数、状态常量、控制变量。</p>
<hr>
<p>闭包：通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数（就是工厂）产生的一个实例函数</p>
<p>闭包组成：外部函数+外部函数创建的upvalue+内部函数（闭包函数）</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzy-frisrtblog/p/5864209.html">Lua的闭包详解（终于搞懂了） - 风雨缠舟 - 博客园 (cnblogs.com)</a></p>
<h3 id="lua的GC算法"><a href="#lua的GC算法" class="headerlink" title="lua的GC算法"></a>lua的GC算法</h3><p>1、Lua的GC垃圾回收机制算法<br>Lua的GC使用了标记清除算法Mark and Sweep</p>
<p>标记：每一次执行GC前，从根节点开始遍历每一个相关节点，进行标记<br>清除：标记完成后，遍历对象链表，然后对需要执行清除标记的对象，进行清除</p>
<p>使用三色法：白，灰，黑，作为对象的三种状态<br>新白：可以回收的对象；新创建的对象，初始状态是新白，但不会被清除<br>旧白：可以回收的对象；lua只会清除旧白，GC后，会更新新白<br>灰色：等待回收的对象：该对象已被GC访问过，但该对象引用的其它对象还未标记<br>黑色：不可回收的对象</p>
<p>简单流程：<br>1.根对象开始标记，将白色对象重置为灰色对象，加入灰色链表<br>2.如果灰色链表不为空，取出一个对象，重置为黑色，并遍历相关引用的对象，重置为黑色<br>3.如果灰色链表为空，清除一次灰色链表<br>4.根据不同类型对象分布回收，类型的存储表<br>5.判断是否遍历到链表尾<br>6.判断对象是否为白色<br>7.将对象重置为白色<br>8.释放资源</p>
<p>伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 初始化阶段  </span><br><span class="line">将所有对象颜色设置为白色  </span><br><span class="line">创建一个灰色对象列表(<span class="type">List</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> 遍历root节点及其所有子对象：  </span><br><span class="line">     <span class="keyword">if</span> 如果对象颜色为白色：  </span><br><span class="line">          将对象颜色设置为灰色  </span><br><span class="line">          将对象添加到灰色对象列表的尾部  </span><br><span class="line">  </span><br><span class="line">// 标记阶段  </span><br><span class="line"><span class="keyword">while</span> 当灰色对象列表不为空时：  </span><br><span class="line">        从灰色对象列表中取出一个对象  </span><br><span class="line">        将对象颜色设置为黑色  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">while</span> 遍历该对象的所有引用对象：  </span><br><span class="line">    <span class="keyword">if</span> 如果引用对象颜色为白色：  </span><br><span class="line">         将引用对象颜色设置为灰色  </span><br><span class="line">         将引用对象添加到灰色对象链表(insert to head)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 回收阶段  </span><br><span class="line">遍历所有对象：  </span><br><span class="line">    <span class="keyword">if</span> 如果对象颜色为白色：  </span><br><span class="line">        该对象没有被引用，执行回收操作（释放内存等）</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	那么重新塞入到对象链表中，等待下一轮GC</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>Lua通过借助grey链表，依次利用reallymarkobject对对象进行了颜色的标记，之后通过遍历alloc链表，依次利用sweeplist清除需要回收的对象。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LJY_rookie/article/details/108141615">lua的GC原理_lua 那些炒作会触发gc-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144875092">Lua设计与实现–GC篇 - 知乎 (zhihu.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fragmentary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/22/0037-lua/">http://example.com/2024/07/22/0037-lua/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">零の領域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/unity-%E7%83%AD%E6%9B%B4/">unity-热更</a></div><div class="post_share"><div class="social-share" data-image="/img/p_66349124.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/24/0038-cppstl/" title="C++ 之STL"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 之STL</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/19/0036-U3dSave-SB/" title="数据可持续化-ScriptableObject"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据可持续化-ScriptableObject</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/10/0030-U3dAssetBundle/" title="unity热更新AB包"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="title">unity热更新AB包</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/pixiv_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fragmentary</div><div class="author-info__description">一个摸鱼人的日常博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fragmentary1002"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Fragmentary1002" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://space.bilibili.com/165064718?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fa-solid fa-tv"></i></a><a class="social-icon" href="https://www.youtube.com/@mentaryFrag" target="_blank" title="youtube"><i class="fa-brands fa-youtube"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是一个博客~ 好吧这是我的学习笔记 一个Unity客户端开发者的日常</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua"><span class="toc-number">1.</span> <span class="toc-text">Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">热更新的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Lua%E4%BD%9C%E4%B8%BA%E7%83%AD%E6%9B%B4%E6%96%B0%E8%AF%AD%E8%A8%80%EF%BC%8C%E4%B8%8D%E7%94%A8C"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么使用Lua作为热更新语言，不用C#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8C-%E7%83%AD%E6%9B%B4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">不用C#热更的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">Lua数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%A1%A8%E6%A0%BC%EF%BC%88Table%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">Lua表格（Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E5%85%83%E8%A1%A8-Metatable"><span class="toc-number">1.2.2.</span> <span class="toc-text">Lua元表 (Metatable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-%E4%B8%8E-newindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">_index 与 _newindex的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-pairs-%E5%92%8C-ipairs%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.</span> <span class="toc-text">遍历:pairs 和 ipairs区别??</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">Lua类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E4%B8%AD-%E7%82%B9%E5%92%8C%E5%86%92%E5%8F%B7%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.</span> <span class="toc-text">Lua中 点和冒号区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">类与对象写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.3.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.4.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.5.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">Lua互相调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%92%8Clua%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">C和lua的互相调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">C#与Lua交互过程和原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E7%83%AD%E6%9B%B4"><span class="toc-number">1.4.3.</span> <span class="toc-text">Lua热更</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">1.5.</span> <span class="toc-text">Lua内存分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.1.</span> <span class="toc-text">Lua深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E9%97%AD%E5%8C%85"><span class="toc-number">1.5.2.</span> <span class="toc-text">lua闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E7%9A%84GC%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">lua的GC算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/0049-UGUI/" title="OS"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS"/></a><div class="content"><a class="title" href="/2024/10/07/0049-UGUI/" title="OS">OS</a><time datetime="2024-10-06T18:35:45.000Z" title="发表于 2024-10-07 02:35:45">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/0048-OSTopic/" title="OS"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS"/></a><div class="content"><a class="title" href="/2024/10/07/0048-OSTopic/" title="OS">OS</a><time datetime="2024-10-06T18:35:45.000Z" title="发表于 2024-10-07 02:35:45">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/0051-DialogueSystem/" title="Dialogue System for Unity"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dialogue System for Unity"/></a><div class="content"><a class="title" href="/2024/10/07/0051-DialogueSystem/" title="Dialogue System for Unity">Dialogue System for Unity</a><time datetime="2024-10-06T18:35:45.000Z" title="发表于 2024-10-07 02:35:45">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/0050-RedDot/" title="Unity红点系统"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity红点系统"/></a><div class="content"><a class="title" href="/2024/10/07/0050-RedDot/" title="Unity红点系统">Unity红点系统</a><time datetime="2024-10-06T18:35:45.000Z" title="发表于 2024-10-07 02:35:45">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/13/0047-MVP/" title="顶点阶段与MVP矩阵"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="顶点阶段与MVP矩阵"/></a><div class="content"><a class="title" href="/2024/09/13/0047-MVP/" title="顶点阶段与MVP矩阵">顶点阶段与MVP矩阵</a><time datetime="2024-09-12T18:35:45.000Z" title="发表于 2024-09-13 02:35:45">2024-09-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Fragmentary</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>