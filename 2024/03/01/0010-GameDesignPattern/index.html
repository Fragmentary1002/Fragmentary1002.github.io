<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>游戏设计模式（逐步更新） | 零の領域</title><meta name="author" content="Fragmentary"><meta name="copyright" content="Fragmentary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文为游戏设计模式的读书笔记，  架构，性能和游戏重访设计模式命令模式定义：1将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。  理解1将命令封装，与目标行为解耦，使命令由流程概念变为对象数据  UML 要点 将一组行为抽象为对象，这个对象和其他对象一样可以被存储和传递，从而实现行为请求者与行为实现者之间的松耦合，这就是命令模">
<meta property="og:type" content="article">
<meta property="og:title" content="游戏设计模式（逐步更新）">
<meta property="og:url" content="http://example.com/2024/03/01/0010-GameDesignPattern/index.html">
<meta property="og:site_name" content="零の領域">
<meta property="og:description" content="前言本文为游戏设计模式的读书笔记，  架构，性能和游戏重访设计模式命令模式定义：1将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。  理解1将命令封装，与目标行为解耦，使命令由流程概念变为对象数据  UML 要点 将一组行为抽象为对象，这个对象和其他对象一样可以被存储和传递，从而实现行为请求者与行为实现者之间的松耦合，这就是命令模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/p_66349124.png">
<meta property="article:published_time" content="2024-03-01T04:49:05.000Z">
<meta property="article:modified_time" content="2024-04-06T16:47:38.531Z">
<meta property="article:author" content="Fragmentary">
<meta property="article:tag" content="unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/p_66349124.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/03/01/0010-GameDesignPattern/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '游戏设计模式（逐步更新）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-07 00:47:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/pixiv_cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/p_66349124.png')"><nav id="nav"><span id="blog-info"><a href="/" title="零の領域"><span class="site-name">零の領域</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">游戏设计模式（逐步更新）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-01T04:49:05.000Z" title="发表于 2024-03-01 12:49:05">2024-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-06T16:47:38.531Z" title="更新于 2024-04-07 00:47:38">2024-04-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="游戏设计模式（逐步更新）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文为<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/acknowledgements.html">游戏设计模式</a>的读书笔记，</p>
<p><img src="https://pic3.zhimg.com/80/v2-5b889398df7bdff213ca0591cfbc6c8e_720w.webp" alt="img"></p>
<h1 id="架构，性能和游戏"><a href="#架构，性能和游戏" class="headerlink" title="架构，性能和游戏"></a>架构，性能和游戏</h1><h1 id="重访设计模式"><a href="#重访设计模式" class="headerlink" title="重访设计模式"></a>重访设计模式</h1><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。</span><br></pre></td></tr></table></figure>

<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将命令封装，与目标行为解耦，使命令由流程概念变为对象数据</span><br></pre></td></tr></table></figure>

<h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img src="https://pic1.zhimg.com/80/v2-3dfdff2ef7fe4b1b5c34564cb63e12d8_720w.webp" alt="img"></p>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>将一组行为抽象为对象，这个对象和其他对象一样可以被存储和传递，从而实现行为请求者与行为实现者之间的松耦合，这就是命令模式。</li>
</ul>
<p><img src="https://gpp.tkchu.me/images/command-buttons-two.png" alt="一个手柄，每个按键都与一个特定的&#39;button_&#39;变量相关联，这个变量再与函数关联。"></p>
<ul>
<li>命令模式是回调机制的面向对象版本。</li>
<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>
<li><img src="https://gpp.tkchu.me/images/command-stream.png" alt="一条连接AI到角色的管道。"></li>
<li>命令模式的优点有：对类间解耦、可扩展性强、易于命令的组合维护、易于与其他模式结合，而缺点是会导致类的膨胀。</li>
<li>命令模式有不少的细分种类，实际使用时应根据当前所需来找到合适的设计方式。</li>
</ul>
<h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><ul>
<li>命令模式很适合实现诸如撤消，重做，回放，时间倒流之类的功能。</li>
</ul>
<p><img src="https://gpp.tkchu.me/images/command-undo.png" alt="从旧到新排列的命令栈。 一个当前箭头指向一条命令，一个“撤销”箭头指向之前的命令，一个“重做”指向之后的命令"></p>
<ul>
<li>基于命令模式实现录像与回放等功能，也就是执行并解析一系列经过预录制的序列化后的各玩家操作的有序命令集合。</li>
</ul>
<h4 id="引申与参考"><a href="#引申与参考" class="headerlink" title="引申与参考"></a>引申与参考</h4><ul>
<li>最终我们可能会得到很多不同的命令类。为了更容易实现这些类，定义一个具体的基类，包含一些能定义行为的高层方法，往往会有帮助。可以将命令的主体execute()转到子类沙箱中。</li>
<li>对象可以响应命令，或者将命令交给它的从属对象。如果我们这样实现了，就完成了一个职责链模式。</li>
<li>对于等价的实例，可能会导致大量的实例化, 可以用享元模式提高内存利用率。</li>
</ul>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式，以共享的方式高效地支持大量的细粒度的对象。通过复用内存中已存在的对象，降低系统创建对象实例的性能消耗。</p>
<h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不同的实例共享相同的特性（共性），同时保留自己的特性部分</span><br></pre></td></tr></table></figure>

<h4 id="UML-1"><a href="#UML-1" class="headerlink" title="UML"></a>UML</h4><p><img src="https://pic2.zhimg.com/80/v2-39192b2daf28aa8f412a5bff7dcb45a1_720w.webp" alt="img"></p>
<p>左半部分为享元模式下，只有一个CubeBase，通过ObjInstancing(int num)将共享的网格、材质及一个Transform信息表传递给GPU，只有一个Draw Call，所以效率极高</p>
<p>右半部分为关闭享元模式后的做法，每生成一个Cube都会重新实例化一个立方体，并向GPU发送一次网格、材质和位置信息，所以1000个立方体就需要1000个Draw Call，效率极低</p>
<h4 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h4><ul>
<li>享元模式中有两种状态。内蕴状态（Internal State）和外蕴状态（External State）。</li>
<li><ul>
<li>内蕴状态，是不会随环境改变而改变的，是存储在享元对象内部的状态信息，因此内蕴状态是可以共享的。对任何一个享元对象而言，内蕴状态的值是完全相同的。</li>
<li>外蕴状态，是会随着环境的改变而改变的。因此是不可共享的状态，对于不同的享元对象而言，它的值可能是不同的。</li>
</ul>
</li>
<li><img src="https://gpp.tkchu.me/images/flyweight-tree-model.png" alt="一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。"></li>
<li>享元模式通过共享内蕴状态，区分外蕴状态，有效隔离系统中的变化部分和不变部分。</li>
</ul>
<h4 id="使用场合-1"><a href="#使用场合-1" class="headerlink" title="使用场合"></a>使用场合</h4><p>在以下情况都成立时，适合使用享元模式：</p>
<ul>
<li>当系统中某个对象类型的实例较多的时候。</li>
<li>由于使用了大量的对象，造成了很大的存储开销。</li>
<li>对象的大多数状态都可变为外蕴状态。</li>
<li>在系统设计中，对象实例进行分类后，发现真正有区别的分类很少的时候。</li>
</ul>
<p><img src="https://gpp.tkchu.me/images/flyweight-tiles.png" alt="一行区块，每个区块指向共享的草、河、山丘对象。"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">世界的表面被划分为由微小区块组成的巨大网格。 每个区块都由一种地形覆盖。我的世界中山川地形有河流有树有草皮，以一定的地形系统来绘制地形，我们只需要调用一个地形类就可以对于地图的绘制</span><br></pre></td></tr></table></figure>



<h4 id="引申与参考-1"><a href="#引申与参考-1" class="headerlink" title="引申与参考"></a>引申与参考</h4><ul>
<li>为了返回一个已经创建的享元，需要和那些已经实例化的对象建立联系，我们可以配合对象池来进行操作。</li>
<li>当使用状态模式时，很多时候可以配合使用享元模式，在不同的状态机上使用相同的对象实例。</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><img src="https://gpp.tkchu.me/images/observer-weasel-wielder.png" alt="成就：一无所成"></p>
<h4 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解耦，物价局改了粮价不需要挨家挨户通知公民，只需要让电视台播个新闻就好</span><br></pre></td></tr></table></figure>



<h4 id="UML-2"><a href="#UML-2" class="headerlink" title="UML"></a>UML</h4><p><img src="https://pic1.zhimg.com/80/v2-ddaad46ef76f43ef30c66319e5843c60_720w.webp" alt="img"></p>
<h4 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h4><ul>
<li>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li>我们知道，将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</li>
<li>目前广泛使用的MVC模式，究其根本，是基于观察者模式的。</li>
<li>观察者模式应用广泛，Java甚至将其放到了核心库之中（java.util.Observer），而C#直接将其嵌入了语法（event关键字）中。</li>
</ul>
<h4 id="使用场合-2"><a href="#使用场合-2" class="headerlink" title="使用场合"></a>使用场合</h4><ul>
<li>当一个抽象模式有两个方面，其中一个方面依赖于另一个方面，需要将这两个方面分别封装到独立的对象中，彼此独立地改变和复用的时候。</li>
<li>当一个系统中一个对象的改变需要同时改变其他对象内容，但是又不知道待改变的对象到底有多少个的时候。</li>
<li>当一个对象的改变必须通知其他对象作出相应的变化，但是不能确定通知的对象是谁的时候。</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h4 id="UML-3"><a href="#UML-3" class="headerlink" title="UML"></a>UML</h4><p><img src="https://pic3.zhimg.com/80/v2-3f8576da88e692b324fd474611cadb1a_720w.webp" alt="img"></p>
<ul>
<li>Unity中Prefab本质就是此模式里的原型，而Spawner要做的只是调用Instantiate方法</li>
<li>新的Prefab被生成以后，通过读取Dragons.txt里配置的信息来设置克隆体的名称和尺寸</li>
</ul>
<h4 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h4><ul>
<li>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li>
</ul>
<p><img src="https://gpp.tkchu.me/images/prototype-spawner.png" alt="一个生产者包含一个对怪物应用的原型字段。 他调用原型的clone()方法来产生新的怪物。"></p>
<ul>
<li>原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。</li>
<li>使用原型模式拷贝对象时，需注意浅拷贝与深拷贝的区别。</li>
<li>原型模式可以结合JSON等数据交换格式，为数据模型构建原型。</li>
</ul>
<h4 id="使用场合-3"><a href="#使用场合-3" class="headerlink" title="使用场合"></a>使用场合</h4><ul>
<li>产生对象过程比较复杂，初始化需要许多资源时。</li>
<li>希望框架原型和产生对象分开时。</li>
<li>同一个对象可能会供其他调用者同时调用访问时。</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类只有一个实例，并且提供了访问该实例的全局访问点。</p>
<h4 id="UML-4"><a href="#UML-4" class="headerlink" title="UML"></a>UML</h4><p><img src="https://pic4.zhimg.com/80/v2-252f5c76b5e601f5163cd8069d35ad5b_720w.webp" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">游戏中看到的很多单例类都是“管理器”——那些类存在的意义就是照顾其他对象。 我曾看到一些代码库中，几乎所有类都有管理器： 怪物，怪物管理器，粒子，粒子管理器，声音，声音管理器，管理管理器的管理器。 有时候，它们被叫做“系统”或“引擎”，但是思路还是一样的。</span><br></pre></td></tr></table></figure>

<h4 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h4><ul>
<li>单例模式因其方便的特性，在开发过程中的运用很多。</li>
<li>单例模式有两个要点，保证一个类只有一个实例，并提供访问该实例的全局访问点。</li>
<li>尽量少用单例模式。单例模式作为一个全局的变量，有很多全局的变量的弊病。它会使代码更难理解，更加耦合，并且对并行不太友好。</li>
</ul>
<h4 id="使用场合-4"><a href="#使用场合-4" class="headerlink" title="使用场合"></a>使用场合</h4><ul>
<li>当在系统中某个特定的类对象实例只需要有唯一一个的时候。</li>
<li>单例模式要尽量少用，无节制的使用会带来各种弊病。</li>
<li>为了保证实例是单一的，可以简单的使用静态类。 还可以使用静态标识位，在运行时检测是不是只有一个实例被创建了。</li>
</ul>
<h4 id="参考与引申"><a href="#参考与引申" class="headerlink" title="参考与引申"></a>参考与引申</h4><ul>
<li>下文中介绍的子类沙箱模式通过对状态的分享，给实例以类的访问权限而无需让其全局可用。</li>
<li>下文中介绍的服务定位器模式不但让一个对象全局可用，还可以带来设置对象的一些灵活性。</li>
</ul>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许对象在当内部状态改变时改变其行为，就好像此对象改变了自己的类一样。</p>
<h4 id="UML-5"><a href="#UML-5" class="headerlink" title="UML"></a>UML</h4><p><img src="https://pic3.zhimg.com/80/v2-5546e6c5306433a2908d9242dd93a0ea_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-5f5e2ec779a9801627bf11a06f9e6dcd_720w.webp" alt="img"></p>
<p><img src="https://gpp.tkchu.me/images/state-flowchart.png" alt="一张画有盒子的图表，盒子代表了站立，跳跃，俯卧和跳斩。标记了按键的按下和释放的箭头连接了这些盒子。"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">祝贺，你刚刚建好了一个有限状态机。 它来自计算机科学的分支自动理论，那里有很多著名的数据结构，包括著名的图灵机。 FSMs是其中最简单的成员。</span><br><span class="line"></span><br><span class="line">要点是：</span><br><span class="line"></span><br><span class="line">你拥有状态机所有可能状态的集合。 在我们的例子中，是站立，跳跃，俯卧和速降。</span><br><span class="line"></span><br><span class="line">状态机同时只能在一个状态。 英雄不可能同时处于跳跃和站立状态。事实上，防止这点是使用FSM的理由之一。</span><br><span class="line"></span><br><span class="line">一连串的输入或事件被发送给状态机。 在我们的例子中，就是按键按下和松开。</span><br><span class="line"></span><br><span class="line">每个状态都有一系列的转移，每个转移与输入和另一状态相关。 当输入进来，如果它与当前状态的某个转移相匹配，机器转换为所指的状态。</span><br><span class="line"></span><br><span class="line">举个例子，在站立状态时，按下下方向键转换为俯卧状态。 在跳跃时按下下方向键转换为速降。 如果输入在当前状态没有定义转移，输入就被忽视。</span><br></pre></td></tr></table></figure>

<h4 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h4><ul>
<li><p>状态模式用来解决当控制一个对象状态转换的条件表达式过于复杂的情况，它把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。</p>
</li>
<li><p>状态模式的实现分为三个要点：</p>
</li>
<li><ul>
<li>为状态定义一个接口。</li>
<li>为每个状态定义一个类。</li>
<li>恰当地进行状态委托。</li>
</ul>
</li>
<li><p>通常来说，状态模式中状态对象的存放有两种实现存放的思路：</p>
</li>
<li><ul>
<li>静态状态。初始化时把所有可能的状态都new好，状态切换时通过赋值改变当前的状态。</li>
<li>实例化状态。每次切换状态时动态new出新的状态。</li>
</ul>
</li>
</ul>
<h4 id="使用场合-5"><a href="#使用场合-5" class="headerlink" title="使用场合"></a>使用场合</h4><ul>
<li><p>在游戏开发过程中，涉及到复杂的状态切换时，可以运用状态模式以及状态机来高效地完成任务。</p>
</li>
<li><p>有限状态机的实现方式，有两种可以选择：</p>
</li>
<li><ul>
<li>用枚举配合switch case语句。</li>
<li>用多态与虚函数（即状态模式）。</li>
</ul>
</li>
<li><p>有限状态机在以下情况成立时可以使用：</p>
</li>
<li><ul>
<li>有一个行为基于一些内在状态的实体。</li>
<li>状态可以被严格的分割为相对较少的不相干项目。</li>
<li>实体可以响应一系列输入或事件。</li>
</ul>
</li>
</ul>
<h1 id="序列模式"><a href="#序列模式" class="headerlink" title="序列模式"></a>序列模式</h1><h2 id="双缓冲模式"><a href="#双缓冲模式" class="headerlink" title="双缓冲模式"></a>双缓冲模式</h2><p>双缓冲模式，使用序列操作来模拟瞬间或者同时发生的事情。</p>
<h4 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们称这些舞台为舞台A和舞台B。 场景一在舞台A上。同时场务在处于黑暗之中的舞台B布置场景二。 当场景一完成后，将切断场景A的灯光，打开场景B的灯光。观众看向新舞台，场景二立即开始。此时场景切换只需要开关灯光（指针的指向改变），后swap就可以得到改变缓冲区的效果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于跑酷游戏，生成地图，碰到某个点而去生成下一个地图，生成过程中可以使用缓冲区</span><br></pre></td></tr></table></figure>



<h4 id="要点-6"><a href="#要点-6" class="headerlink" title="要点"></a>要点</h4><ul>
<li>一个双缓冲类封装了一个缓冲：一段可改变的状态。这个缓冲被增量的修改，但我们想要外部的代码将其视为单一的元素修改。 为了实现这点，双缓冲类需保存两个缓冲的实例：下一缓存和当前缓存。</li>
<li>当信息从缓冲区中读取，我们总是去读取当前的缓冲区。当信息需要写到缓存，我们总是在下一缓冲区上操作。 当改变完成后，一个交换操作会立刻将当前缓冲区和下一缓冲区交换， 这样新缓冲区就是公共可见的了。旧的缓冲区则成为了下一个重用的缓冲区。</li>
<li>双缓冲模式常用来做帧缓冲区交换。</li>
</ul>
<h4 id="使用场合-6"><a href="#使用场合-6" class="headerlink" title="使用场合"></a>使用场合</h4><p>双缓冲模式是那种你需要它时自然会想起来的模式。以下情况都满足时，使用这个模式很合适：</p>
<ul>
<li>我们需要维护一些被增量修改的状态</li>
<li>在修改过程中，状态可能会被外部请求。</li>
<li>我们想要防止请求状态的外部代码知道内部是如何工作的。</li>
<li>我们想要读取状态，而且不想在修改的时候等待。</li>
</ul>
<h2 id="游戏循环"><a href="#游戏循环" class="headerlink" title="游戏循环"></a>游戏循环</h2><p>游戏循环模式，实现游戏运行过程中对用户输入处理和时间处理的解耦。</p>
<p>可参考[脚本生命周期](<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/ExecutionOrder.html">Unity - Manual: Order of execution for event functions (unity3d.com)</a>)，主要游戏引擎给你处理好了，可以相当于每一帧对于游戏的处理如同。</p>
<h4 id="要点-7"><a href="#要点-7" class="headerlink" title="要点"></a>要点</h4><ul>
<li>游戏循环模式：游戏循环在游戏过程中持续运转。每循环一次，它非阻塞地处理用户的输入，更新游戏状态，并渲染游戏。它跟踪流逝的时间并控制游戏的速率。</li>
<li>游戏循环将游戏的处理过程和玩家输入解耦，和处理器速度解耦，实现用户输入和处理器速度在游戏行进时间上的分离。</li>
<li>游戏循环也许需要与平台的事件循环相协调。如果在操作系统的高层或有图形UI和内建事件循环的平台上构建游戏， 那就有了两个应用循环在同时运作，需要对他们进行相应的协调。</li>
</ul>
<h4 id="使用场合-7"><a href="#使用场合-7" class="headerlink" title="使用场合"></a>使用场合</h4><p>任何游戏或游戏引擎都拥有自己的游戏循环，因为游戏循环是游戏运行的主心骨。</p>
<h4 id="游戏循环发展史"><a href="#游戏循环发展史" class="headerlink" title="游戏循环发展史"></a>游戏循环发展史</h4><ul>
<li>最古老的交互式程序</li>
</ul>
<p>文本处理器通常呆在那里什么也不做，直到你按了个键或者点了什么东西。</p>
<p>类似于对于普通的galgame，你只需要点击后才会触发事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">  Event* event = waitForEvent();</span><br><span class="line">  dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不堵塞游戏内时间的交互式系统</li>
</ul>
<p>这是真实游戏循环的第一个关键部分：<em>它处理用户输入，但是不等待它</em>。循环总是继续旋转：</p>
<p>你即使不做任何动作，游戏也会继续更新和渲染，这边可以使用协程模拟这个过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">  processInput();</span><br><span class="line">  update();</span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层对于性能的影响</li>
</ul>
<p>我们现在写的这个循环是能转多快转多快，两个因素决定了帧率。 一个是<em>每帧要做多少工作</em>。另一个是<em>底层平台的速度。</em> 更快的芯片可以在同样的时间里执行更多的代码。</p>
<p>这就是游戏循环的另一个关键任务：<em>不管潜在的硬件条件，以固定速度运行游戏。</em></p>
<p>每一个设备具有不同的更新和渲染速度，如同小霸王和外星人</p>
<p>下面案例是如果帧数过快直接使得系统休眠的方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FixAlienware</span>()</span>&#123;</span><br><span class="line">	<span class="built_in">float</span> handleTime = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">float</span> sleepTime = timer.moveTime - handleTime;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (sleepTime &gt;  e) &#123;</span><br><span class="line">		timer. moveTime = sleepTime + 	handleTime;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        timer. moveTime = handleTime;</span><br><span class="line">    &#125;	</span><br></pre></td></tr></table></figure>

<p><img src="https://gpp.tkchu.me/images/game-loop-simple.png" alt="一个简单的游戏循环流程图。处理输入 → 更新游戏 → 渲染 → 等待，然后从头开始。"></p>
<ul>
<li>拉伸每一帧需要处理的内容</li>
</ul>
<p>每一帧，我们计算上次游戏更新到现在有多少<em>真实</em>时间过去了（即变量<code>elapsed</code>）。 当我们更新游戏状态时将其传入。 然后游戏引擎让游戏世界推进一定的时间量。</p>
<p>假设有一颗子弹跨过屏幕。 使用固定的时间间隔，在每一帧中，你根据它的速度移动它。 使用变化的时间间隔，你<em>根据过去的时间拉伸速度</em>。 随着时间间隔增加，子弹在每帧间移动得更远。 无论是二十个快的小间隔还是四个慢的大间隔，子弹在<em>真实</em>时间里移动<em>同样</em>多的距离。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FixFixAlienware</span>()</span>&#123;</span><br><span class="line">    <span class="built_in">float</span> handleTime =<span class="number">5.5f</span>;</span><br><span class="line">    <span class="comment">//我的一帧虽然快，经过拉伸以后，但是每一帧处理的表现就比较少</span></span><br><span class="line">	<span class="built_in">float</span> mul = handleTime / timer.moveTime;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">float</span> movex=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//假如我们游戏需要真实时间1s移动的距离是1</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;我一让方块运行的距离是&quot;</span> + mul* moveX +<span class="string">&quot;我一秒让方块移动的距离是&quot;</span>+movex + mul * timer.moveTime / handleTime);</span><br><span class="line"></span><br><span class="line">	timer.moveTime = handleTime;</span><br><span class="line">	<span class="comment">//引入了新问题，联网对战中，两个设备的配置不同，经过拉伸的比例也不同，浮点数的每一次拉伸运算都有误差，那么拉伸比例大的那个误差也就多了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>将渲染和逻辑更新分离</li>
</ul>
<p>幸运的是，我们给自己了一些喘息的空间。 技巧在于我们将<em>渲染拉出了更新循环</em>。 这释放了一大块CPU时间。 最终结果是游戏以固定时间步长<em>模拟</em>，该时间步长与硬件不相关。 只是使用低端硬件的玩家<em>看到的</em>内容会有抖动。</p>
<p>对于高性能的电脑来说，更新和渲染可以进行同步，但对于低端性能电脑来说可以把更新和渲染不同步以实现同步效果，可以理解为你更新了俩次，才渲染了一次。</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-timeline.png" alt="一条时间线，上面是均匀分布的更新时刻和不均匀的渲染时刻。"></p>
<ul>
<li>将渲染和逻辑更新分离后的问题</li>
</ul>
<p>在渲染中有可能更新于渲染的帧率不同导致你会做出些无效操作，如死亡后继续释放技能，这边就需要在需要的位置添加关键帧，如同释放技能时或者死亡时。</p>
<p>这边涉及到了帧同步和状态同步。</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-timeline-close.png" alt="时间线的一部分，渲染发生在两次更新之间。"></p>
<h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h2 id="子类沙箱"><a href="#子类沙箱" class="headerlink" title="子类沙箱"></a>子类沙箱</h2><h4 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h4><p>用一系列由基类提供的操作定义子类中的行为。</p>
<h4 id="要点-8"><a href="#要点-8" class="headerlink" title="要点"></a>要点</h4><p>子类沙箱模式：基类定义抽象的沙箱方法和几个提供操作的实现方法，将他们设为protected，表明它们只为子类所使用。每个推导出的沙箱子类用提供的操作实现了沙箱方法。</p>
<h4 id="使用场合-8"><a href="#使用场合-8" class="headerlink" title="使用场合"></a>使用场合</h4><p>子类沙箱模式是潜伏在编程日常中简单常用的模式，哪怕是在游戏之外的地方。 如果有一个非虚的protected方法，你可能早已在用类似的技术了。</p>
<p>沙箱方法在以下情况适用：</p>
<ul>
<li>你有一个能推导很多子类的基类。</li>
<li>基类可以提供子类需要的所有操作。</li>
<li>在子类中有行为重复，你想要更容易的在它们间分享代码。</li>
<li>你想要最小化子类和程序的其他部分的耦合。</li>
</ul>
<h2 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h2><h1 id="解耦模式"><a href="#解耦模式" class="headerlink" title="解耦模式"></a>解耦模式</h1><h2 id="组件模式"><a href="#组件模式" class="headerlink" title="组件模式"></a>组件模式</h2><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><h2 id="服务定位器"><a href="#服务定位器" class="headerlink" title="服务定位器"></a>服务定位器</h2><h1 id="优化模式"><a href="#优化模式" class="headerlink" title="优化模式"></a>优化模式</h1><h2 id="数据局部性"><a href="#数据局部性" class="headerlink" title="数据局部性"></a>数据局部性</h2><h2 id="脏标识模式"><a href="#脏标识模式" class="headerlink" title="脏标识模式"></a>脏标识模式</h2><h2 id="对象池模式"><a href="#对象池模式" class="headerlink" title="对象池模式"></a>对象池模式</h2><h4 id="理解-5"><a href="#理解-5" class="headerlink" title="理解"></a>理解</h4><p>放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率。</p>
<h4 id="要点-9"><a href="#要点-9" class="headerlink" title="要点"></a>要点</h4><ul>
<li>对象池模式：定义一个包含了一组可重用对象的对象池。其中每个可重用对象都支持查询“使用中”状态，说明它是不是“正在使用”。 对象池被初始化时，就创建了整个对象集合（通常使用一次连续的分配），然后初始化所有对象到“不在使用中”状态。</li>
<li>当我们需要新对象时，就从对象池中获取。从对象池取到一个可用对象，初始化为“使用中”然后返回给我们。当不再需要某对象时，将其设置回“不在使用中”状态。 通过这种方式，便可以轻易地创建和销毁对象，而不必每次都分配内存或其他资源。</li>
</ul>
<h4 id="使用场合-9"><a href="#使用场合-9" class="headerlink" title="使用场合"></a>使用场合</h4><ul>
<li><p>这个模式广泛使用在可见事物上，比如游戏物体和特效。但是它也可在不那么视觉化的数据结构上使用，比如正在播放的声音。</p>
</li>
<li><p>满足以下情况可以使用对象池：</p>
</li>
<li><ul>
<li>需要频繁创建和销毁对象。</li>
<li>对象大小相仿。</li>
<li>在堆上分配对象缓慢或者会导致内存碎片。</li>
<li>每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源。</li>
</ul>
</li>
</ul>
<h2 id="空间分区"><a href="#空间分区" class="headerlink" title="空间分区"></a>空间分区</h2><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>最近看到了ECS模式与MVC模式的对比，参考一下链接</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leehuimr/article/details/116298737">【Unity3D】MVC框架在Unity项目中的理解与使用_unity mvc框架工作原理-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ch411A7vS/?spm_id_from=333.337.search-card.all.click">除了 ECS，还有什么游戏架构 - Bob Nystrom_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42205218/article/details/105920323">MVC和ECS两种设计架构的初浅理解_对mvc和ecs框架有一定理解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bug_Curry/article/details/109206399">对于（MVC 、MVCS、MVVM）的理解-CSDN博客</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39707078">《游戏设计模式》(游戏编程模式)全书笔记+Unity 实现</a><br><a target="_blank" rel="noopener" href="https://gpp.tkchu.me/acknowledgements.html">游戏设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23821422">【游戏设计模式】之四 《游戏编程模式》全书内容提炼总结 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18G411D7A2/?spm_id_from=333.788">【Unity】设计模式_游戏循环解读_哔哩哔哩_bilibili</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fragmentary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/01/0010-GameDesignPattern/">http://example.com/2024/03/01/0010-GameDesignPattern/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">零の領域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/unity/">unity</a></div><div class="post_share"><div class="social-share" data-image="/img/p_66349124.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/06/0023-U3dUIOptimize/" title="unity UI优化"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">unity UI优化</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/29/0022-U3dMath/" title="unity中关于3d数学"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">unity中关于3d数学</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/11/0006-U3dRetargeting/" title="unity 的动画重定向"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">unity 的动画重定向</div></div></a></div><div><a href="/2023/08/11/0010-unityKeyboard/" title="unity快捷键"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-11</div><div class="title">unity快捷键</div></div></a></div><div><a href="/2023/12/25/0017-U3dMovement/" title="U3d的移动"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-25</div><div class="title">U3d的移动</div></div></a></div><div><a href="/2023/12/08/0016-U3dApi/" title="unity 常见api"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="title">unity 常见api</div></div></a></div><div><a href="/2023/12/27/0019-U3dDataSave/" title="数据可持续化"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-27</div><div class="title">数据可持续化</div></div></a></div><div><a href="/2023/12/28/0020-U3dRay/" title="射线检测"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">射线检测</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/pixiv_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fragmentary</div><div class="author-info__description">一个摸鱼人的日常博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Fragmentary1002" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://www.bilibili.com/" target="_blank" title="bilibili"><i class="fa-solid fa-tv"></i></a><a class="social-icon" href="https://stackoverflow.co/" target="_blank" title="stackoverflow"><i class="fa-brands fa-stack-overflow"></i></a><a class="social-icon" href="https://www.pixiv.net" target="_blank" title="pixiv"><i class="fa-solid fa-p"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F"><span class="toc-number">2.</span> <span class="toc-text">架构，性能和游戏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%AE%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">重访设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-number">3.1.0.5.</span> <span class="toc-text">使用场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%B3%E4%B8%8E%E5%8F%82%E8%80%83"><span class="toc-number">3.1.0.6.</span> <span class="toc-text">引申与参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-1"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML-1"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-1"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-1"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">使用场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%B3%E4%B8%8E%E5%8F%82%E8%80%83-1"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">引申与参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-2"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML-2"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-2"><span class="toc-number">3.3.0.3.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-2"><span class="toc-number">3.3.0.4.</span> <span class="toc-text">使用场合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UML-3"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-3"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-3"><span class="toc-number">3.4.0.3.</span> <span class="toc-text">使用场合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UML-4"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-4"><span class="toc-number">3.5.0.2.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-4"><span class="toc-number">3.5.0.3.</span> <span class="toc-text">使用场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%B8%8E%E5%BC%95%E7%94%B3"><span class="toc-number">3.5.0.4.</span> <span class="toc-text">参考与引申</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UML-5"><span class="toc-number">3.6.0.1.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-5"><span class="toc-number">3.6.0.2.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-5"><span class="toc-number">3.6.0.3.</span> <span class="toc-text">使用场合</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">序列模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">双缓冲模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-3"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-6"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-6"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">使用场合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">游戏循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-7"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-7"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">使用场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">游戏循环发展史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">更新方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">行为模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1"><span class="toc-number">5.2.</span> <span class="toc-text">子类沙箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-4"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-8"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-8"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">使用场合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">类型对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">解耦模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">组件模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">事件队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">服务定位器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">优化模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">7.1.</span> <span class="toc-text">数据局部性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%8F%E6%A0%87%E8%AF%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">脏标识模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">对象池模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-5"><span class="toc-number">7.3.0.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9-9"><span class="toc-number">7.3.0.2.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88-9"><span class="toc-number">7.3.0.3.</span> <span class="toc-text">使用场合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E5%8C%BA"><span class="toc-number">7.4.</span> <span class="toc-text">空间分区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%95%AA%E5%A4%96"><span class="toc-number">8.</span> <span class="toc-text">番外</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/07/0028-FragFrameWork/" title="创建我自己的小框架"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建我自己的小框架"/></a><div class="content"><a class="title" href="/2024/04/07/0028-FragFrameWork/" title="创建我自己的小框架">创建我自己的小框架</a><time datetime="2024-04-06T18:35:45.000Z" title="发表于 2024-04-07 02:35:45">2024-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/04/0027-OptimizeDrawCall/" title="UGUI 优化- DrawCall"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UGUI 优化- DrawCall"/></a><div class="content"><a class="title" href="/2024/04/04/0027-OptimizeDrawCall/" title="UGUI 优化- DrawCall">UGUI 优化- DrawCall</a><time datetime="2024-04-04T14:26:45.000Z" title="发表于 2024-04-04 22:26:45">2024-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/20/0026-CsharpCLR/" title="关于CLR模型-GC"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于CLR模型-GC"/></a><div class="content"><a class="title" href="/2024/03/20/0026-CsharpCLR/" title="关于CLR模型-GC">关于CLR模型-GC</a><time datetime="2024-03-20T11:20:05.000Z" title="发表于 2024-03-20 19:20:05">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/10/0025-CsharpAdvanced/" title="C# 高级语法"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C# 高级语法"/></a><div class="content"><a class="title" href="/2024/03/10/0025-CsharpAdvanced/" title="C# 高级语法">C# 高级语法</a><time datetime="2024-03-10T11:20:05.000Z" title="发表于 2024-03-10 19:20:05">2024-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/07/0024-Shader/" title="unityShader（逐步更新）"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="unityShader（逐步更新）"/></a><div class="content"><a class="title" href="/2024/03/07/0024-Shader/" title="unityShader（逐步更新）">unityShader（逐步更新）</a><time datetime="2024-03-07T01:09:05.000Z" title="发表于 2024-03-07 09:09:05">2024-03-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Fragmentary</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>