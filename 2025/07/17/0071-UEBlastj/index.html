<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>UE- Blast  (正在更新) | 零の領域</title><meta name="author" content="Fragmentary"><meta name="copyright" content="Fragmentary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="_哔哩哔哩_bilibili 这边是Blaster 笔记  自己整理的有点杂乱 是本人 unity转ue的一个重要项目， 采用前视频后源码 去了解这个项目。 中间有其他资料与AI辅助。 插件编写（待）这边我先开盖即用插件 Play设置编译模式   模式 用途描述 编译特点 文件&#x2F;性能特点    DebugGame 开发过程中进行调试。在游戏中设置断点、查看变量值以及代码调试。 以调试模式编译，包含">
<meta property="og:type" content="article">
<meta property="og:title" content="UE- Blast  (正在更新)">
<meta property="og:url" content="http://example.com/2025/07/17/0071-UEBlastj/index.html">
<meta property="og:site_name" content="零の領域">
<meta property="og:description" content="_哔哩哔哩_bilibili 这边是Blaster 笔记  自己整理的有点杂乱 是本人 unity转ue的一个重要项目， 采用前视频后源码 去了解这个项目。 中间有其他资料与AI辅助。 插件编写（待）这边我先开盖即用插件 Play设置编译模式   模式 用途描述 编译特点 文件&#x2F;性能特点    DebugGame 开发过程中进行调试。在游戏中设置断点、查看变量值以及代码调试。 以调试模式编译，包含">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/p_66349124.png">
<meta property="article:published_time" content="2025-07-17T01:16:49.000Z">
<meta property="article:modified_time" content="2025-08-23T10:37:31.048Z">
<meta property="article:author" content="Fragmentary">
<meta property="article:tag" content="ue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/p_66349124.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/17/0071-UEBlastj/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE- Blast  (正在更新)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-23 18:37:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/pixiv_cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/p_66349124.png')"><nav id="nav"><span id="blog-info"><a href="/" title="零の領域"><span class="site-name">零の領域</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UE- Blast  (正在更新)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-17T01:16:49.000Z" title="发表于 2025-07-17 09:16:49">2025-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-23T10:37:31.048Z" title="更新于 2025-08-23 18:37:31">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ue/">ue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UE- Blast  (正在更新)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AN4y1f745?spm_id_from=333.788.player.switch&vd_source=d19e47552f1614194f0d0b0662850083&p=2">_哔哩哔哩_bilibili</a></p>
<p>这边是Blaster 笔记  自己整理的有点杂乱 是本人 unity转ue的一个重要项目，</p>
<p>采用前视频后源码 去了解这个项目。</p>
<p>中间有其他资料与AI辅助。</p>
<h1 id="插件编写（待）"><a href="#插件编写（待）" class="headerlink" title="插件编写（待）"></a>插件编写（待）</h1><p>这边我先开盖即用插件</p>
<h2 id="Play设置"><a href="#Play设置" class="headerlink" title="Play设置"></a>Play设置</h2><h3 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h3><table>
<thead>
<tr>
<th>模式</th>
<th>用途描述</th>
<th>编译特点</th>
<th>文件/性能特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DebugGame</strong></td>
<td>开发过程中进行调试。在游戏中设置断点、查看变量值以及代码调试。</td>
<td>以调试模式编译，包含调试符号（debug symbols）。</td>
<td>可执行文件较大且运行速度较慢。</td>
</tr>
<tr>
<td><strong>Development</strong></td>
<td>开发过程中进行内部测试和验证。相比DebugGame模式会进行更多优化，同时保留调试能力。</td>
<td>启用优化选项以提高运行性能，保留部分调试信息。</td>
<td>运行性能更高，但仍便于问题排查。</td>
</tr>
<tr>
<td><strong>DebugGame Editor</strong></td>
<td>在Unreal Editor中调试游戏功能（与DebugGame模式类似，但专用于编辑器环境）。</td>
<td>编译包含调试符号，便于在编辑器中调试。</td>
<td>可执行文件较大，运行效率较低。</td>
</tr>
<tr>
<td><strong>Development Editor</strong></td>
<td>在Unreal Editor中进行开发测试。优化编辑器运行性能，同时保留调试能力（与Development模式类似）。</td>
<td>启用优化选项提高编辑器性能，保留部分调试信息。</td>
<td>编辑器运行更流畅，同时支持问题排查。</td>
</tr>
<tr>
<td><strong>Shipping</strong></td>
<td>发布给玩家的正式版本构建。</td>
<td>全面优化编译，移除所有调试符号和调试信息。</td>
<td>可执行文件最小化，运行性能最高（无调试开销）。</td>
</tr>
</tbody></table>
<h3 id="网络模式（ENetMode）"><a href="#网络模式（ENetMode）" class="headerlink" title="网络模式（ENetMode）"></a>网络模式（ENetMode）</h3><h2 id="更新插件代码"><a href="#更新插件代码" class="headerlink" title="更新插件代码"></a>更新插件代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原弃用代码：bIsFocusable = true;</span></span><br><span class="line"><span class="built_in">SetIsFocusable</span>(<span class="literal">true</span>); <span class="comment">// 使用UE5官方Setter方法[1,3](@ref)</span></span><br></pre></td></tr></table></figure>



<h1 id="基础3C"><a href="#基础3C" class="headerlink" title="基础3C"></a>基础3C</h1><h2 id="项目建立"><a href="#项目建立" class="headerlink" title="项目建立"></a>项目建立</h2><ul>
<li>编译项目<ul>
<li>装入自定义网络插件</li>
<li>装入Online SubSystem Steam</li>
<li>设置ini：</li>
</ul>
</li>
</ul>
<p>在DefaultEngine.ini写入</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[/Script/Engine.GameEngine]</span></span><br><span class="line">+<span class="attr">NetDriverDefinitions</span>=(DefName=<span class="string">&quot;GameNetDriver&quot;</span>,DriverClassName=<span class="string">&quot;OnlineSubsystemSteam.SteamNetDriver&quot;</span>,DriverClassNameFallback=<span class="string">&quot;OnlineSubsystemUtils.IpNetDriver&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">[OnlineSubsystem]</span></span><br><span class="line"><span class="attr">DefaultPlatformService</span>=Steam</span><br><span class="line"></span><br><span class="line"><span class="section">[OnlineSubsystemSteam]</span></span><br><span class="line"><span class="attr">bEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SteamDevAppId</span>=<span class="number">480</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; If using Sessions</span></span><br><span class="line"><span class="comment">; bInitServerOnClient=true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/OnlineSubsystemSteam.SteamNetDriver]</span></span><br><span class="line"><span class="attr">NetConnectionClassName</span>=<span class="string">&quot;OnlineSubsystemSteam.SteamNetConnection&quot;</span></span><br></pre></td></tr></table></figure>

<p>在DefaultGame.ini写入</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[/Script/Engine.GameSession]</span></span><br><span class="line"><span class="attr">MaxPlayers</span>=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>删除二进制文件夹</p>
<ul>
<li><p>创建关卡</p>
<ul>
<li>创建StartUpMap，LobbyMap</li>
<li>在Project Setting - Map&amp;Modes - 里面更换默认的Map</li>
<li>在StartUpMap关卡蓝图里面调用Create WBP Menu widget -&gt; Menu Setup （设置Lobby路径）</li>
</ul>
</li>
<li><p>Bulid</p>
<ul>
<li>设置bulid的map : 在Project Setting - 搜索 maps to 设置俩个关卡</li>
<li>平台-打包-windows-放入新建的build文件夹</li>
</ul>
</li>
</ul>
<h2 id="建立网络连接"><a href="#建立网络连接" class="headerlink" title="建立网络连接"></a>建立网络连接</h2><ul>
<li>在内容浏览器里面ADD 第三人称资产<ul>
<li>重点概念 <strong>input</strong> （待定)</li>
</ul>
</li>
<li>GameMode设置第三人称 -<ul>
<li>重点概念<strong>GameMode</strong> -&gt; <a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/game-mode-and-game-state-in-unreal-engine#agamemodebase">虚幻引擎中的 Game Mode 和 Game State | 虚幻引擎 5.6 文档 | Epic Developer Community</a></li>
</ul>
</li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a target="_blank" rel="noopener" href="https://www.mixamo.com/">Maximo</a></p>
<p><strong>重定向</strong>（待定）<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AN4y1f745/?spm_id_from=333.788.player.switch&vd_source=d19e47552f1614194f0d0b0662850083&p=32">重定向教程</a></p>
<h2 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h2><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>新建一个cpp类 注意 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;FCharacter.h&quot;</span><br></pre></td></tr></table></figure>

<p>头文件path要对，新建立的时候默认h会错误</p>
<p>每次更新都 ====在编辑器或游戏窗口中按下 **<code>Ctrl + Alt + F11</code>**，强制终止当前 Live Coding 进程，释放资源后重新编译</p>
<p>C++类创建蓝图 并且设置Mesh和pos</p>
<h3 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h3><p>FCharacter</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">FCharacter.<span class="function">h</span></span><br><span class="line"><span class="function">	<span class="title">UPROPERTY</span><span class="params">(VisibleAnyWhere, Category = Camera)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">class</span> USpringArmComponent* CameraBoom</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, Category = Camera)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCameraComponent</span>* FollowCamera;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FCharacter.<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="title">AFCharacter::AFCharacter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CameraBoom = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraBoom&quot;</span>));</span><br><span class="line">    CameraBoom-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置弹簧臂长度（摄像机与角色的默认距离）</span></span><br><span class="line">    CameraBoom-&gt;TargetArmLength = <span class="number">500.f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启用角色旋转控制弹簧臂  当玩家控制器旋转时，弹簧臂同步旋转（适用于第三人称视角） </span></span><br><span class="line">    CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    FollowCamera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Camera&quot;</span>));</span><br><span class="line">    FollowCamera-&gt;<span class="built_in">SetupAttachment</span>(CameraBoom, USpringArmComponent::SocketName);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置摄像机的视角控制</span></span><br><span class="line">    FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>; <span class="comment">// 禁用摄像机的控制器旋转（通常用于第一人称视角）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>project setting - Engine Input （类似unity Input Manager）</p>
<p>设置人物BP_FCharacter - Pawn - 自动控制玩家 - 选择玩家0</p>
<p>FCharacter</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFCharacter::MoveRight);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFCharacter::Turn);   </span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFCharacter::LookUp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Controller &amp;&amp; Value != <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取前向向量并应用移动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完整控制器旋转（包含俯仰角）</span></span><br><span class="line">        <span class="comment">// const FRotator Rotation = Controller-&gt;GetControlRotation();</span></span><br><span class="line">        <span class="comment">//  仅Yaw方向旋转（锁定水平移动）</span></span><br><span class="line">        <span class="type">const</span> FRotator Rotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, Controller-&gt;<span class="built_in">GetControlRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">        <span class="type">const</span> FVector Direction = <span class="built_in">FRotationMatrix</span>(Rotation).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">        <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Controller &amp;&amp; Value != <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取右向向量并应用移动</span></span><br><span class="line">        <span class="comment">// 完整控制器旋转（包含俯仰角）</span></span><br><span class="line">        <span class="comment">// const FRotator Rotation = Controller-&gt;GetControlRotation();</span></span><br><span class="line">        <span class="comment">//  仅Yaw方向旋转（锁定水平移动）</span></span><br><span class="line">        <span class="type">const</span> FRotator Rotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, Controller-&gt;<span class="built_in">GetControlRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">        <span class="type">const</span> FVector Direction = <span class="built_in">FRotationMatrix</span>(Rotation).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">        <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFCharacter::Turn</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理水平旋转输入</span></span><br><span class="line">    <span class="built_in">AddControllerYawInput</span>(Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFCharacter::LookUp</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理垂直旋转输入</span></span><br><span class="line">    <span class="built_in">AddControllerPitchInput</span>(Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Anim"><a href="#Anim" class="headerlink" title="Anim"></a>Anim</h3><p>FAnimInstance</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFAnimInstance::NativeInitializeAnimation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化动画实例时调用</span></span><br><span class="line">    Super::<span class="built_in">NativeInitializeAnimation</span>();</span><br><span class="line">    <span class="comment">//尝试获取角色实例</span></span><br><span class="line">    FCharacter = <span class="built_in">Cast</span>&lt;AFCharacter&gt;(<span class="built_in">TryGetPawnOwner</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFAnimInstance::NativeUpdateAnimation</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每帧更新动画实例时调用</span></span><br><span class="line">    Super::<span class="built_in">NativeUpdateAnimation</span>(DeltaSeconds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(FCharacter == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果FCharacter为空，尝试获取角色实例</span></span><br><span class="line">        FCharacter = <span class="built_in">Cast</span>&lt;AFCharacter&gt;(<span class="built_in">TryGetPawnOwner</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FCharacter == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果仍然为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FVector Velocity = FCharacter-&gt;<span class="built_in">GetVelocity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算角色的速度</span></span><br><span class="line">    <span class="comment">// 忽略垂直分量，通常用于地面移动速度计算</span></span><br><span class="line">    Velocity.Z = <span class="number">0</span>; <span class="comment">// 忽略垂直速度分量</span></span><br><span class="line">    Speed = Velocity.<span class="built_in">Size</span>(); <span class="comment">// 计算速度大小</span></span><br><span class="line"></span><br><span class="line">    bIsInAir= FCharacter-&gt;<span class="built_in">GetMovementComponent</span>()-&gt;<span class="built_in">IsFalling</span>(); <span class="comment">// 检查角色是否在空中</span></span><br><span class="line">    bIsAccelerating = FCharacter-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;<span class="built_in">GetCurrentAcceleration</span>().<span class="built_in">Size</span>() &gt; <span class="number">0</span>; <span class="comment">// 检查角色是否正在加速</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li><p>动画蓝图创建</p>
<ul>
<li>类设置 - 父类设置为 F Anim Instance</li>
</ul>
</li>
<li><p>创建状态机</p>
<ul>
<li>创建状态</li>
<li>创建连线</li>
<li>创建连线条件</li>
</ul>
</li>
<li><p>创建混合空间（<strong>混合空间1D和混合空间的区别</strong>）<a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/blend-spaces-in-unreal-engine">混合空间 </a></p>
<ul>
<li>放入 Idle Walk Run 三个动画</li>
<li>X轴设置为Speed</li>
<li>放入动画状态机 中 并且输入设置为CPP文件中的Speed </li>
</ul>
</li>
</ul>
<h3 id="修改动画手感与摄像机小优化"><a href="#修改动画手感与摄像机小优化" class="headerlink" title="修改动画手感与摄像机小优化"></a>修改动画手感与摄像机小优化</h3><h4 id="自由摄像机视角"><a href="#自由摄像机视角" class="headerlink" title="自由摄像机视角"></a>自由摄像机视角</h4><ul>
<li>FCharacter.cpp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动画后的优化</span></span><br><span class="line">AFCharacter::<span class="built_in">AFCharacter</span>()&#123;</span><br><span class="line">    bUseControllerRotationYaw = <span class="literal">false</span>; <span class="comment">// 禁止控制器偏航旋转</span></span><br><span class="line">	<span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">true</span>; <span class="comment">// 角色朝向移动方向</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<ul>
<li>BP_FCharacter - 使用控制器旋转Yaw - false</li>
<li>CharMoveComp - 将旋转朝向运动 - true</li>
</ul>
<h4 id="下落bug"><a href="#下落bug" class="headerlink" title="下落bug"></a>下落bug</h4><ul>
<li>下落动画Loop</li>
</ul>
<h2 id="无缝切换"><a href="#无缝切换" class="headerlink" title="无缝切换"></a>无缝切换</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/461787677">(99+ 封私信 / 80 条消息) 关卡系统四、无缝切换 - 知乎</a></p>
<p>对于地图切换（也即关卡切换），UE还提供了无缝切换（Seamless Travel）和非无缝切换（Non-Seamless Travel），无缝切换使用<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=190749537&content_type=Article&match_order=1&q=%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD&zhida_source=entity">异步加载</a>关卡资源，是非阻塞式切换，而非无缝切换即为前面介绍的同步加载关卡资源，是阻塞式切换（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/461781710">传送门</a>），在网络联机游戏中，无缝切换不会导致网络断开，而非无缝会导致网络断开后重连，UE推荐在网络联机游戏中使用无缝切换，感兴趣可以看看<a href="https://link.zhihu.com/?target=https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Travelling/">官方文档</a>（有点晦涩难懂T_T，因此需要深入研究一番）。</p>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><ul>
<li><p>创建FLobbyGameMode</p>
</li>
<li><p>设置Pawn为FCharacter </p>
</li>
<li><p>创建过度关卡</p>
</li>
<li><p>在Project Setting 里面设置过度关卡</p>
</li>
<li><p>在GameMode中设置无缝切换</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFLobbyGameMode::PostLogin</span><span class="params">(APlayerController* NewPlayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类实现，确保基础登录流程完成</span></span><br><span class="line">    Super::<span class="built_in">PostLogin</span>(NewPlayer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前已登录玩家数量（游戏状态中的玩家数组人数）</span></span><br><span class="line">    int32 NumofPlayer = GameState.<span class="built_in">Get</span>()-&gt;PlayerArray.<span class="built_in">Num</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当有2名玩家登录时，开始游戏</span></span><br><span class="line">    <span class="keyword">if</span>(NumofPlayer == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">        <span class="keyword">if</span>(World)</span><br><span class="line">        &#123;</span><br><span class="line">            bUseSeamlessTravel = <span class="literal">true</span>;  <span class="comment">// 启用无缝切换地图功能</span></span><br><span class="line">            <span class="comment">// 无缝切换到战斗地图（使用监听服务端模式）</span></span><br><span class="line">            World-&gt;<span class="built_in">ServerTravel</span>(<span class="built_in">FString</span>(<span class="string">&quot;/Game/AFMaps/FBattleMap?listen&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h2><ul>
<li>创建HUD Class</li>
<li>创建WBP继承与HUD Class</li>
<li>在代码中绑定WBP</li>
<li>在FCharacter中设置WBP类以及展示Canvas</li>
<li>在FCharacter蓝图中反射调用UpdateText</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFPlayerHUDWidget::SetDisplayText</span><span class="params">(<span class="type">const</span>  FString&amp; TextToDisplay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DisplayText)</span><br><span class="line">	&#123;</span><br><span class="line">		DisplayText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(TextToDisplay));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFPlayerHUDWidget::UpdateHUD</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ENetRole RemoteRole = InPawn-&gt;<span class="built_in">GetRemoteRole</span>();</span><br><span class="line">	FString Role;</span><br><span class="line">	<span class="keyword">switch</span> (RemoteRole)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> ENetRole::ROLE_Authority:</span><br><span class="line">		Role = <span class="built_in">FString</span>(<span class="string">&quot;Authority&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ENetRole::ROLE_AutonomousProxy:</span><br><span class="line">		Role = <span class="built_in">FString</span>(<span class="string">&quot;Autonomous Proxy&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ENetRole::ROLE_SimulatedProxy:</span><br><span class="line">		Role = <span class="built_in">FString</span>(<span class="string">&quot;Simulated Proxy&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ENetRole::ROLE_None:</span><br><span class="line">		Role = <span class="built_in">FString</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FString RemoteRoleString = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Remote Role: %s&quot;</span>), *Role);</span><br><span class="line">	<span class="built_in">SetDisplayText</span>(RemoteRoleString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFPlayerHUDWidget::NativeDestruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">RemoveFromParent</span>();</span><br><span class="line">	Super::<span class="built_in">NativeDestruct</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetRemoteRole</p>
<h2 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h2><h2 id="11-Camera"><a href="#11-Camera" class="headerlink" title="11.Camera"></a>11.Camera</h2><p><code>CreateDefaultSubobject</code> 是 Unreal Engine（UE）中用于创建组件或子对象的<strong>核心函数</strong>，主要在 C++ 中实现 Actor 或组件的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* <span class="built_in">CreateDefaultSubobject</span>&lt;TReturnType&gt;(FName SubobjectName, <span class="type">bool</span> bIsRequired = <span class="literal">true</span>, <span class="type">bool</span> bIsTransient = <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>TReturnType</code>**：需创建的组件类型（如 <code>USpringArmComponent</code>）。</li>
<li><code>SubobjectName</code>：组件唯一标识（同一 Actor 内不可重复）</li>
<li>**<code>bIsTransient</code>**：若为 <code>true</code>，组件不会被序列化（适用于临时对象）</li>
</ul>
<p><code>SetupAttachment</code> 是用于<strong>建立组件层级关系</strong>的核心方法，主要作用是将一个组件（子组件）附加到另一个组件（父组件）上，形成父子依赖关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">USceneComponent::SetupAttachment</span><span class="params">(USceneComponent* Parent, FName SocketName = NAME_None)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="反射-UPROPERTY"><a href="#反射-UPROPERTY" class="headerlink" title="反射  - UPROPERTY"></a>反射  - UPROPERTY</h4><h1 id="Weapon"><a href="#Weapon" class="headerlink" title="Weapon"></a>Weapon</h1><p>这边开始以阅读源码方式去处理代码部分，可能涉及到下面课程的部分，但主要还是看引擎操作流程。</p>
<h2 id="1-Weapon-Class"><a href="#1-Weapon-Class" class="headerlink" title="1-Weapon Class"></a>1-Weapon Class</h2><ul>
<li><p>创建CPP FWeaponBase</p>
</li>
<li><p>编写代码</p>
<ul>
<li>代码内容为AFWeaponBase 的创建组件与网格<strong>碰撞</strong>（详见主要API 碰撞）的设置</li>
<li>创建组件如下的1.2，1.5-1.10</li>
<li>网格碰撞如下的3.1-3.4</li>
</ul>
</li>
<li><p>创建BP </p>
<ul>
<li>BP继承与FWeaponBase </li>
<li>设置Mesh</li>
</ul>
</li>
</ul>
<h2 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42673921/article/details/84070119">UE4 物理碰撞(C++)_setcollisionresponsetochannel-CSDN博客</a></p>
<table>
<thead>
<tr>
<th><strong><code>SetCollisionResponseToAllChannels(ECollisionResponse Response)</code></strong></th>
<th>设置组件对所有通道的统一响应</th>
<th><code>Response</code>: <code>Ignore</code>、<code>Overlap</code> 或 <code>Block</code></th>
<th>快速全局设置（如禁用所有碰撞）</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse Response)</code></strong></td>
<td>设置组件对单个通道的响应</td>
<td><code>Channel</code>: 目标通道（如<code>ECC_WorldStatic</code>） <code>Response</code>: 响应类型</td>
<td>精细化控制（如角色忽略子弹通道）</td>
</tr>
<tr>
<td><strong><code>SetCollisionEnabled(ECollisionEnabled::Type Type)</code></strong></td>
<td>启用/禁用碰撞检测</td>
<td><code>Type</code>: <code>NoCollision</code>、<code>QueryOnly</code>（仅检测）、<code>PhysicsOnly</code>（仅物理）、<code>QueryAndPhysics</code></td>
<td>动态开关碰撞检测（如死亡后禁用）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><strong>通道名称</strong></th>
<th align="center"><strong>枚举值</strong></th>
<th align="center"><strong>主要用途</strong></th>
<th align="center"><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>WorldStatic</strong></td>
<td align="center"><code>ECC_WorldStatic</code></td>
<td align="center">静态环境物体（不可移动）</td>
<td align="center">墙壁、地面、建筑物等场景静态元素的碰撞阻挡 。</td>
</tr>
<tr>
<td align="center"><strong>WorldDynamic</strong></td>
<td align="center"><code>ECC_WorldDynamic</code></td>
<td align="center">动态物体（可移动或受物理影响）</td>
<td align="center">可移动平台、可破坏物、开关门等动态交互对象 。</td>
</tr>
<tr>
<td align="center"><strong>Pawn</strong></td>
<td align="center"><code>ECC_Pawn</code></td>
<td align="center">玩家或AI控制的角色</td>
<td align="center">角色移动碰撞、AI视线检测、玩家与NPC的交互 。</td>
</tr>
<tr>
<td align="center"><strong>PhysicsBody</strong></td>
<td align="center"><code>ECC_PhysicsBody</code></td>
<td align="center">受物理模拟影响的物体</td>
<td align="center">滚石、箱子、布娃娃等物理驱动对象的碰撞检测 。</td>
</tr>
<tr>
<td align="center"><strong>Visibility</strong></td>
<td align="center"><code>ECC_Visibility</code></td>
<td align="center">可见性检测（非物理阻挡）</td>
<td align="center">光线追踪、玩家视线判断、渲染剔除优化 。</td>
</tr>
<tr>
<td align="center"><strong>Camera</strong></td>
<td align="center"><code>ECC_Camera</code></td>
<td align="center">摄像机碰撞检测</td>
<td align="center">防止摄像机穿墙、第三人称视角的镜头避障 。</td>
</tr>
<tr>
<td align="center"><strong>Destructible</strong></td>
<td align="center"><code>ECC_Destructible</code></td>
<td align="center">可破坏物体</td>
<td align="center">栅栏、玻璃、爆炸物等可破坏对象的碰撞响应 。</td>
</tr>
<tr>
<td align="center"><strong>Vehicle</strong></td>
<td align="center"><code>ECC_Vehicle</code></td>
<td align="center">载具类对象</td>
<td align="center">汽车、坦克、飞行器等载具的物理碰撞与交互 。</td>
</tr>
<tr>
<td align="center"><strong>Gameplay</strong></td>
<td align="center"><code>ECC_GameTraceChannelN</code></td>
<td align="center">预留的自定义游戏逻辑通道（<code>N=1~8</code>）</td>
<td align="center">武器检测（<code>Weapon</code>）、拾取物（<code>Pickup</code>）、陷阱触发等专属交互 。</td>
</tr>
</tbody></table>
<h2 id="2-Pickup-Widget"><a href="#2-Pickup-Widget" class="headerlink" title="2-Pickup Widget"></a>2-Pickup Widget</h2><ul>
<li><p>创建WBP Pickup </p>
</li>
<li><p>加入Text</p>
</li>
<li><p>编写代码 - 添加子物体</p>
<ul>
<li>创建WBP引用</li>
</ul>
</li>
<li><p>BP_Weapon中</p>
<ul>
<li>设置Pickup Widget<ul>
<li>Space-Screen</li>
<li>Widget Class - WBP Pickup</li>
<li>所需大小绘制-true</li>
</ul>
</li>
</ul>
</li>
<li><p>编写代码</p>
<ul>
<li><p>OnSphereOverlap 当有物体进入拾取区域时调用</p>
</li>
<li><p>必须是U函数 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFWeaponBase::OnSphereOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>绑定事件<strong>委托</strong></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AreaSphere-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFWeaponBase::OnSphereOverlap);  <span class="comment">// 3.5 绑定重叠开始事件</span></span><br><span class="line">AreaSphere-&gt;OnComponentEndOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFWeaponBase::OnSphereEndOverlap);  <span class="comment">// 3.6 绑定重叠结束事件</span></span><br></pre></td></tr></table></figure>



<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/ZFSR05255134/article/details/119612832">UE4]委托代理：单播委托，多播委托，动态单播委托，动态多播委托，事件_ue 多播委托-CSDN博客</a></p>
<table>
<thead>
<tr>
<th align="center"><strong>特性</strong></th>
<th align="center"><strong>单播委托</strong></th>
<th align="center"><strong>多播委托</strong></th>
<th align="center"><strong>动态单播委托</strong></th>
<th align="center"><strong>动态多播委托</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>绑定数量</strong></td>
<td align="center">仅绑定 <strong>1个</strong> 函数</td>
<td align="center">可绑定 <strong>多个</strong> 函数</td>
<td align="center">仅绑定 <strong>1个</strong> 函数</td>
<td align="center">可绑定 <strong>多个</strong> 函数</td>
</tr>
<tr>
<td align="center"><strong>执行方式</strong></td>
<td align="center"><code>.Execute()</code></td>
<td align="center"><code>.Broadcast()</code></td>
<td align="center"><code>.Execute()</code></td>
<td align="center"><code>.Broadcast()</code></td>
</tr>
<tr>
<td align="center"><strong>蓝图支持</strong></td>
<td align="center">❌ 不支持蓝图绑定</td>
<td align="center">❌ 不支持蓝图绑定</td>
<td align="center">✅ 支持蓝图绑定（需<code>UFUNCTION</code>）</td>
<td align="center">✅ 支持蓝图绑定（需<code>UFUNCTION</code>）</td>
</tr>
<tr>
<td align="center"><strong>线程安全</strong></td>
<td align="center">非线程安全</td>
<td align="center">非线程安全</td>
<td align="center">非线程安全</td>
<td align="center">非线程安全</td>
</tr>
<tr>
<td align="center"><strong>声明宏</strong></td>
<td align="center"><code>DECLARE_DELEGATE[_Xxx]</code></td>
<td align="center"><code>DECLARE_MULTICAST_DELEGATE[_Xxx]</code></td>
<td align="center"><code>DECLARE_DYNAMIC_DELEGATE[_Xxx]</code></td>
<td align="center"><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE[_Xxx]</code></td>
</tr>
<tr>
<td align="center"><strong>典型用例</strong></td>
<td align="center">一对一回调（如任务完成通知）</td>
<td align="center">事件广播（如伤害事件通知多个系统）</td>
<td align="center">蓝图与C++交互的单次回调</td>
<td align="center">蓝图可订阅的事件系统（如UI事件）</td>
</tr>
</tbody></table>
<h2 id="3-Variable-Replication"><a href="#3-Variable-Replication" class="headerlink" title="3- Variable Replication"></a>3- Variable Replication</h2><ul>
<li><p>复制变量设置</p>
<ul>
<li>在Character设置新变量为<strong>复制变量</strong>（详见主要API 复制变量）</li>
<li>重写 virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>&amp; OutLifetimeProps) const override;</li>
<li>这边<strong>TArray</strong>（详见主要API 数据容器）</li>
<li><strong>DOREPLIFETIME</strong></li>
</ul>
</li>
<li><p>内联宏 <strong>FORCEINLINE</strong>（详见主要API 内联宏）</p>
</li>
<li><p>DOREPLIFETIME_CONDITION(AFCharacter,OverlappingWeapon,COND_OwnerOnly)</p>
</li>
<li><p>复制时回调函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_OverlappingWeapon)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AFWeaponBase</span>* OverlappingWeapon;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_OverlappingWeapon</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>SetOverlappingWeapon</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFCharacter::SetOverlappingWeapon</span><span class="params">(AFWeaponBase* Weapon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OverlappingWeapon)</span><br><span class="line">    &#123;</span><br><span class="line">        OverlappingWeapon-&gt;<span class="built_in">ShowPickupWidget</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    OverlappingWeapon = Weapon;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (OverlappingWeapon)</span><br><span class="line">        &#123;</span><br><span class="line">            OverlappingWeapon-&gt;<span class="built_in">ShowPickupWidget</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边使用了<strong>IsLocallyControlled</strong>()  </p>
<p>退出碰撞函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">OnSphereEndOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置Rep回调函数多一个变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_OverlappingWeapon</span><span class="params">(AFWeaponBase* lastWeapon)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注：这边lastWeapon 会有值（代表着被销毁的前一帧），但是OverlappingWeapon 可能为空，</p>
</li>
</ul>
<h3 id="网络复制（复制变量三部曲）"><a href="#网络复制（复制变量三部曲）" class="headerlink" title="网络复制（复制变量三部曲）"></a>网络复制（复制变量三部曲）</h3><p>在虚幻引擎（Unreal Engine）中，<code>UPROPERTY(Replicated)</code> 是一个核心宏，用于声明一个<strong>网络复制的属性</strong>。其作用是标记该变量（属性）的值需要从服务器（Server）自动同步到所有相关的客户端（Client），以实现多人游戏中状态的一致性。</p>
<h4 id="1-声明复制属性"><a href="#1-声明复制属性" class="headerlink" title="1. 声明复制属性"></a>1. <strong>声明复制属性</strong></h4><p>**<code>ReplicatedUsing</code>**：指定同步后的回调函数为 <code>OnRep_OverlappingWeapon</code>，即属性值在客户端更新后自动触发此函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">float</span> Health;  <span class="comment">// 生命值需从服务器同步到客户端</span></span><br></pre></td></tr></table></figure>

<h4 id="2-重写虚函数"><a href="#2-重写虚函数" class="headerlink" title="2. 重写虚函数"></a>2. <strong>重写虚函数</strong></h4><p>重写 <code>GetLifetimeReplicatedProps</code> 函数  – 在.h声明虚函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用DOREPLIFETIME宏"><a href="#3-使用DOREPLIFETIME宏" class="headerlink" title="3. 使用DOREPLIFETIME宏"></a>3. 使用DOREPLIFETIME宏</h4><ul>
<li>DOREPLIFETIME` 宏是复制注册的关键。</li>
<li><strong>头文件要求</strong>：必须包含 <code>#include &quot;Net/UnrealNetwork.h&quot;</code>。</li>
<li>详见<strong>DOREPLIFETIME宏解析</strong></li>
</ul>
<p>该宏确保 <code>OverlappingWeapon</code>（角色当前重叠的武器对象）仅在特定条件下从服务器同步到客户端。通过 <code>COND_OwnerOnly</code> 条件，<strong>仅同步给控制该角色的客户端</strong>，其他客户端（如队友或敌人）不会收到此数据</p>
<p>在属性所属的类中重写此函数，注册需复制的变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Net/UnrealNetwork.h&quot;</span>  <span class="comment">// 必须包含此头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="built_in">DOREPLIFETIME</span>(AMyActor, Health);  <span class="comment">// 注册Health为复制属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-启用Actor复制"><a href="#4-启用Actor复制" class="headerlink" title="4. 启用Actor复制"></a>4. <strong>启用Actor复制</strong></h4><p>（不包含三部曲中，如果要复制Actor的话用这个代替第一步）</p>
<p>在Actor的构造函数中设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMyActor::<span class="built_in">AMyActor</span>() &#123;</span><br><span class="line">    <span class="built_in">SetReplicates</span>(<span class="literal">true</span>);  <span class="comment">// 开启Actor的网络复制能力</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="数据容器（代替STL）"><a href="#数据容器（代替STL）" class="headerlink" title="数据容器（代替STL）"></a>数据容器（代替STL）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ryacber/article/details/128758764">UE C++基础 | 常用数据容器 | TArray、TMap、TSet_emplace tmap-CSDN博客</a></p>
<h3 id="DOREPLIFETIME宏解析"><a href="#DOREPLIFETIME宏解析" class="headerlink" title="DOREPLIFETIME宏解析"></a>DOREPLIFETIME宏解析</h3><p>在虚幻引擎（Unreal Engine）中，<code>DOREPLIFETIME(AFCharacter, OverlappingWeapon)</code> 是一个核心宏，用于<strong>注册需要网络同步的属性</strong>，确保服务器上 <code>AFCharacter</code> 类中 <code>OverlappingWeapon</code> 变量的值能自动同步到所有客户端。以下是详细解析：</p>
<hr>
<h4 id="🔧-一、功能与作用"><a href="#🔧-一、功能与作用" class="headerlink" title="🔧 一、功能与作用"></a>🔧 <strong>一、功能与作用</strong></h4><ol>
<li><strong>网络同步机制</strong><ul>
<li>当服务器修改 <code>OverlappingWeapon</code>（如角色拾取武器）时，该宏会触发引擎自动将新值广播给所有客户端。</li>
<li>客户端收到数据后更新本地副本，无需手动处理同步逻辑，确保多人游戏中状态一致。</li>
</ul>
</li>
<li><strong>使用场景</strong><ul>
<li>适用于需跨客户端同步的 <code>Actor</code> 引用（如角色当前重叠的武器对象）。</li>
<li>典型案例：角色靠近武器时，客户端需实时显示武器可拾取提示。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="⚙️-二、底层实现原理"><a href="#⚙️-二、底层实现原理" class="headerlink" title="⚙️ 二、底层实现原理"></a>⚙️ <strong>二、底层实现原理</strong></h4><ol>
<li><p><strong>依赖函数</strong><br> 该宏需在 <code>AFCharacter</code> 类的 <code>GetLifetimeReplicatedProps</code> 函数中调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void AFCharacter::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const &#123;</span><br><span class="line">    Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line">    DOREPLIFETIME(AFCharacter, OverlappingWeapon); // 注册同步属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- </p>
</li>
<li><p><strong>属性声明</strong><br> <code>OverlappingWeapon</code> 需用 <code>UPROPERTY(Replicated)</code> 标记为可复制属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROPERTY(Replicated)</span><br><span class="line">class AWeapon* OverlappingWeapon; // 声明为可复制引用</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Actor复制启用</strong><br> 在 <code>AFCharacter</code> 构造函数中需设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AFCharacter::AFCharacter() &#123;</span><br><span class="line">    SetReplicates(true); // 启用Actor的网络复制能力</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="📊-三、同步流程与数据流"><a href="#📊-三、同步流程与数据流" class="headerlink" title="📊 三、同步流程与数据流"></a>📊 <strong>三、同步流程与数据流</strong></h4><table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>服务器</strong></th>
<th><strong>客户端</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>属性修改</strong></td>
<td>调用 <code>SetOverlappingWeapon(NewWeapon)</code></td>
<td>-</td>
</tr>
<tr>
<td><strong>检测变化</strong></td>
<td>引擎自动检测 <code>OverlappingWeapon</code> 变更</td>
<td>-</td>
</tr>
<tr>
<td><strong>广播更新</strong></td>
<td>发送新值给所有客户端</td>
<td>接收更新数据</td>
</tr>
<tr>
<td><strong>应用更新</strong></td>
<td>-</td>
<td>自动更新本地 <code>OverlappingWeapon</code> 值</td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ <strong>注意</strong>：客户端<strong>不能直接修改</strong> <code>Replicated</code> 属性，否则会与服务器值冲突。</p>
</blockquote>
<hr>
<h4 id="🛠️-四、高级用法"><a href="#🛠️-四、高级用法" class="headerlink" title="🛠️ 四、高级用法"></a>🛠️ <strong>四、高级用法</strong></h4><ol>
<li><p><strong>条件复制</strong><br> 通过 <code>DOREPLIFETIME_CONDITION</code> 限制同步范围，优化带宽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOREPLIFETIME_CONDITION(AFCharacter, OverlappingWeapon, COND_OwnerOnly);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>条件类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>COND_InitialOnly</code></td>
<td>仅首次同步时复制（如初始装备）</td>
</tr>
<tr>
<td><code>COND_OwnerOnly</code></td>
<td>仅同步给控制该角色的客户端</td>
</tr>
</tbody></table>
</li>
<li><p><strong>复制通知（RepNotify）</strong><br> 使用 <code>ReplicatedUsing</code> 在属性同步后触发客户端逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UPROPERTY(ReplicatedUsing = OnRep_OverlappingWeapon)</span><br><span class="line">AWeapon* OverlappingWeapon;</span><br><span class="line"></span><br><span class="line">UFUNCTION()</span><br><span class="line">void OnRep_OverlappingWeapon() &#123;</span><br><span class="line">    if (OverlappingWeapon) ShowPickupWidget(true); // 显示拾取UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端属性更新后自动调用 <code>OnRep_OverlappingWeapon</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="⚠️-五、常见问题与注意事项"><a href="#⚠️-五、常见问题与注意事项" class="headerlink" title="⚠️ 五、常见问题与注意事项"></a>⚠️ <strong>五、常见问题与注意事项</strong></h4><ol>
<li><p><strong>权限验证</strong><br> 修改复制属性的代码需在服务器执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void AFCharacter::SetNewWeapon(AWeapon* Weapon) &#123;</span><br><span class="line">    if (HasAuthority()) &#123; // 仅服务器可修改</span><br><span class="line">        OverlappingWeapon = Weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>适用对象限制</strong></p>
<ul>
<li>仅继承自 <code>AActor</code> 的类支持属性复制（如 <code>AFCharacter</code>）。</li>
<li>非 <code>Actor</code> 类（如 <code>UObject</code>）需通过 RPC 或序列化同步。</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li>避免高频同步属性（如每帧更新的位置），优先使用内置组件（如 <code>CharacterMovementComponent</code>）。</li>
<li>对低频属性（如装备状态、交互对象）使用复制更高效。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="💎-总结"><a href="#💎-总结" class="headerlink" title="💎 总结"></a>💎 <strong>总结</strong></h4><p><code>DOREPLIFETIME(AFCharacter, OverlappingWeapon)</code> 是虚幻引擎网络同步的核心机制，通过声明-注册模式实现属性自动同步。结合 <code>ReplicatedUsing</code> 可扩展客户端响应逻辑，而条件复制能进一步优化带宽。在多人游戏中，合理使用该宏可显著提升状态同步的效率和可靠性。</p>
<h3 id="IsLocallyControlled"><a href="#IsLocallyControlled" class="headerlink" title="IsLocallyControlled"></a>IsLocallyControlled</h3><p>在Unreal Engine的多人游戏开发中，类似 <code>IsLocallyControlled()</code> 的函数主要用于处理<strong>网络角色控制权、执行权限和同步逻辑</strong>的判断。以下是关键函数及其作用分类说明，结合了Unreal Engine的网络同步机制设计：</p>
<hr>
<h4 id="🔧-一、角色控制权与执行端判断"><a href="#🔧-一、角色控制权与执行端判断" class="headerlink" title="🔧 一、角色控制权与执行端判断"></a>🔧 一、角色控制权与执行端判断</h4><ol>
<li><p><strong><code>IsLocallyControlled()</code></strong></p>
<ul>
<li><strong>功能</strong>：判断当前角色是否由本地玩家控制（客户端视角）。</li>
<li><strong>典型场景</strong>：客户端特效播放、本地UI更新（如武器拾取提示）。</li>
</ul>
</li>
<li><p><strong><code>HasAuthority()</code></strong></p>
<ul>
<li><strong>功能</strong>：判断当前逻辑是否在服务端（Authority）执行。</li>
<li><strong>场景</strong>：关键状态修改（如生命值扣除）、生成网络同步对象（如武器掉落），确保仅服务端修改全局状态。</li>
</ul>
</li>
<li><p><strong><code>IsNetMode(ENetMode Mode)</code></strong></p>
<ul>
<li><p><strong>功能</strong>：检测当前网络模式（如客户端、服务端、独立运行）。</p>
</li>
<li><p>常用模式：</p>
<ul>
<li><code>NM_Client</code>：当前为客户端。</li>
<li><code>NM_DedicatedServer</code>：专用服务器。</li>
<li><code>NM_ListenServer</code>：监听服务器（同时是主机客户端）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="📡-二、网络执行函数变体"><a href="#📡-二、网络执行函数变体" class="headerlink" title="📡 二、网络执行函数变体"></a>📡 二、网络执行函数变体</h4><ol>
<li><p><strong><code>GetWorld()-&gt;IsServer()</code> / <code>GetWorld()-&gt;IsClient()</code></strong></p>
<ul>
<li><strong>功能</strong>：直接判断当前运行环境是服务端或客户端，与 <code>HasAuthority()</code> 类似但更直观。</li>
</ul>
</li>
<li><p><strong><code>RunOnServer</code> (RPC函数限定符)</strong></p>
<ul>
<li><strong>功能</strong>：通过标记 <code>UFUNCTION(Server, Reliable)</code>，强制函数逻辑在服务端执行。</li>
<li><strong>场景</strong>：客户端发起攻击请求时，需服务端验证并广播同步。</li>
</ul>
</li>
<li><p><strong><code>Client</code> / <code>NetMulticast</code> RPC</strong></p>
<ul>
<li><p>功能：从服务端向客户端广播事件：</p>
<ul>
<li><code>Client</code>：仅发送给控制该角色的客户端。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><code>NetMulticast</code>：发送给所有客户端。</li>
<li><strong>场景</strong>：播放全局特效（如爆炸）、更新多人UI。</li>
</ul>
<hr>
<h4 id="⚙️-三、属性同步与响应函数"><a href="#⚙️-三、属性同步与响应函数" class="headerlink" title="⚙️ 三、属性同步与响应函数"></a>⚙️ 三、属性同步与响应函数</h4><ol>
<li><strong><code>OnRep_[PropertyName]()</code></strong><ul>
<li><strong>功能</strong>：属性标记为 <code>Replicated</code> 后，当属性在客户端同步时自动触发的回调函数。</li>
<li><strong>场景</strong>：客户端根据同步后的生命值更新血条UI。</li>
</ul>
</li>
<li><strong><code>GetNetMode()</code></strong><ul>
<li><strong>功能</strong>：返回当前网络模式枚举值（比 <code>IsNetMode</code> 更灵活），用于分支逻辑处理。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="📊-关键函数对比表"><a href="#📊-关键函数对比表" class="headerlink" title="📊 关键函数对比表"></a>📊 关键函数对比表</h5><table>
<thead>
<tr>
<th><strong>函数/方法</strong></th>
<th><strong>判断目标</strong></th>
<th><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>IsLocallyControlled()</code></td>
<td>角色是否本地控制</td>
<td>本地UI显示、输入响应</td>
</tr>
<tr>
<td><code>HasAuthority()</code></td>
<td>是否在服务端执行</td>
<td>关键状态修改、生成同步对象</td>
</tr>
<tr>
<td><code>IsNetMode(NM_Client)</code></td>
<td>当前是否为客户端环境</td>
<td>环境适配逻辑（如禁用客户端物理）</td>
</tr>
<tr>
<td><code>OnRep_Health()</code></td>
<td>客户端属性同步完成</td>
<td>更新本地UI或播放特效</td>
</tr>
<tr>
<td><code>UFUNCTION(Server)</code></td>
<td>强制函数在服务端运行</td>
<td>客户端发起的动作请求（如拾取武器）</td>
</tr>
<tr>
<td><code>UFUNCTION(NetMulticast)</code></td>
<td>服务端向所有客户端广播</td>
<td>全局事件（如游戏开始通知）</td>
</tr>
</tbody></table>
<hr>
<h4 id="💡-四、组合使用示例"><a href="#💡-四、组合使用示例" class="headerlink" title="💡 四、组合使用示例"></a>💡 四、组合使用示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void AMyCharacter::TryPickupWeapon(AWeapon* Weapon) &#123;</span><br><span class="line">    // 客户端发起请求</span><br><span class="line">    if (IsLocallyControlled()) &#123;</span><br><span class="line">        Server_PickupWeapon(Weapon); // 调用Server RPC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UFUNCTION(Server, Reliable)</span><br><span class="line">void Server_PickupWeapon(AWeapon* Weapon) &#123;</span><br><span class="line">    // 服务端验证并执行</span><br><span class="line">    if (HasAuthority() &amp;&amp; Weapon) &#123;</span><br><span class="line">        Weapon-&gt;AttachToCharacter(this);</span><br><span class="line">        Multicast_PlayPickupFX(); // 广播特效</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UFUNCTION(NetMulticast, Unreliable)</span><br><span class="line">void Multicast_PlayPickupFX() &#123;</span><br><span class="line">    // 所有客户端播放特效</span><br><span class="line">    SpawnPickupParticles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码体现了以下设计原则：</p>
<ol>
<li>本地控制判断（<code>IsLocallyControlled</code>）触发客户端请求 →</li>
<li>服务端权限验证（<code>HasAuthority</code>）执行逻辑 →</li>
<li>广播事件（<code>NetMulticast</code>）同步到所有客户端。</li>
</ol>
<hr>
<h4 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h4><ol>
<li><strong>避免在客户端修改同步属性</strong>：所有需网络同步的属性修改必须通过服务端执行，否则会被引擎覆盖。</li>
<li><strong>RPC的可靠性选择</strong>：关键事件（如角色死亡）用 <code>Reliable RPC</code>；高频非关键事件（如位置微调）用 <code>Unreliable RPC</code>。</li>
<li><strong>网络优化</strong>：通过 <code>NetUpdateFrequency</code> 控制属性同步频率，平衡带宽与实时性需求。</li>
</ol>
<p>这些函数共同构成了Unreal Engine多人游戏开发的底层框架，理解其差异和适用场景是保证网络同步一致性与性能的关键。</p>
<h2 id="4-装备武器"><a href="#4-装备武器" class="headerlink" title="4 装备武器"></a>4 装备武器</h2><ul>
<li><p>创建一个ActorComponent的子类：FShootingComponent</p>
<ul>
<li>在FCharactor中添加 FShootingComponent 的 U变量 </li>
<li>FShootingComponent  加入静态变量并设置 SetIsReplicated –true</li>
</ul>
</li>
<li><p>input 设置Equip</p>
<ul>
<li>FCharactor设置UInputComponent按键回调</li>
</ul>
</li>
<li><p>设置FShootingComponent友元给 FCharactor</p>
<ul>
<li>友元类 可以全访问</li>
</ul>
</li>
<li><p>重载PostInitializeComponents</p>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void PostInitializeComponents() override;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加武器插槽</p>
<ul>
<li>在SK(骨骼)中hand_r右键添加武器插槽</li>
<li>点击预览模型</li>
<li>可以在Anim中查看预览模型位置以调整插槽位置</li>
</ul>
</li>
<li><p>写SetWeapon</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USkeletalMeshComponent* mesh = Character-&gt;<span class="built_in">GetMesh</span>(); <span class="comment">// 获取角色的网格组件</span></span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* hand = mesh-&gt; <span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;RightHandSocket&quot;</span>)); <span class="comment">// 将武器附加到角色的右手插槽</span></span><br><span class="line"><span class="keyword">if</span> (hand)</span><br><span class="line">   &#123;</span><br><span class="line">       hand-&gt;<span class="built_in">AttachActor</span>(CurWeapon, mesh); <span class="comment">// 将武器附加到角色的右手插槽</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;RightHandSocket not found!&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">CurWeapon -&gt;<span class="built_in">SetOwner</span>(Character); <span class="comment">// 设置武器的拥有者为角色</span></span><br></pre></td></tr></table></figure></li>
<li><p>在FCharactor中判断 HasAuthority() 并调用SetWeapon</p>
</li>
</ul>
<h2 id="5-RPC"><a href="#5-RPC" class="headerlink" title="5 RPC"></a>5 RPC</h2><ul>
<li>Sever函数中装备武器：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(Server, Reliable)</span><br><span class="line">void ServerEquipButtonPressed();</span><br></pre></td></tr></table></figure>

<ul>
<li>EquipButtonPressed 区分双端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EquipButtonPressed </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(shootingComponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        shootingComponent-&gt; <span class="built_in">SetWeapon</span>(OverlappingWeapon);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HasAuthority</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//server端装备武器</span></span><br><span class="line">            shootingComponent-&gt; <span class="built_in">SetWeapon</span>(OverlappingWeapon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//客户端请求装备武器</span></span><br><span class="line">            <span class="built_in">ServerEquipButtonPressed</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>



<ul>
<li><p>EquippedWeapon-&gt;SetOwner(Character);</p>
<ul>
<li><p>在这边Owner也是复制变量,OnRep_Owner为回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_Owner) </span><br><span class="line">   TObjectPtr&lt;AActor&gt; Owner;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>把 AFWeapon 的State 变成复制变量 回调函数为 OnRep_WeaponState （如复制变量三部曲）</p>
</li>
</ul>
<p>若 EWS_Equipped 则 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果武器状态为已装备，隐藏拾取UI</span></span><br><span class="line">   <span class="built_in">ShowPickupWidget</span>(<span class="literal">false</span>);</span><br><span class="line">   AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);  <span class="comment">// 禁用碰撞</span></span><br></pre></td></tr></table></figure>

<ul>
<li>那么在UFShootingComponent 中会调用 SetState 从而实现 回调 OnRep_WeaponState</li>
</ul>
<h3 id="RPC流程"><a href="#RPC流程" class="headerlink" title="RPC流程"></a>RPC流程</h3><p>在虚幻引擎（UE）中，<strong>RPC（Remote Procedure Call，远程过程调用）</strong> 是实现网络同步的核心机制，允许客户端与服务器之间跨网络调用函数。以下是完整的RPC制作流程及关键要点，结合C++和蓝图实现方式：</p>
<hr>
<h4 id="🛠️-一、RPC类型与选择"><a href="#🛠️-一、RPC类型与选择" class="headerlink" title="🛠️ 一、RPC类型与选择"></a>🛠️ <strong>一、RPC类型与选择</strong></h4><p>RPC分为三类，需根据场景选择：</p>
<ol>
<li><strong>Server RPC</strong><ul>
<li><strong>作用</strong>：客户端调用 → 服务器执行（如请求跳跃、交互验证）。</li>
<li><strong>标记</strong>：<code>UFUNCTION(Server, Reliable/Unreliable)</code>。</li>
<li><strong>命名规范</strong>：函数名前缀 <code>Server_</code>（如 <code>Server_Jump()</code>）。</li>
</ul>
</li>
<li><strong>Client RPC</strong><ul>
<li><strong>作用</strong>：服务器调用 → <strong>特定客户端</strong>执行（如播放动画、更新UI）。</li>
<li><strong>标记</strong>：<code>UFUNCTION(Client, Reliable/Unreliable)</code>。</li>
<li><strong>命名规范</strong>：函数名前缀 <code>Client_</code>（如 <code>Client_PlayMontage()</code>）。</li>
</ul>
</li>
<li><strong>Multicast RPC</strong><ul>
<li><strong>作用</strong>：服务器调用 → <strong>所有客户端</strong>执行（如爆炸特效、全局事件）。</li>
<li><strong>标记</strong>：<code>UFUNCTION(NetMulticast, Reliable/Unreliable)</code>。</li>
<li><strong>命名规范</strong>：函数名前缀 <code>Multicast_</code>（如 <code>Multicast_Explode()</code>）。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>RPC类型</strong></th>
<th><strong>调用端</strong></th>
<th><strong>执行端</strong></th>
<th><strong>典型场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Server</strong></td>
<td>客户端</td>
<td>服务器</td>
<td>动作请求、状态变更</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>服务器</td>
<td>特定客户端</td>
<td>动画播放、UI更新</td>
</tr>
<tr>
<td><strong>Multicast</strong></td>
<td>服务器</td>
<td>所有客户端</td>
<td>全局特效、环境事件</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>可靠性选择</strong>：</p>
<ul>
<li><code>Reliable</code>：保证必达（关键操作如跳跃、伤害）。</li>
<li><code>Unreliable</code>：允许丢包（高频更新如位置同步）。</li>
</ul>
</blockquote>
<hr>
<h4 id="📝-二、RPC声明与定义"><a href="#📝-二、RPC声明与定义" class="headerlink" title="📝 二、RPC声明与定义"></a>📝 <strong>二、RPC声明与定义</strong></h4><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a><strong>C++实现</strong></h4><ol>
<li><p><strong>头文件声明</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMyCharacter</span> : <span class="keyword">public</span> ACharacter &#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Server RPC示例</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Server, Reliable, WithValidation)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Server_Jump</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Server_Jump_Validate</span><span class="params">()</span></span>; <span class="comment">// 参数验证（防作弊）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Server_Jump_Implementation</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Client RPC示例</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Client, Reliable)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Client_PlayMontage</span><span class="params">(UAnimMontage* Montage)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Client_PlayMontage_Implementation</span><span class="params">(UAnimMontage* Montage)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>源文件实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::Server_Jump_Implementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CanJump</span>()) <span class="built_in">Jump</span>(); <span class="comment">// 服务器逻辑</span></span><br><span class="line">    <span class="built_in">Multicast_Jump</span>();      <span class="comment">// 广播到所有客户端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMyCharacter::Server_Jump_Validate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// 验证逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::Client_PlayMontage_Implementation</span><span class="params">(UAnimMontage* Montage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>()) <span class="built_in">PlayAnimMontage</span>(Montage); <span class="comment">// 仅本地客户端执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="蓝图实现"><a href="#蓝图实现" class="headerlink" title="蓝图实现"></a><strong>蓝图实现</strong></h4><ol>
<li>创建自定义事件：<ul>
<li>在蓝图编辑器中右键 → <em>Add Event</em> → <em>Custom Event</em>。</li>
<li>设置事件名称（如 <code>PlayMontageEvent</code>）。</li>
</ul>
</li>
<li>标记为RPC：<ul>
<li>在事件详情面板 → <em>Replicates</em> → 选择 <em>Server</em>/<em>Client</em>/<em>Multicast</em>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="🔐-三、权限控制与调用条件"><a href="#🔐-三、权限控制与调用条件" class="headerlink" title="🔐 三、权限控制与调用条件"></a>🔐 <strong>三、权限控制与调用条件</strong></h4><ul>
<li><p>调用者权限：</p>
<ul>
<li><strong>Server RPC</strong>：仅客户端可调用，且Actor需被客户端<strong>控制</strong>（如 <code>IsLocallyControlled()</code>）。</li>
<li><strong>Client/Multicast RPC</strong>：仅服务器可调用。</li>
</ul>
</li>
<li><p>执行端检查：</p>
<ul>
<li><p>在RPC实现中，使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetLocalRole()</span><br></pre></td></tr></table></figure>

<p> 或 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HasAuthority()</span><br></pre></td></tr></table></figure>

<p> 区分执行环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void AMyCharacter::Client_PlayMontage_Implementation(UAnimMontage* Montage) &#123;</span><br><span class="line">    if (GetLocalRole() == ROLE_SimulatedProxy) return; // 非主控端跳过</span><br><span class="line">    PlayAnimMontage(Montage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Actor复制要求：</p>
<ul>
<li>RPC调用的Actor必须开启复制（<code>bReplicates = true</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="⚙️-四、参数处理与序列化"><a href="#⚙️-四、参数处理与序列化" class="headerlink" title="⚙️ 四、参数处理与序列化"></a>⚙️ <strong>四、参数处理与序列化</strong></h4><ul>
<li><strong>支持类型</strong>：基础类型（<code>int</code>、<code>float</code>、<code>FString</code>）、结构体、<code>UObject</code>指针（需网络同步）。</li>
<li>对象参数限制：<ul>
<li>传递的 <code>UObject*</code>（如 <code>UAnimMontage*</code>）必须在<strong>所有客户端加载</strong>，否则需用 <code>SoftObjectPath</code> 异步加载。</li>
</ul>
</li>
<li>结构体序列化：<ul>
<li>若结构体包含动态数据，需重写 <code>NetSerialize()</code> 函数优化流量。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="📡-五、RPC调用流程"><a href="#📡-五、RPC调用流程" class="headerlink" title="📡 五、RPC调用流程"></a>📡 <strong>五、RPC调用流程</strong></h4><ol>
<li><p><strong>触发调用</strong>：</p>
<ul>
<li><p>客户端触发Server RPC</p>
<p>（如输入事件）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::OnJumpInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>()) <span class="built_in">Server_Jump</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务器触发Client RPC（如播放动画）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::TriggerMontageOnClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) <span class="built_in">Client_PlayMontage</span>(JumpMontage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>网络传输</strong>：</p>
<ul>
<li>可靠RPC立即发送，不可靠RPC随属性同步发送。</li>
<li>数据顺序：可靠RPC → 属性复制 → 不可靠RPC（同一Actor通道内有序）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="🧪-六、调试与测试"><a href="#🧪-六、调试与测试" class="headerlink" title="🧪 六、调试与测试"></a>🧪 <strong>六、调试与测试</strong></h4><ol>
<li>多玩家测试：<ul>
<li>编辑器开启多个PIE窗口：1个为服务器，其余为客户端。</li>
</ul>
</li>
<li>网络模拟：<ul>
<li>控制台命令 <code>net.PktLoss=20</code> 模拟丢包，验证RPC可靠性。</li>
</ul>
</li>
<li>日志追踪：<ul>
<li>使用 <code>UE_LOG(LogNet, Log, TEXT(&quot;RPC Called&quot;))</code> 输出调用记录。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="⚠️-七、常见问题与优化"><a href="#⚠️-七、常见问题与优化" class="headerlink" title="⚠️ 七、常见问题与优化"></a>⚠️ <strong>七、常见问题与优化</strong></h4><ol>
<li>时序问题：<ul>
<li>避免在Actor初始化前调用RPC（如 <code>BeginPlay</code> 中），优先在 <code>PostInitializeComponents()</code> 后调用。</li>
</ul>
</li>
<li>流量优化：<ul>
<li>高频更新（如位置同步）用 <strong>不可靠RPC + 属性复制</strong> 组合。</li>
</ul>
</li>
<li>安全性：<ul>
<li>Server RPC必须添加 <code>WithValidation</code> 验证参数（如检测坐标是否合法）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="💎-总结流程"><a href="#💎-总结流程" class="headerlink" title="💎 总结流程"></a>💎 <strong>总结流程</strong></h4><ol>
<li><strong>设计RPC类型</strong> → 2. <strong>声明函数并标记UFUNCTION</strong> → 3. <strong>实现逻辑与验证</strong> → 4. <strong>权限检查</strong> → 5. <strong>参数传递优化</strong> → 6. <strong>网络测试与调试</strong>。<br> 通过合理使用RPC，可高效实现多人游戏的实时交互，同时确保安全性与流畅性。</li>
</ol>
<h2 id="6-动画"><a href="#6-动画" class="headerlink" title="6 动画"></a>6 动画</h2><ul>
<li><p>在FAnim中声明一个变量 : 武器是否装配(bool)</p>
</li>
<li><p>把FShootingComponent组件中的武器提升成复制变量（如复制变量三部曲）</p>
</li>
<li><p>在新建一个子FSM   – 在Blend Poses by bool 节点上 – 武器是否装配(bool) 来当 Condition</p>
<ul>
<li>这个子FSM代表的是已装配FSM - Equipped</li>
<li>之前上一章的FSM是未装配FSM - Unequipped</li>
</ul>
</li>
<li><p>Equipped 创建idle  State </p>
</li>
</ul>
<h2 id="7-下蹲"><a href="#7-下蹲" class="headerlink" title="7 下蹲"></a>7 下蹲</h2><p>继承与Character Croush 有 bIsCroushed 的bool 这个还是一个复制变量 </p>
<p>在AFAnim中设置  this-&gt; bIsCroushed = bIsCroushed  然后在FSM设置Condition</p>
<h2 id="8-瞄准"><a href="#8-瞄准" class="headerlink" title="8 瞄准"></a>8 瞄准</h2><p>tmp：动画 Play Idle_Rifle_Ironsights  Play Idle_Rifle_Hip  idle状态中</p>
<p>Croush 中也一样</p>
<ul>
<li><p>bAnim （bool）定义</p>
</li>
<li><p>在FCharactor（取Component的），FAnim  ，shootingComponent</p>
</li>
<li><p>bAnim 提升成复制变量</p>
<ul>
<li>这边只能从S-&gt;C 才同步</li>
</ul>
</li>
<li><p>使用RPC </p>
<ul>
<li>这边才能C-&gt; C and S</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFShootingComponent::SetAiming</span><span class="params">(<span class="type">bool</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bAnim = b; <span class="comment">// 设置动画状态</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Character-&gt;<span class="built_in">HasAuthority</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果不是服务器端，调用服务器函数来设置动画状态</span></span><br><span class="line">		<span class="built_in">ServerSetAiming</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFShootingComponent::ServerSetAiming_Implementation</span><span class="params">(<span class="type">bool</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bAnim = b; <span class="comment">// 设置动画状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边HasAuthority其实不必要 </p>
<p>在C调用Server RPC 是S执行，后调整bAnim数值</p>
<p>在S调用Server RPC 是S执行，里面的逻辑不会同步到All C，但这边 bAnim为复制变量可以同步All C</p>
<h1 id="源码阅读笔记"><a href="#源码阅读笔记" class="headerlink" title="源码阅读笔记"></a>源码阅读笔记</h1><h2 id="BlasterCharacter"><a href="#BlasterCharacter" class="headerlink" title="BlasterCharacter"></a>BlasterCharacter</h2><h3 id="input（完结）"><a href="#input（完结）" class="headerlink" title="input（完结）"></a>input（完结）</h3><p>Input  ==  SetupPlayerInputComponent</p>
<p>前后左右:</p>
<p>用欧拉角判断Vector</p>
<p>欧拉角:</p>
<p>pitch()：俯仰，将物体绕X轴旋转（localRotationX）</p>
<p>yaw()：航向，将物体绕Y轴旋转（localRotationY）</p>
<p>roll()：横滚，将物体绕Z轴旋转（localRotationZ）</p>
<p>Jump( ):</p>
<p>蹲伏</p>
<p>CrouchButtonPressed ( )</p>
<p>用UE自带的Character重写</p>
<p>装备–EquipButtonPressed( )</p>
<p>真正逻辑在Combat中</p>
<p>瞄准</p>
<p>AimButtonPressed( )</p>
<p>AimButtonReleased( )</p>
<p>开火</p>
<p>FireButtonPressed( )<br>FireButtonReleased( )</p>
<p>换弹</p>
<p>ReloadButtonPressed( )</p>
<p>投掷</p>
<p>GrenadeButtonPressed( )</p>
<p>装备</p>
<p>EquipButtonPressed( )</p>
<h3 id="HUD-（完结）"><a href="#HUD-（完结）" class="headerlink" title="HUD （完结）"></a>HUD （完结）</h3><ul>
<li><p>OnRep_Health</p>
<ul>
<li>PlayHitReactMontage( ) ==&gt;详见动画 TODO</li>
<li>UpdateHUDHealth ==&gt; BlasterPlayerController-&gt;SetHUDHealth ==&gt; BlasterHUD</li>
</ul>
</li>
<li><p>OnRep_Shield 盾</p>
<ul>
<li>PlayHitReactMontage( ) ==&gt;详见动画 TODO</li>
<li>UpdateHUDShield ==&gt; BlasterPlayerController-&gt;SetHUDShield ==&gt; BlasterHUD</li>
</ul>
</li>
<li><p>UpdateHUDGrenade ==&gt; BlasterPlayerController-&gt;SetHUDGrenades==&gt; BlasterHUD</p>
</li>
</ul>
<ul>
<li>UpdateHUDAmmo弹药<ul>
<li>BlasterPlayerController-&gt;SetHUDCarriedAmmo  SetHUDWeaponAmmo ==&gt; BlasterHUD</li>
</ul>
</li>
</ul>
<h3 id="动画调用"><a href="#动画调用" class="headerlink" title="动画调用"></a>动画调用</h3><p>PlayFireMontage( )</p>
<p>PlayReloadMontage( )</p>
<p>PlayElimMontage( )</p>
<p>PlayThrowGrenadeMontage ( )</p>
<p>PlaySwapMontage( )</p>
<p>PlayHitReactMontage( )</p>
<p>提供给Anim的接口</p>
<p>GetCombatState</p>
<p>IsLocallyReloading</p>
<p>IsAiming</p>
<p>CalculateSpeed</p>
<p>CalculateAO_Pitch</p>
<p>AimOffset</p>
<h3 id="Charactor-生命周期"><a href="#Charactor-生命周期" class="headerlink" title="Charactor 生命周期"></a>Charactor 生命周期</h3><ul>
<li><p>Elim( )死亡</p>
<ul>
<li><p>DropOrDestroyWeapons( ) 丢弃武器    </p>
<ul>
<li>DropOrDestroyWeapon( )  <ul>
<li>Weapon Actor::Destroy( ) or Dropped( ) 结束</li>
</ul>
</li>
</ul>
</li>
<li><p>MulticastElim( ) –TODO 多播淘汰效果</p>
<ul>
<li>StartDissolve  UpdateDissolveMaterial</li>
<li>ElimTimerFinished</li>
</ul>
</li>
<li><p>ServerLeaveGame 服务器离开游戏</p>
</li>
</ul>
</li>
<li><p>Destroyed (Actor)</p>
<ul>
<li><p>ElimBotComponent ==&gt;DestroyComponent (SceneCompent)</p>
</li>
<li><p>Combat 销毁武器</p>
</li>
</ul>
</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul>
<li><p>GetLifetimeReplicatedProps  (ACharacter) 注册属性复制</p>
</li>
<li><p>SpawnDefaultWeapon 获得默认武器</p>
<ul>
<li><p>Combat-&gt;EquipWeapon(StartingWEeapon);</p>
<p>​        </p>
</li>
</ul>
</li>
<li><p>PostInitializeComponents  (ACharacter) 初始化组件</p>
<ul>
<li>Combat</li>
<li>Buff</li>
<li>LagCompensation</li>
</ul>
</li>
</ul>
<ul>
<li>OnPlayerStateInitialized 初始化PlayerState<ul>
<li>SetSpawnPoint</li>
<li>SetTeamColor</li>
</ul>
</li>
<li>ReceiveDamage  TODO 造成伤害</li>
</ul>
<h3 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h3><p>RotateInPlace</p>
<p>HideCameraIfCharacterClose</p>
<p>PollInit</p>
<h3 id="prop-and-rep"><a href="#prop-and-rep" class="headerlink" title="prop and rep"></a>prop and rep</h3><p>GetTeam</p>
<p>SetTeamColor</p>
<p>SetOverlappingWeapon</p>
<p>OnRep_OverlappingWeapon</p>
<h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>SetHoldingTheFlag</p>
<p>IsHoldingTheFlag</p>
<h2 id="UCombatComponent"><a href="#UCombatComponent" class="headerlink" title="UCombatComponent"></a>UCombatComponent</h2><ul>
<li>瞄准 SetAiming<ul>
<li>RPC<ul>
<li>服务器权威  瞄准移动速度降低 </li>
</ul>
</li>
<li>瞄准移动速度降低 设置原生Charactor MaxWalkSpeed</li>
<li>狙击枪开镜 UI</li>
<li>预测（网络延迟）<ul>
<li>SetAiming 记录本地玩家的瞄准按钮状态</li>
<li>OnRep_Aiming </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>在虚幻引擎的多人游戏开发中，<code>OnRep_Aiming</code>（复制回调函数）与<code>SetAiming</code>（本地预测函数）结合使用，能够有效缓解网络延迟带来的瞄准状态同步问题。其核心原理在于<strong>客户端预测 + 服务器权威验证 + 延迟补偿修正</strong>的协同机制，具体分析如下：</p>
<hr>
<h4 id="一、网络延迟问题的本质"><a href="#一、网络延迟问题的本质" class="headerlink" title="一、网络延迟问题的本质"></a>一、网络延迟问题的本质</h4><p>网络延迟导致客户端操作（如按下瞄准键）与服务器状态同步之间存在时间差。若仅依赖服务器同步（如通过RPC或变量复制），玩家会感受到明显的操作延迟（如按下右键后角色需等待数百毫秒才举枪）。这种延迟会严重破坏实时游戏的体验。</p>
<hr>
<h4 id="二、SetAiming的作用：本地预测与快速响应"><a href="#二、SetAiming的作用：本地预测与快速响应" class="headerlink" title="二、SetAiming的作用：本地预测与快速响应"></a>二、<code>SetAiming</code>的作用：本地预测与快速响应</h4><ol>
<li><p><strong>即时状态更新</strong></p>
<p>当玩家按下瞄准键时，<code>SetAiming</code><strong>立即更新本地客户端的 <code>bAiming</code>状态</strong>（如 <code>bAiming = true</code>），并调整角色移动速度、显示狙击镜UI等视觉效果。这实现了操作的“零延迟”响应。</p>
</li>
<li><p><strong>发起服务器同步</strong></p>
<p>通过 <code>ServerSetAiming</code>RPC 将操作请求发送给服务器，要求服务器权威验证并更新状态。</p>
</li>
<li><p><strong>预测执行</strong></p>
<p>客户端在等待服务器确认期间，<strong>假定操作会被服务器接受</strong>，提前执行相关逻辑（如移动速度变化）。这种预测机制是减少感知延迟的核心。</p>
</li>
</ol>
<hr>
<h4 id="三、OnRep-Aiming的作用：延迟补偿与状态修正"><a href="#三、OnRep-Aiming的作用：延迟补偿与状态修正" class="headerlink" title="三、OnRep_Aiming的作用：延迟补偿与状态修正"></a>三、<code>OnRep_Aiming</code>的作用：延迟补偿与状态修正</h4><ol>
<li><p><strong>响应服务器同步</strong></p>
<p><code>OnRep_Aiming</code>是虚幻引擎的<strong>复制回调函数</strong>，当服务器通过变量复制将 <code>bAiming</code>的新值同步到客户端时，该函数自动触发。</p>
</li>
<li><p><strong>覆盖复制的延迟状态</strong></p>
<p>若网络延迟较高，服务器同步的 <code>bAiming</code>值可能过时（例如玩家已松开右键，但服务器仍同步“瞄准中”状态）。此时 <code>OnRep_Aiming</code>会用本地记录的 <code>bAimButtonPressed</code>（实时记录按键状态）<strong>覆盖复制的值</strong>，确保客户端状态与玩家实时操作一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void UCombatComponent::OnRep_Aiming() &#123;</span><br><span class="line">    if (Character &amp;&amp; Character-&gt;IsLocallyControlled()) &#123;</span><br><span class="line">        bAiming = bAimButtonPressed; // 用本地按键状态修正复制值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>避免状态回滚抖动</strong></p>
<p>若未使用此机制，客户端会在收到旧状态时错误地回退到过时状态（如突然收起狙击镜再重新举起），导致画面抖动。<code>OnRep_Aiming</code>的修正逻辑避免了这一问题。</p>
</li>
</ol>
<hr>
<h4 id="四、协作机制：解决延迟的核心逻辑"><a href="#四、协作机制：解决延迟的核心逻辑" class="headerlink" title="四、协作机制：解决延迟的核心逻辑"></a>四、协作机制：解决延迟的核心逻辑</h4><ol>
<li><p><strong>预测-验证-修正流程</strong></p>
<ul>
<li><strong>客户端预测</strong>：<code>SetAiming</code>立即执行本地操作并通知服务器。</li>
<li><strong>服务器验证</strong>：服务器通过 <code>ServerSetAiming</code>更新权威状态并复制到所有客户端。</li>
<li><strong>客户端修正</strong>：<code>OnRep_Aiming</code>在收到复制值时，用本地实时状态覆盖延迟的复制值。</li>
</ul>
</li>
<li><p><strong>权限隔离</strong></p>
<ul>
<li>仅对本地控制角色（<code>IsLocallyControlled()</code>）启用修正逻辑，远程角色直接使用复制值，避免逻辑冲突。</li>
</ul>
</li>
<li><p><strong>降低感知延迟</strong></p>
<p>玩家始终看到与自身操作一致的状态（即使网络延迟存在），而服务器仍保持状态权威性，防止作弊。</p>
</li>
</ol>
<hr>
<h4 id="五、对比传统方案的优势"><a href="#五、对比传统方案的优势" class="headerlink" title="五、对比传统方案的优势"></a>五、对比传统方案的优势</h4><table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>响应速度</strong></th>
<th><strong>状态一致性</strong></th>
<th><strong>抗延迟能力</strong></th>
</tr>
</thead>
<tbody><tr>
<td>纯RPC同步</td>
<td>低（需等待RPC往返）</td>
<td>高</td>
<td>弱</td>
</tr>
<tr>
<td>纯变量复制</td>
<td>低（依赖复制周期）</td>
<td>中（可能过时）</td>
<td>中</td>
</tr>
<tr>
<td><code>SetAiming</code>+<code>OnRep</code></td>
<td><strong>高</strong>（本地预测）</td>
<td><strong>高</strong>（延迟补偿）</td>
<td><strong>强</strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="六、适用场景与局限性"><a href="#六、适用场景与局限性" class="headerlink" title="六、适用场景与局限性"></a>六、适用场景与局限性</h4><ul>
<li><strong>适用场景</strong>：需快速响应的操作（如瞄准、射击、跳跃）。</li>
<li><strong>局限性</strong>：<ul>
<li>需严格区分本地/远程角色逻辑。</li>
<li>高丢包率下预测可能频繁出错（需结合重传机制）。</li>
<li>复杂状态（如物理模拟）需更精细的预测回滚算法。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h4 id="OnRep-Aiming与-SetAiming的协作本质是客户端预测执行-服务器权威验证-复制延迟补偿："><a href="#OnRep-Aiming与-SetAiming的协作本质是客户端预测执行-服务器权威验证-复制延迟补偿：" class="headerlink" title="OnRep_Aiming与 SetAiming的协作本质是客户端预测执行 + 服务器权威验证 + 复制延迟补偿："></a><code>OnRep_Aiming</code>与 <code>SetAiming</code>的协作本质是<strong>客户端预测执行 + 服务器权威验证 + 复制延迟补偿</strong>：</h4><ol>
<li><p><code>SetAiming</code>实现本地操作的即时反馈（预测）；</p>
</li>
<li><p><code>OnRep_Aiming</code>在服务器状态同步后修正网络延迟导致的误差（补偿）。</p>
<p>这一机制在保持服务器权威性的前提下，最大限度消除了玩家感知到的操作延迟，是实时多人游戏中网络同步设计的核心模式。</p>
</li>
</ol>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>开火 FireButtonPressed</p>
<p>开火流程（以 <code>UCombatComponent::Fire()</code> 为核心）如下：</p>
<ol>
<li><p><strong>按下射击按钮</strong><br>玩家按下射击按钮，调用 <code>FireButtonPressed(true)</code>，进而调用 <code>Fire()</code>。</p>
</li>
<li><p><strong>条件检查</strong><br><code>Fire()</code> 内部通过 <code>CanFire()</code> 检查是否满足开火条件（如弹药、冷却、状态等）。</p>
</li>
<li><p><strong>锁定射击</strong><br>满足条件后，设置 <code>bCanFire = false</code>，防止连发。</p>
</li>
<li><p><strong>分类型射击</strong><br>根据当前武器类型（抛射物、射线、霰弹枪）分别调用 <code>FireProjectileWeapon()</code>、<code>FireHitScanWeapon()</code> 或 <code>FireShotgun()</code>。</p>
</li>
<li><p><strong>本地预测</strong><br>如果是客户端（非服务器），先本地执行 <code>LocalFire()</code> 或 <code>ShotgunLocalFire()</code>，立即播放动画和武器效果，实现射击预测。</p>
</li>
<li><p><strong>服务器同步</strong><br>客户端通过 RPC（如 <code>ServerFire()</code>、<code>ServerShotgunFire()</code>）通知服务器进行权威判定。</p>
</li>
<li><p><strong>多播同步</strong><br>服务器通过 <code>MulticastFire()</code> 或 <code>MulticastShotgunFire()</code> 广播所有客户端，确保所有玩家看到一致的射击效果。</p>
</li>
<li><p><strong>冷却计时</strong><br>调用 <code>StartFireTimer()</code> 启动射击冷却，冷却结束后允许再次射击。</p>
</li>
</ol>
<p>整个流程保证了射击的即时反馈（本地预测）和网络同步（服务器权威+多播）。</p>
<p>换弹Reload</p>
<p>换弹（Reload）流程如下：</p>
<ol>
<li><p><strong>触发换弹</strong><br>玩家点击换弹按钮，调用 <code>Reload()</code>。</p>
</li>
<li><p><strong>条件检查</strong><br><code>Reload()</code> 检查携带弹药、武器状态、是否满弹、是否正在本地换弹等，只有全部满足才继续。</p>
</li>
<li><p><strong>本地与服务器同步</strong>  </p>
<ul>
<li>客户端调用 <code>ServerReload()</code>，请求服务器同步换弹。</li>
<li>客户端本地执行 <code>HandleReload()</code>，播放换弹动画，并设置 <code>bLocallyReloading = true</code>。</li>
</ul>
</li>
<li><p><strong>服务器处理</strong>  </p>
<ul>
<li><code>ServerReload_Implementation()</code> 设置 <code>CombatState = ECS_Reloading</code>。</li>
<li>非本地控制角色时，服务器也调用 <code>HandleReload()</code> 播放动画。</li>
</ul>
</li>
<li><p><strong>动画结束/换弹完成</strong>  </p>
<ul>
<li>动画结束后，调用 <code>FinishReloading()</code>。</li>
<li>服务器端：更新弹药数据，<code>CombatState</code> 设为 <code>ECS_Unoccuiped</code>。</li>
<li>客户端：重置 <code>bLocallyReloading</code>，如射击按钮仍按下则自动开火。</li>
</ul>
</li>
<li><p><strong>弹药同步</strong>  </p>
<ul>
<li><code>UpdateAmmoValues()</code> 更新弹匣和携带弹药，并同步到 HUD。</li>
</ul>
</li>
</ol>
<p>整个流程保证了本地即时反馈、服务器权威同步和弹药数据一致性。</p>
<p>投掷 ThrowGrenade</p>
<p>投掷手雷（ThrowGrenade）流程如下：</p>
<ol>
<li><p><strong>触发投掷</strong><br>玩家点击投掷手雷按钮，调用 <code>ThrowGrenade()</code>。</p>
</li>
<li><p><strong>条件检查</strong><br>检查手雷数量、战斗状态和武器有效性，只有全部满足才继续。</p>
</li>
<li><p><strong>本地动画与显示</strong>  </p>
<ul>
<li>设置 <code>CombatState = ECS_ThrowingGrenade</code>。</li>
<li>本地控制角色播放投掷动画，切换武器到左手，显示手雷模型。</li>
</ul>
</li>
<li><p><strong>服务器同步</strong>  </p>
<ul>
<li>非服务器端调用 <code>ServerThrowGrenade()</code>，请求服务器同步投掷。</li>
<li>服务器端减少手雷数量，更新HUD，播放动画和显示。</li>
</ul>
</li>
<li><p><strong>动画结束/投掷完成</strong>  </p>
<ul>
<li>动画结束后，调用 <code>ThrowGrenadeFinished()</code>，恢复战斗状态，武器回到右手。</li>
</ul>
</li>
<li><p><strong>手雷发射</strong>  </p>
<ul>
<li>调用 <code>LaunchGrenade()</code>，本地显示手雷消失，并通过 <code>ServerLaunchGrenade()</code> 在服务器生成手雷抛射物。</li>
</ul>
</li>
</ol>
<p>整个流程保证了本地即时反馈、服务器权威同步和手雷数量一致性。</p>
<h2 id="ULagCompensationComponent"><a href="#ULagCompensationComponent" class="headerlink" title="ULagCompensationComponent"></a>ULagCompensationComponent</h2><p><code>ULagCompensationComponent</code> 主要用于延迟补偿（Lag Compensation），确保网络射击命中判定的公平性。各函数作用如下：</p>
<ul>
<li><p><strong>构造函数/BeginPlay/TickComponent</strong><br>初始化组件，Tick 时保存每帧的碰撞盒快照（FramePackage）。</p>
</li>
<li><p><strong>InterpBetweenFrames</strong><br>在两帧之间插值，重建某一时刻角色的碰撞盒状态。</p>
</li>
<li><p><strong>ConfirmHit/ProjectileConfirmHit/ShotgunConfirmHit</strong><br>用于命中判定：  </p>
<ul>
<li><code>ConfirmHit</code>：命中检测（如射线武器），优先检测头部，再检测身体。  </li>
<li><code>ProjectileConfirmHit</code>：用于投射物武器，预测弹道后检测碰撞。  </li>
<li><code>ShotgunConfirmHit</code>：霰弹枪多目标多弹丸命中检测，分别统计头部和身体命中数。</li>
</ul>
</li>
<li><p><strong>CacheBoxPositions/MoveBoxes/ResetHitBoxes/EnableCharacterMeshCollision</strong>  </p>
<ul>
<li><code>CacheBoxPositions</code>：缓存角色当前所有碰撞盒的位置、旋转、大小。  </li>
<li><code>MoveBoxes</code>：将角色碰撞盒移动到指定快照状态。  </li>
<li><code>ResetHitBoxes</code>：恢复碰撞盒到原始状态并关闭碰撞。  </li>
<li><code>EnableCharacterMeshCollision</code>：设置角色网格体的碰撞开关。</li>
</ul>
</li>
<li><p><strong>ShowFramePackage</strong><br>用于调试，显示某一帧的所有碰撞盒。</p>
</li>
<li><p><strong>ServerSideRewind/ProjectileServerSideRewind/ShotgunServerSideRewind</strong><br>服务器端回溯到指定时间点，进行命中判定。</p>
</li>
<li><p><strong>GetFrameToCheck</strong><br>根据时间戳，从历史帧中获取或插值出需要判定的帧。</p>
</li>
<li><p><strong>ServerScoreRequest_Implementation/ProjectileServerScoreRequest_Implementation/ShotgunServerScoreRequest_Implementation</strong><br>服务器端处理命中结果，应用伤害。</p>
</li>
<li><p><strong>SaveFramePackageServer/SaveFramePackage</strong><br>保存当前帧的碰撞盒快照到历史记录中。</p>
</li>
</ul>
<h2 id="Weapon-1"><a href="#Weapon-1" class="headerlink" title="Weapon"></a>Weapon</h2><p>Weapon.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WeaponMesh-&gt;<span class="built_in">SetCustomDepthStencilValue</span>(CUSTOM_DEPTH_BLUE);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">MarkRenderStateDirty</span>(); <span class="comment">// 强制更新渲染状态</span></span><br><span class="line"><span class="built_in">EnableCustomDepth</span>(<span class="literal">true</span>); <span class="comment">// 启用轮廓效果</span></span><br></pre></td></tr></table></figure>

<p>Bloom效果</p>
<h3 id="霰弹枪与步枪区别"><a href="#霰弹枪与步枪区别" class="headerlink" title="霰弹枪与步枪区别"></a>霰弹枪与步枪区别</h3><p>在你的代码中，霰弹枪（Shotgun）和步枪（如步枪/步枪类武器，AssaultRifle）主要区别体现在以下几个方面：</p>
<ol>
<li><strong>武器类型区分</strong><br>通过 <code>EWeaponType</code> 和 <code>EFireType</code> 枚举区分，霰弹枪通常是 <code>EWT_Shotgun</code>，步枪是 <code>EWT_AssaultRifle</code>，它们的 <code>FireType</code> 也不同：  </li>
</ol>
<ul>
<li>步枪：<code>EFireType::EFT_HitScan</code>（射线检测，单发命中）  </li>
<li>霰弹枪：<code>EFireType::EFT_Shotgun</code>（一次发射多颗弹丸，散射）</li>
</ul>
<ol start="2">
<li><strong>开火逻辑</strong>  </li>
</ol>
<ul>
<li>步枪调用 <code>FireHitScanWeapon()</code>，只处理一个命中点，单发或连发。</li>
<li>霰弹枪调用 <code>FireShotgun()</code>，会生成多个命中点（弹丸散射），并用 <code>Shotgun-&gt;ShotgunTraceEndWithScatter()</code> 计算所有弹丸的落点，<code>Shotgun-&gt;FireShotgun()</code> 处理多弹丸伤害。</li>
</ul>
<ol start="3">
<li><strong>换弹逻辑</strong>  </li>
</ol>
<ul>
<li>步枪换弹一次性填满弹匣，调用 <code>UpdateAmmoValues()</code>。</li>
<li>霰弹枪采用“逐发装填”，每次装填一发，调用 <code>UpdateShotgunAmmoValues()</code>，并在弹匣满或无子弹时跳转到装填动画结束。</li>
</ul>
<ol start="4">
<li><strong>射击动画与同步</strong>  </li>
</ol>
<ul>
<li>步枪射击只需同步一次命中点。</li>
<li>霰弹枪射击需要同步所有弹丸的命中点数组（<code>TArray&lt;FVector_NetQuantize&gt;</code>）。</li>
</ul>
<ol start="5">
<li><strong>CanFire 特殊处理</strong><br>霰弹枪在装填过程中允许中断射击（即装填时也能开火），步枪则不允许。</li>
</ol>
<p><strong>总结</strong>：  </p>
<ul>
<li>步枪是单发/连发、单点命中，射线检测，换弹一次性填满。</li>
<li>霰弹枪是多弹丸散射、逐发装填，射击和同步都处理多个命中点，装填时可中断射击。</li>
</ul>
<p>这些差异体现在武器类型、开火方式、换弹方式和网络同步等核心逻辑上。</p>
<h3 id="投掷武器特点"><a href="#投掷武器特点" class="headerlink" title="投掷武器特点"></a>投掷武器特点</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fragmentary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/17/0071-UEBlastj/">http://example.com/2025/07/17/0071-UEBlastj/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">零の領域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ue/">ue</a></div><div class="post_share"><div class="social-share" data-image="/img/p_66349124.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/27/0072-UEAPI/" title="UE常见API"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UE常见API</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/09/0070-lua5.4/" title="Lua 5.4 源码"><img class="cover" src="/img/p_66349124.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Lua 5.4 源码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/08/24/0076-UEPython/" title="UE Python"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-24</div><div class="title">UE Python</div></div></a></div><div><a href="/2025/08/08/0075-UEDs/" title="UE 联机"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-08</div><div class="title">UE 联机</div></div></a></div><div><a href="/2025/08/03/0073-UEBase/" title="UE基础"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="title">UE基础</div></div></a></div><div><a href="/2025/08/03/0074-UELyra/" title="UE Lyra"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="title">UE Lyra</div></div></a></div><div><a href="/2025/07/27/0072-UEAPI/" title="UE常见API"><img class="cover" src="/img/p_66349124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-27</div><div class="title">UE常见API</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/pixiv_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fragmentary</div><div class="author-info__description">一个摸鱼人的日常博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fragmentary1002"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Fragmentary1002" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://space.bilibili.com/165064718?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fa-solid fa-tv"></i></a><a class="social-icon" href="https://www.youtube.com/@mentaryFrag" target="_blank" title="youtube"><i class="fa-brands fa-youtube"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是一个博客~ 好吧这是我的学习笔记 一个Unity客户端开发者的日常</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%EF%BC%88%E5%BE%85%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">插件编写（待）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Play%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">Play设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">编译模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%EF%BC%88ENetMode%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">网络模式（ENetMode）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">更新插件代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%803C"><span class="toc-number">2.</span> <span class="toc-text">基础3C</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">项目建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">建立网络连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">2.3.</span> <span class="toc-text">资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3C"><span class="toc-number">2.4.</span> <span class="toc-text">3C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Character"><span class="toc-number">2.4.1.</span> <span class="toc-text">Character</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Camera"><span class="toc-number">2.4.2.</span> <span class="toc-text">Camera</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control"><span class="toc-number">2.4.3.</span> <span class="toc-text">Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Anim"><span class="toc-number">2.4.4.</span> <span class="toc-text">Anim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%8A%A8%E7%94%BB%E6%89%8B%E6%84%9F%E4%B8%8E%E6%91%84%E5%83%8F%E6%9C%BA%E5%B0%8F%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.5.</span> <span class="toc-text">修改动画手感与摄像机小优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E6%91%84%E5%83%8F%E6%9C%BA%E8%A7%86%E8%A7%92"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">自由摄像机视角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%90%BDbug"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">下落bug</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BC%9D%E5%88%87%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">无缝切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GameMode"><span class="toc-number">2.5.1.</span> <span class="toc-text">GameMode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HUD"><span class="toc-number">2.6.</span> <span class="toc-text">HUD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81API"><span class="toc-number">2.7.</span> <span class="toc-text">主要API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Camera"><span class="toc-number">2.8.</span> <span class="toc-text">11.Camera</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-UPROPERTY"><span class="toc-number">2.8.0.1.</span> <span class="toc-text">反射  - UPROPERTY</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Weapon"><span class="toc-number">3.</span> <span class="toc-text">Weapon</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Weapon-Class"><span class="toc-number">3.1.</span> <span class="toc-text">1-Weapon Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E"><span class="toc-number">3.2.</span> <span class="toc-text">碰撞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Pickup-Widget"><span class="toc-number">3.3.</span> <span class="toc-text">2-Pickup Widget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">3.3.1.</span> <span class="toc-text">委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Variable-Replication"><span class="toc-number">3.4.</span> <span class="toc-text">3- Variable Replication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A4%8D%E5%88%B6%EF%BC%88%E5%A4%8D%E5%88%B6%E5%8F%98%E9%87%8F%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">网络复制（复制变量三部曲）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%A4%8D%E5%88%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">1. 声明复制属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%86%99%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">2. 重写虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8DOREPLIFETIME%E5%AE%8F"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">3. 使用DOREPLIFETIME宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%AF%E7%94%A8Actor%E5%A4%8D%E5%88%B6"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">4. 启用Actor复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BB%A3%E6%9B%BFSTL%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">数据容器（代替STL）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOREPLIFETIME%E5%AE%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">3.4.3.</span> <span class="toc-text">DOREPLIFETIME宏解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%A7-%E4%B8%80%E3%80%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">🔧 一、功能与作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E4%BA%8C%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">⚙️ 二、底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8A-%E4%B8%89%E3%80%81%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">📊 三、同步流程与数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">🛠️ 四、高级用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.3.5.</span> <span class="toc-text">⚠️ 五、常见问题与注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.3.6.</span> <span class="toc-text">💎 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsLocallyControlled"><span class="toc-number">3.4.4.</span> <span class="toc-text">IsLocallyControlled</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%A7-%E4%B8%80%E3%80%81%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6%E6%9D%83%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%AB%AF%E5%88%A4%E6%96%AD"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">🔧 一、角色控制权与执行端判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%A1-%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8F%98%E4%BD%93"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">📡 二、网络执行函数变体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E4%B8%89%E3%80%81%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">⚙️ 三、属性同步与响应函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%93%8A-%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">3.4.4.3.1.</span> <span class="toc-text">📊 关键函数对比表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E5%9B%9B%E3%80%81%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">💡 四、组合使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">⚠️ 注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A3%85%E5%A4%87%E6%AD%A6%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">4 装备武器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-RPC"><span class="toc-number">3.6.</span> <span class="toc-text">5 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.1.</span> <span class="toc-text">RPC流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E4%B8%80%E3%80%81RPC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">🛠️ 一、RPC类型与选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%9D-%E4%BA%8C%E3%80%81RPC%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">📝 二、RPC声明与定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">C++实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.1.4.</span> <span class="toc-text">蓝图实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%90-%E4%B8%89%E3%80%81%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%B0%83%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.6.1.5.</span> <span class="toc-text">🔐 三、权限控制与调用条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%9B%9B%E3%80%81%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.6.1.6.</span> <span class="toc-text">⚙️ 四、参数处理与序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%A1-%E4%BA%94%E3%80%81RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.1.7.</span> <span class="toc-text">📡 五、RPC调用流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%85%AD%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">3.6.1.8.</span> <span class="toc-text">🧪 六、调试与测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">3.6.1.9.</span> <span class="toc-text">⚠️ 七、常见问题与优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.1.10.</span> <span class="toc-text">💎 总结流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8A%A8%E7%94%BB"><span class="toc-number">3.7.</span> <span class="toc-text">6 动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%8B%E8%B9%B2"><span class="toc-number">3.8.</span> <span class="toc-text">7 下蹲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%9E%84%E5%87%86"><span class="toc-number">3.9.</span> <span class="toc-text">8 瞄准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0"><span class="toc-number">4.</span> <span class="toc-text">源码阅读笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlasterCharacter"><span class="toc-number">4.1.</span> <span class="toc-text">BlasterCharacter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">input（完结）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HUD-%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">HUD （完结）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">动画调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Charactor-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">Charactor 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init"><span class="toc-number">4.1.5.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tick"><span class="toc-number">4.1.6.</span> <span class="toc-text">Tick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prop-and-rep"><span class="toc-number">4.1.7.</span> <span class="toc-text">prop and rep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flag"><span class="toc-number">4.1.8.</span> <span class="toc-text">Flag</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UCombatComponent"><span class="toc-number">4.2.</span> <span class="toc-text">UCombatComponent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">预测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">一、网络延迟问题的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SetAiming%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A%E6%9C%AC%E5%9C%B0%E9%A2%84%E6%B5%8B%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%93%8D%E5%BA%94"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">二、SetAiming的作用：本地预测与快速响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81OnRep-Aiming%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF%E4%B8%8E%E7%8A%B6%E6%80%81%E4%BF%AE%E6%AD%A3"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">三、OnRep_Aiming的作用：延迟补偿与状态修正</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">四、协作机制：解决延迟的核心逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">五、对比传统方案的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">4.2.1.6.</span> <span class="toc-text">六、适用场景与局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.1.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OnRep-Aiming%E4%B8%8E-SetAiming%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A2%84%E6%B5%8B%E6%89%A7%E8%A1%8C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%83%E5%A8%81%E9%AA%8C%E8%AF%81-%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF%EF%BC%9A"><span class="toc-number">4.2.1.8.</span> <span class="toc-text">OnRep_Aiming与 SetAiming的协作本质是客户端预测执行 + 服务器权威验证 + 复制延迟补偿：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO"><span class="toc-number">4.2.2.</span> <span class="toc-text">TODO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ULagCompensationComponent"><span class="toc-number">4.3.</span> <span class="toc-text">ULagCompensationComponent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Weapon-1"><span class="toc-number">4.4.</span> <span class="toc-text">Weapon</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%B0%E5%BC%B9%E6%9E%AA%E4%B8%8E%E6%AD%A5%E6%9E%AA%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.1.</span> <span class="toc-text">霰弹枪与步枪区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E6%8E%B7%E6%AD%A6%E5%99%A8%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.2.</span> <span class="toc-text">投掷武器特点</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/24/0076-UEPython/" title="UE Python"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE Python"/></a><div class="content"><a class="title" href="/2025/08/24/0076-UEPython/" title="UE Python">UE Python</a><time datetime="2025-08-24T11:29:00.747Z" title="发表于 2025-08-24 19:29:00">2025-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/0075-UEDs/" title="UE 联机"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE 联机"/></a><div class="content"><a class="title" href="/2025/08/08/0075-UEDs/" title="UE 联机">UE 联机</a><time datetime="2025-08-07T16:00:00.000Z" title="发表于 2025-08-08 00:00:00">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/03/0073-UEBase/" title="UE基础"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE基础"/></a><div class="content"><a class="title" href="/2025/08/03/0073-UEBase/" title="UE基础">UE基础</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/03/0074-UELyra/" title="UE Lyra"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE Lyra"/></a><div class="content"><a class="title" href="/2025/08/03/0074-UELyra/" title="UE Lyra">UE Lyra</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/27/0072-UEAPI/" title="UE常见API"><img src="/img/p_66349124.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE常见API"/></a><div class="content"><a class="title" href="/2025/07/27/0072-UEAPI/" title="UE常见API">UE常见API</a><time datetime="2025-07-27T01:16:49.000Z" title="发表于 2025-07-27 09:16:49">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Fragmentary</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>