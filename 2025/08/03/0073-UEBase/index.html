<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>UE基础 | 零の領域</title><meta name="author" content="Fragmentary"><meta name="copyright" content="Fragmentary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本篇为UE使用过程中关于某些API 或者 某些底层机制的Common 处理。 某些东西深入研究可以多开一篇文章。 FSoftObjectPath在 Unreal Engine（UE）中，FSoftObjectPath 是一种用于间接引用资产（Asset）的核心机制，它通过存储资源的路径字符串而非直接加载资源，实现按需加载和内存优化。以下是其核心概念、用法及技术细节： 🔍 一、FSoftObj">
<meta property="og:type" content="article">
<meta property="og:title" content="UE基础">
<meta property="og:url" content="http://example.com/2025/08/03/0073-UEBase/index.html">
<meta property="og:site_name" content="零の領域">
<meta property="og:description" content="前言本篇为UE使用过程中关于某些API 或者 某些底层机制的Common 处理。 某些东西深入研究可以多开一篇文章。 FSoftObjectPath在 Unreal Engine（UE）中，FSoftObjectPath 是一种用于间接引用资产（Asset）的核心机制，它通过存储资源的路径字符串而非直接加载资源，实现按需加载和内存优化。以下是其核心概念、用法及技术细节： 🔍 一、FSoftObj">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bg/default_cover.png">
<meta property="article:published_time" content="2025-08-02T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-12T16:48:39.960Z">
<meta property="article:author" content="Fragmentary">
<meta property="article:tag" content="ue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/bg/default_cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/08/03/0073-UEBase/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-13 00:48:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg/pixiv_cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg/default_cover.png')"><nav id="nav"><span id="blog-info"><a href="/" title="零の領域"><span class="site-name">零の領域</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UE基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-12T16:48:39.960Z" title="更新于 2025-11-13 00:48:39">2025-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ue/">ue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UE基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇为UE使用过程中关于某些API 或者 某些底层机制的Common 处理。</p>
<p>某些东西深入研究可以多开一篇文章。</p>
<h1 id="FSoftObjectPath"><a href="#FSoftObjectPath" class="headerlink" title="FSoftObjectPath"></a>FSoftObjectPath</h1><p>在 Unreal Engine（UE）中，<code>FSoftObjectPath</code> 是一种用于<strong>间接引用资产（Asset）</strong>的核心机制，它通过存储资源的路径字符串而非直接加载资源，实现按需加载和内存优化。以下是其核心概念、用法及技术细节：</p>
<h3 id="🔍-一、FSoftObjectPath-核心概念"><a href="#🔍-一、FSoftObjectPath-核心概念" class="headerlink" title="🔍 一、FSoftObjectPath 核心概念"></a>🔍 一、FSoftObjectPath 核心概念</h3><ol>
<li><strong>作用与原理</strong><ol>
<li><strong>路径存储</strong>：存储资源的完整路径（如 <code>StaticMesh&#39;/Game/Meshes/Cube.Cube&#39;</code>），但不加载资源本身<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">4,6</a>。</li>
<li><strong>按需加载</strong>：通过调用 <code>TryLoad()</code> 或异步接口显式加载资源，避免启动时内存占用过高。</li>
<li><strong>软引用类型</strong>：属于软引用（Soft Reference），与硬引用（<code>UObject*</code>）相比，不强制资源常驻内存<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">6</a>。</li>
</ol>
</li>
<li><strong>路径格式解析</strong> 资源路径的典型结构：</li>
<li> [资源类型]’[分区]/[路径]/[包名].[对象名]’</li>
<li>示例： <code>StaticMesh&#39;/Game/Meshes/Cube.Cube&#39;</code><ol>
<li><strong>分区</strong>：<code>/Game</code>（项目资源）或 <code>/Engine</code>（引擎资源）<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">5</a>。</li>
<li><strong>包名</strong>：磁盘上的 <code>.uasset</code> 文件名（如 <code>Cube</code>）。</li>
<li><strong>对象名</strong>：资源文件内的具体对象名（默认与包名相同）<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">5</a>。</li>
</ol>
</li>
</ol>
<h3 id="⚙️-二、代码实现与用法"><a href="#⚙️-二、代码实现与用法" class="headerlink" title="⚙️ 二、代码实现与用法"></a>⚙️ 二、代码实现与用法</h3><h4 id="1-声明与编辑器配置"><a href="#1-声明与编辑器配置" class="headerlink" title="1. 声明与编辑器配置"></a>1. 声明与编辑器配置</h4><p> // 头文件声明</p>
<p> UPROPERTY(EditAnywhere, Category=”Assets”)</p>
<p> FSoftObjectPath MeshPath;  // 可接受任意资源类型</p>
<p> UPROPERTY(EditDefaultsOnly, meta=(AllowedClasses=”Texture”)) // 限制为纹理类</p>
<p> FSoftObjectPath TexturePath; </p>
<ul>
<li><strong>编辑器支持</strong>：在 UE 编辑器中，属性面板会显示资源选择器，允许直接拾取资源<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">4,6</a>。</li>
</ul>
<h4 id="2-资源加载方式"><a href="#2-资源加载方式" class="headerlink" title="2. 资源加载方式"></a>2. 资源加载方式</h4><ul>
<li><strong>同步加载</strong>（适合小资源）：</li>
<li> UObject* LoadedObject = MeshPath.TryLoad(); UStaticMesh* Mesh = Cast<UStaticMesh>(LoadedObject); if (Mesh) { /* 使用网格 */ }</li>
<li>注意：大资源同步加载可能导致卡顿<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">4</a>。</li>
<li><strong>异步加载</strong>（推荐）： 需结合 <code>FStreamableManager</code> 实现：</li>
<li> FStreamableManager&amp; Streamer = …; Streamer.RequestAsyncLoad(     MeshPath.ToString(),      this {          UStaticMesh* Mesh = Cast<UStaticMesh>(MeshPath.ResolveObject());         // 资源加载完成后的回调     } );</li>
</ul>
<h4 id="3-动态设置路径"><a href="#3-动态设置路径" class="headerlink" title="3. 动态设置路径"></a>3. 动态设置路径</h4><p> // 代码中动态修改路径</p>
<p> MeshPath.SetPath(TEXT(“StaticMesh’/Game/Meshes/Sphere.Sphere’”));</p>
<h3 id="⚖️-三、软引用-vs-硬引用"><a href="#⚖️-三、软引用-vs-硬引用" class="headerlink" title="⚖️ 三、软引用 vs. 硬引用"></a>⚖️ 三、软引用 vs. 硬引用</h3><table>
<thead>
<tr>
<th>特性</th>
<th>软引用（FSoftObjectPath）</th>
<th>硬引用（UObject*）</th>
</tr>
</thead>
<tbody><tr>
<td>内存占用</td>
<td>不自动加载资源，内存占用低</td>
<td>资源常驻内存</td>
</tr>
<tr>
<td>加载时机</td>
<td>显式调用 TryLoad() 时加载</td>
<td>父对象加载时自动加载</td>
</tr>
<tr>
<td>适用场景</td>
<td>大型资源（如地图、高精度模型）</td>
<td>高频使用的小资源（如材质）</td>
</tr>
<tr>
<td>GC 影响</td>
<td>卸载后资源可被回收</td>
<td>持有引用时资源不会被 GC 释放</td>
</tr>
</tbody></table>
<h3 id="💡-四、实际应用场景"><a href="#💡-四、实际应用场景" class="headerlink" title="💡 四、实际应用场景"></a>💡 四、实际应用场景</h3><ol>
<li><strong>动态资源加载</strong><ol>
<li>根据玩家进度加载不同关卡资源，减少初始包体积<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">5</a>。</li>
<li>示例：开放世界游戏中按区域加载地形网格。</li>
</ol>
</li>
<li><strong>资源热更新</strong> 通过重定向路径到下载的新资源包，实现热更新<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">6</a>。</li>
<li><strong>避免循环依赖</strong> 软引用可解耦模块间依赖，例如：<code>Gameplay</code> 模块通过路径引用 <code>Asset</code> 模块的资源，无需编译依赖。</li>
</ol>
<h3 id="⚠️-五、常见问题与优化"><a href="#⚠️-五、常见问题与优化" class="headerlink" title="⚠️ 五、常见问题与优化"></a>⚠️ 五、常见问题与优化</h3><ol>
<li><strong>路径失效</strong><ol>
<li><strong>原因</strong>：资源移动或重命名后路径未更新。</li>
<li><strong>解决方案</strong>：使用 <strong>重定向器（Redirector）</strong> 或编辑器工具 <strong>Fix Up Redirectors</strong>。</li>
</ol>
</li>
<li><strong>异步加载卡顿</strong><ol>
<li><strong>优化策略</strong>：分帧加载（如每帧加载 1 个资源），或预加载到内存池<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">4</a>。</li>
</ol>
</li>
<li><strong>类型安全</strong><ol>
<li>使用 </li>
<li> TSoftObjectPtr<T></li>
<li> 替代 </li>
<li> FSoftObjectPath</li>
<li>，限制资源类型：</li>
<li> TSoftObjectPtr<UTexture> SafeTexturePath; // 仅允许纹理类</li>
</ol>
</li>
</ol>
<h3 id="💎-总结"><a href="#💎-总结" class="headerlink" title="💎 总结"></a>💎 总结</h3><ul>
<li><strong>核心价值</strong>：<code>FSoftObjectPath</code> 通过路径解耦资源引用，是优化内存与加载性能的关键工具。</li>
<li>最佳实践：<ul>
<li>大型资源用异步加载 + 回调；</li>
</ul>
</li>
<li>高频小资源用硬引用；<ul>
<li>动态场景用 <code>TSoftObjectPtr</code> 确保类型安全<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">4,6</a>。</li>
</ul>
</li>
<li><strong>调试工具</strong>：控制台命令 <code>Obj List</code> 查看加载的资源状态。</li>
</ul>
<blockquote>
<p>深入参考：</p>
<ul>
<li>UE 官方文档：<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/en-US/async-asset-loading-in-unreal-engine/">Async Asset Loading</a></li>
<li>实战案例：<a target="_blank" rel="noopener" href="https://github.com/UnrealEngine/Resources">UE5 Resource Management</a></li>
</ul>
</blockquote>
<h1 id="Actor生命周期"><a href="#Actor生命周期" class="headerlink" title="Actor生命周期"></a>Actor生命周期</h1><p><a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-actor-lifecycle">https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-actor-lifecycle</a></p>
<p><img src="./../../pic/picture/0073-UEBase/1761188735788-3.png" alt="img"></p>
<p>Unreal Engine 中 Actor 的生命周期管理是其游戏对象系统的核心。下面我将 Actor 的几种主要生成路径及其生命周期阶段用表格形式整理出来，并补充一些关键细节和注意事项。</p>
<h3 id="🧭-总览：Actor-的四种主要生成路径"><a href="#🧭-总览：Actor-的四种主要生成路径" class="headerlink" title="🧭 总览：Actor 的四种主要生成路径"></a>🧭 总览：Actor 的四种主要生成路径</h3><table>
<thead>
<tr>
<th>路径名称</th>
<th>触发场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>从磁盘加载 (Load from Disk)</td>
<td>关卡加载（LoadMap）或流关卡加载（AddToWorld）时。</td>
<td>适用于在编辑器中预先放置好的静态 Actor</td>
</tr>
<tr>
<td>在编辑器中播放 (Play in Editor, PIE)</td>
<td>在编辑器内点击“Play”按钮启动游戏时。</td>
<td>Actor 是从编辑器中的原始对象复制而来，避免影响原始资产。</td>
</tr>
<tr>
<td>动态生成 (Spawning)</td>
<td>运行时通过 UWorld::SpawnActor 函数动态创建。</td>
<td>最常见的运行时生成方式，用于敌人、道具、特效等。</td>
</tr>
<tr>
<td>延迟生成 (Deferred Spawning)</td>
<td>运行时通过 UWorld::SpawnActorDeferred 函数动态创建。</td>
<td>允许在调用蓝图构造脚本之前设置Actor的属性。</td>
</tr>
</tbody></table>
<ol>
<li>从磁盘加载 (Load from Disk)</li>
</ol>
<p>这是指那些在编辑器中预先放置好、随关卡一起从磁盘加载的 Actor 的生命周期路径。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
<th>常见用途与注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>从磁盘加载</td>
<td>Actor 及其所在的包/关卡从硬盘被读取到内存中。</td>
<td>硬盘读取速度（SSD vs HDD）影响加载时间。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">6</a></td>
</tr>
<tr>
<td>PostLoad</td>
<td>Actor 反序列化完成后调用。与 PostActorCreated 互斥。</td>
<td>在此处理自定义版本迁移和数据修复。是加载路径独有的阶段。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>InitializeActorsForPlay</td>
<td>引擎内部函数，准备 Actor 以开始游戏。</td>
<td></td>
</tr>
<tr>
<td>RouteActorInitialize</td>
<td>为未初始化的 Actor 执行初始化路由。</td>
<td>包含 Stream Level 的加载。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>PreInitializeComponents</td>
<td>在 Actor 自身的组件初始化之前调用。</td>
<td>可进行一些初始化所需的准备工作，例如配表。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
</tr>
<tr>
<td>InitializeComponent</td>
<td>在 Actor 的每个组件上调用。</td>
<td>是组件自身的初始化点，按注册顺序调用。</td>
</tr>
<tr>
<td>PostInitializeComponents</td>
<td>Actor 的所有组件都已初始化后调用。</td>
<td>此时可以安全地访问和操作其他组件。</td>
</tr>
<tr>
<td>BeginPlay</td>
<td>关卡正式开始游戏时调用。</td>
<td>开始执行游戏逻辑，如启动计时器、绑定事件。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,4</a></td>
</tr>
</tbody></table>
<ol>
<li>在编辑器中播放 (Play in Editor - PIE)</li>
</ol>
<p>此路径与“从磁盘加载”非常相似，但源不同，主要用于调试。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
<th>与“从磁盘加载”路径的主要差异</th>
</tr>
</thead>
<tbody><tr>
<td>复制Actor</td>
<td>将编辑器中的原始 Actor 复制到一个新的、专用于PIE的世界中。</td>
<td>源是编辑器中的现有对象，而非磁盘上的包文件。</td>
</tr>
<tr>
<td>PostDuplicate</td>
<td>复制完成后调用。</td>
<td>替代了 PostLoad 阶段，是PIE路径独有的阶段。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>InitializeActorsForPlay</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>RouteActorInitialize</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>PreInitializeComponents</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>InitializeComponent</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>PostInitializeComponents</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>BeginPlay</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>动态生成 (Spawning)</li>
</ol>
<p>这是游戏运行时<strong>动态创建</strong> Actor（如生成敌人、子弹）最常用的方式。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">9</a></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
<th>常见用途与注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>SpawnActor</td>
<td>调用 UWorld::SpawnActor 函数。</td>
<td>需提供有效的 UClass、位置变换和生成参数。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">9</a></td>
</tr>
<tr>
<td>PostSpawnInitialize</td>
<td>引擎内部初始化流程。</td>
<td></td>
</tr>
<tr>
<td>PostActorCreated</td>
<td>Actor 对象在内存中创建后立即调用。与 PostLoad 互斥。</td>
<td>可在此执行类似构造函数的初始化行为。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>ExecuteConstruction</td>
<td>执行 Actor 的构建逻辑。</td>
<td></td>
</tr>
<tr>
<td>OnConstruction</td>
<td>（主要在蓝图中使用）构建脚本被调用。</td>
<td>蓝图Actor在此创建组件并初始化蓝图变量。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>PostActorConstruction</td>
<td>Actor 构建完成。</td>
<td></td>
</tr>
<tr>
<td>PreInitializeComponents</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>InitializeComponent</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>PostInitializeComponents</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
<tr>
<td>OnActorSpawned</td>
<td>在 UWorld 上广播生成事件。</td>
<td>其他系统可监听此事件，得知某个Actor已生成完毕。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>BeginPlay</td>
<td>同“从磁盘加载”路径。</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>延迟生成 (Deferred Spawning)</li>
</ol>
<p>这种生成方式允许你在 Actor 的蓝图构造脚本运行<em>之前</em>配置其属性。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
<th>与“动态生成”路径的主要差异</th>
</tr>
</thead>
<tbody><tr>
<td>SpawnActorDeferred</td>
<td>调用 UWorld::SpawnActorDeferred 函数。</td>
<td>生成一个未完成构建的Actor实例，并返回其指针。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>(执行SpawnActor内的步骤)</td>
<td>同“动态生成”路径，直到 PostActorCreated。</td>
<td></td>
</tr>
<tr>
<td>自定义初始化</td>
<td>在 PostActorCreated 后，你有机会使用这个有效的、但不完整的 Actor 实例进行自定义初始化设置（例如，设置其暴露（Expose on Spawn）的属性）。</td>
<td>这是延迟生成的核心目的，在运行构建脚本前配置属性。</td>
</tr>
<tr>
<td>FinishSpawningActor</td>
<td>调用此函数以最终完成Actor的生成过程。</td>
<td>此函数会继续执行“动态生成”路径中 ExecuteConstruction 及之后的所有步骤。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
</tbody></table>
<h3 id="⛔-生命周期的结束-End-of-Life"><a href="#⛔-生命周期的结束-End-of-Life" class="headerlink" title="⛔ 生命周期的结束 (End of Life)"></a>⛔ 生命周期的结束 (End of Life)</h3><p>无论通过哪种路径生成，Actor的销毁过程都是统一的。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
<th>调用时机与常见操作</th>
</tr>
</thead>
<tbody><tr>
<td>Destroy</td>
<td>手动调用，表示希望销毁Actor。游戏仍在继续。</td>
<td>Actor被标记为 PendingKill 并从关卡的Actor数组中移除。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>EndPlay</td>
<td>核心的清理函数。保证Actor生命终结时被调用。</td>
<td>必须在此进行所有重要的清理工作：  • 解除事件绑定  • 清除定时器 (GetWorld()-&gt;GetTimerManager().ClearAllTimersForObject(this))<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>  • 释放动态分配的资源<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>  • 网络复制的清理</td>
</tr>
<tr>
<td>（原因）</td>
<td></td>
<td>调用 EndPlay 的常见原因：<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a>  • 显式调用 Destroy  • PIE会话结束  • 关卡转换（无缝旅行或加载新地图）  • 包含该Actor的流关卡被卸载  • Actor的生存期（Lifespan）到期  • 应用程序关闭</td>
</tr>
<tr>
<td>OnDestroy</td>
<td>较旧的遗留函数，响应 Destroy 调用。</td>
<td>建议将清理逻辑移至 EndPlay，因为 EndPlay 在更多情况下（如关卡转换）会被调用。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>标记待销毁</td>
<td>Actor被标记为 <strong>RF_PendingKill</strong>。</td>
<td>此后，尝试获取该Actor的指针可能会失败或返回空。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>垃圾回收 (Garbage Collection)</td>
<td>引擎的垃圾回收系统会在一段时间后真正从内存中释放该对象。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
<td></td>
</tr>
<tr>
<td>BeginDestroy</td>
<td>对象有机会释放内存和处理多线程资源。</td>
<td>大多数游戏性清理应在 EndPlay 中完成，此处处理底层资源释放。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>IsReadyForFinishDestroy</td>
<td>GC过程调用此函数，询问对象是否可被永久释放。</td>
<td>返回 false 可以延迟实际销毁，直到下一个GC周期。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
<tr>
<td>FinishDestroy</td>
<td>对象被销毁，是释放内部数据结构的最后机会。</td>
<td>内存释放前的最后一次调用。<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a></td>
</tr>
</tbody></table>
<h3 id="💎-总结与建议"><a href="#💎-总结与建议" class="headerlink" title="💎 总结与建议"></a>💎 总结与建议</h3><p>理解 Actor 的生命周期对于编写稳定、无内存泄漏的 UE 代码至关重要。</p>
<ul>
<li><strong>初始化逻辑的位置</strong>：根据需求选择正确的初始化阶段。<code>PostLoad</code> 用于版本迁移，<code>PostActorCreated</code> 用于 C++ 构造函数逻辑，<code>InitializeComponents</code> 用于组件初始化，<code>PostInitializeComponents</code> 用于依赖其他组件的逻辑，<code>BeginPlay</code> 用于最终的游戏逻辑开始。</li>
<li><strong>清理逻辑的位置</strong>：**<code>EndPlay</code> 是你最重要的朋友**。几乎所有针对游戏性的清理工作，如解绑事件、清除计时器、释放引用等，都应在此进行。不要依赖析构函数或 <code>OnDestroy</code>。</li>
<li><strong>生成方式的选择</strong>： <ul>
<li>静态放置 → <strong>从磁盘加载</strong></li>
<li>运行时动态生成 → <strong><code>SpawnActor</code></strong></li>
<li>运行时动态生成且需在构建前设置“Expose on Spawn”属性 → <strong><code>SpawnActorDeferred</code></strong></li>
</ul>
</li>
<li><strong>警惕关卡转换和流关卡卸载</strong>：这些情况也会触发 <code>EndPlay</code>，确保你的 Actor 能正确处理，防止出现“关卡切换后报错”的问题。</li>
</ul>
<p>希望这份详细的表格能帮助你更好地驾驭 Unreal Engine 中的 Actor。</p>
<h1 id="ESlateVisibility"><a href="#ESlateVisibility" class="headerlink" title="ESlateVisibility"></a>ESlateVisibility</h1><p><code>UE.ESlateVisibility.SelfHitTestInvisible</code> 是 Unreal Engine 中用于控制 UI 控件<strong>可见性与交互性</strong>的一个枚举值。简单来说，它让控件<strong>可见但无法与之交互</strong>（例如点击、悬停），同时<strong>不影响其子控件</strong>的交互性。</p>
<p>下面是一个快速对比表格，帮你了解 <code>ESlateVisibility</code> 的主要枚举值：</p>
<table>
<thead>
<tr>
<th>可见性状态</th>
<th>是否可见</th>
<th>是否占用布局空间</th>
<th>自身是否可交互</th>
<th>子控件是否可交互</th>
</tr>
</thead>
<tbody><tr>
<td>Visible</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>SelfHitTestInvisible</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>HitTestInvisible</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>Hidden</td>
<td>✗</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>Collapsed</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody></table>
<h3 id="💡-关键细节"><a href="#💡-关键细节" class="headerlink" title="💡 关键细节"></a>💡 关键细节</h3><ul>
<li><strong>“不响应事件”</strong>：指的是鼠标点击、触摸、悬停等用户输入事件会<strong>直接穿透</strong>该控件，被其下方或后方的其他控件接收<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,4</a>。</li>
<li><strong>“不影响子控件”</strong>：这是 <code>SelfHitTestInvisible</code> 和 <code>HitTestInvisible</code> 的主要区别。如果父控件设置为 <code>HitTestInvisible</code>，则其所有子控件也会变得不可交互。而 <code>SelfHitTestInvisible</code> 仅禁用控件自身的交互，子控件保持原有的交互状态<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,6,7</a>。</li>
</ul>
<h3 id="🛠-使用方法"><a href="#🛠-使用方法" class="headerlink" title="🛠 使用方法"></a>🛠 使用方法</h3><p><strong>在蓝图中</strong>： 在控件细节面板的 “Appearance” 部分，直接找到 “Visibility” 下拉菜单选择即可。</p>
<p><strong>在 C++ 中</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 假设 YourWidget 是某个控件指针</span><br><span class="line">YourWidget-&gt;SetVisibility(ESlateVisibility::SelfHitTestInvisible);</span><br></pre></td></tr></table></figure>

<p><strong>在 UnLua 中</strong>（如果项目使用了Lua绑定）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local visibleType = UE.ESlateVisibility.SelfHitTestInvisible</span><br><span class="line">self.YourWidget:SetVisibility(visibleType)</span><br></pre></td></tr></table></figure>

<p>（用法参考了 <code>Visible</code> 和 <code>Hidden</code> 的设定 <a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1</a>）</p>
<h3 id="🧩-主要应用场景"><a href="#🧩-主要应用场景" class="headerlink" title="🧩 主要应用场景"></a>🧩 主要应用场景</h3><ul>
<li><strong>装饰性UI元素</strong>：显示一些无需交互的图片、背景、装饰图案等。</li>
<li><strong>视觉遮罩或提示</strong>：需要半透明遮罩层来提示用户某个区域，但又不想阻挡用户与下层UI的交互。</li>
<li><strong>禁用状态视觉表现</strong>：有时希望控件在禁用时不仅变灰，而且鼠标事件能穿透它，可能会用到此选项。</li>
</ul>
<h3 id="💎-实用建议"><a href="#💎-实用建议" class="headerlink" title="💎 实用建议"></a>💎 实用建议</h3><ol>
<li><strong>与</strong> <strong><code>HitTestInvisible</code></strong> <strong>区分</strong>：关键在于你<strong>是否希望子控件可交互</strong>。如果需要子控件交互，用 <code>SelfHitTestInvisible</code>；如果希望父子控件都不可交互，用 <code>HitTestInvisible</code>。</li>
<li><strong>和</strong> <strong><code>Hidden</code><strong><strong>/</strong></strong><code>Collapsed</code></strong> <strong>区分</strong>：<code>Hidden</code> 和 <code>Collapsed</code> 是<strong>完全不可见</strong>的<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,4</a>。如果你的控件需要<strong>可见</strong>但<strong>不拦截输入</strong>，就应选择 <code>SelfHitTestInvisible</code> 或 <code>HitTestInvisible</code>。</li>
<li><strong>事件穿透的另一种方法</strong>：有时为了实现更复杂的点击事件穿透（例如，仅让按钮的透明部分穿透点击），除了设置 <code>SelfHitTestInvisible</code>，还可能需配合调整<strong>点击检测（Hit Test）</strong> 的相关设置或使用透明材质<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">8</a>。</li>
</ol>
<p>希望这些信息能帮助你更好地理解和使用 <code>ESlateVisibility.SelfHitTestInvisible</code>。</p>
<p>10.13</p>
<h1 id="BVM"><a href="#BVM" class="headerlink" title="BVM"></a>BVM</h1><p>蓝图虚拟机</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54174686">https://zhuanlan.zhihu.com/p/54174686</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/688017291">https://zhuanlan.zhihu.com/p/688017291</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Evaluatable expression item types.</span></span><br><span class="line"><span class="comment">// 可评估表达式项类型枚举，用于标识脚本代码中不同类型的操作和常量[6](@ref)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EExprToken</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 变量与上下文操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Variable references.</span></span><br><span class="line">    EX_LocalVariable        = <span class="number">0x00</span>,    <span class="comment">// 访问局部变量（函数内定义的变量）</span></span><br><span class="line">    EX_InstanceVariable     = <span class="number">0x01</span>,    <span class="comment">// 访问对象实例变量（类的成员变量）</span></span><br><span class="line">    EX_DefaultVariable      = <span class="number">0x02</span>,    <span class="comment">// 访问类上下文中的默认变量</span></span><br><span class="line">    <span class="comment">//                      = 0x03,    // 保留值，未使用</span></span><br><span class="line">    EX_Return               = <span class="number">0x04</span>,    <span class="comment">// 从函数返回操作</span></span><br><span class="line">    <span class="comment">//                      = 0x05,    // 保留值，未使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 流程控制操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_Jump                 = <span class="number">0x06</span>,    <span class="comment">// 无条件跳转到代码中的本地地址</span></span><br><span class="line">    EX_JumpIfNot            = <span class="number">0x07</span>,    <span class="comment">// 条件跳转（当表达式为false时跳转）</span></span><br><span class="line">    <span class="comment">//                      = 0x08,    // 保留值，未使用</span></span><br><span class="line">    EX_Assert               = <span class="number">0x09</span>,    <span class="comment">// 断言检查，用于调试和验证条件</span></span><br><span class="line">    <span class="comment">//                      = 0x0A,    // 保留值，未使用</span></span><br><span class="line">    EX_Nothing              = <span class="number">0x0B</span>,    <span class="comment">// 空操作（无操作指令）</span></span><br><span class="line">    <span class="comment">//                      = 0x0C,    // 保留值，未使用</span></span><br><span class="line">    <span class="comment">//                      = 0x0D,    // 保留值，未使用</span></span><br><span class="line">    <span class="comment">//                      = 0x0E,    // 保留值，未使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 赋值操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_Let                  = <span class="number">0x0F</span>,    <span class="comment">// 为变量赋值（任意大小的值）</span></span><br><span class="line">    <span class="comment">//                      = 0x10,    // 保留值，未使用</span></span><br><span class="line">    <span class="comment">//                      = 0x11,    // 保留值，未使用</span></span><br><span class="line">    EX_ClassContext         = <span class="number">0x12</span>,    <span class="comment">// 类默认对象上下文</span></span><br><span class="line">    EX_MetaCast             = <span class="number">0x13</span>,    <span class="comment">// 元类转换操作</span></span><br><span class="line">    EX_LetBool              = <span class="number">0x14</span>,    <span class="comment">// 为布尔变量赋值</span></span><br><span class="line">    EX_LetObj               = <span class="number">0x5F</span>,    <span class="comment">// 为对象引用指针赋值</span></span><br><span class="line">    EX_LetWeakObjPtr        = <span class="number">0x60</span>,    <span class="comment">// 为弱对象指针赋值</span></span><br><span class="line">    EX_LetValueOnPersistentFrame = <span class="number">0x64</span>, <span class="comment">// 在持久帧上赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 函数调用相关</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_EndParmValue         = <span class="number">0x15</span>,    <span class="comment">// 可选函数参数默认值的结束标记</span></span><br><span class="line">    EX_EndFunctionParms     = <span class="number">0x16</span>,    <span class="comment">// 函数调用参数结束标记</span></span><br><span class="line">    EX_Self                 = <span class="number">0x17</span>,    <span class="comment">// 获取当前对象自身（this/self指针）</span></span><br><span class="line">    EX_Context              = <span class="number">0x19</span>,    <span class="comment">// 通过对象上下文调用函数</span></span><br><span class="line">    EX_Context_FailSilent   = <span class="number">0x1A</span>,    <span class="comment">// 通过对象上下文调用函数（上下文为NULL时可静默失败）</span></span><br><span class="line">    EX_VirtualFunction      = <span class="number">0x1B</span>,    <span class="comment">// 虚函数调用（带参数）</span></span><br><span class="line">    EX_FinalFunction        = <span class="number">0x1C</span>,    <span class="comment">// 预绑定函数调用（带参数）</span></span><br><span class="line">    EX_CallMath             = <span class="number">0x68</span>,    <span class="comment">// 调用本地调用空间中的静态纯函数</span></span><br><span class="line">    EX_InterfaceContext     = <span class="number">0x51</span>,    <span class="comment">// 通过本地接口变量调用函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 常量值</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_IntConst             = <span class="number">0x1D</span>,    <span class="comment">// 整型常量</span></span><br><span class="line">    EX_FloatConst           = <span class="number">0x1E</span>,    <span class="comment">// 浮点数常量</span></span><br><span class="line">    EX_StringConst          = <span class="number">0x1F</span>,    <span class="comment">// 字符串常量</span></span><br><span class="line">    EX_ObjectConst          = <span class="number">0x20</span>,    <span class="comment">// 对象常量</span></span><br><span class="line">    EX_NameConst            = <span class="number">0x21</span>,    <span class="comment">// 名称常量</span></span><br><span class="line">    EX_RotationConst        = <span class="number">0x22</span>,    <span class="comment">// 旋转常量</span></span><br><span class="line">    EX_VectorConst          = <span class="number">0x23</span>,    <span class="comment">// 向量常量</span></span><br><span class="line">    EX_ByteConst            = <span class="number">0x24</span>,    <span class="comment">// 字节常量</span></span><br><span class="line">    EX_IntZero              = <span class="number">0x25</span>,    <span class="comment">// 整型零值（优化用）</span></span><br><span class="line">    EX_IntOne               = <span class="number">0x26</span>,    <span class="comment">// 整型一值（优化用）</span></span><br><span class="line">    EX_True                 = <span class="number">0x27</span>,    <span class="comment">// 布尔真值（true）</span></span><br><span class="line">    EX_False                = <span class="number">0x28</span>,    <span class="comment">// 布尔假值（false）</span></span><br><span class="line">    EX_TextConst            = <span class="number">0x29</span>,    <span class="comment">// FText常量（本地化文本）</span></span><br><span class="line">    EX_NoObject             = <span class="number">0x2A</span>,    <span class="comment">// 空对象引用</span></span><br><span class="line">    EX_TransformConst       = <span class="number">0x2B</span>,    <span class="comment">// 变换常量</span></span><br><span class="line">    EX_IntConstByte         = <span class="number">0x2C</span>,    <span class="comment">// 单字节整型常量（优化存储）</span></span><br><span class="line">    EX_NoInterface          = <span class="number">0x2D</span>,    <span class="comment">// 空接口引用（类似于EX_NoObject，但用于接口）</span></span><br><span class="line">    EX_UnicodeStringConst   = <span class="number">0x34</span>,    <span class="comment">// Unicode字符串常量</span></span><br><span class="line">    EX_Int64Const           = <span class="number">0x35</span>,    <span class="comment">// 64位整型常量</span></span><br><span class="line">    EX_UInt64Const          = <span class="number">0x36</span>,    <span class="comment">// 64位无符号整型常量</span></span><br><span class="line">    EX_AssetConst           = <span class="number">0x67</span>,    <span class="comment">// 资源常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 类型转换操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_DynamicCast          = <span class="number">0x2E</span>,    <span class="comment">// 安全的动态类转换</span></span><br><span class="line">    EX_PrimitiveCast        = <span class="number">0x38</span>,    <span class="comment">// 基本类型转换操作符</span></span><br><span class="line">    EX_ObjToInterfaceCast   = <span class="number">0x52</span>,    <span class="comment">// 对象引用到本地接口变量的转换</span></span><br><span class="line">    EX_CrossInterfaceCast   = <span class="number">0x54</span>,    <span class="comment">// 接口变量引用到本地接口变量的转换</span></span><br><span class="line">    EX_InterfaceToObjCast   = <span class="number">0x55</span>,    <span class="comment">// 接口变量引用到对象的转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 结构体和数组操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_StructConst          = <span class="number">0x2F</span>,    <span class="comment">// 任意UStruct常量</span></span><br><span class="line">    EX_EndStructConst       = <span class="number">0x30</span>,    <span class="comment">// UStruct常量结束标记</span></span><br><span class="line">    EX_SetArray             = <span class="number">0x31</span>,    <span class="comment">// 设置任意数组的值</span></span><br><span class="line">    EX_EndArray             = <span class="number">0x32</span>,    <span class="comment">// 数组结束标记</span></span><br><span class="line">    EX_StructMemberContext  = <span class="number">0x42</span>,    <span class="comment">// 用于访问结构体内属性的上下文表达式</span></span><br><span class="line">    EX_ArrayConst           = <span class="number">0x65</span>,    <span class="comment">// 数组常量</span></span><br><span class="line">    EX_EndArrayConst        = <span class="number">0x66</span>,    <span class="comment">// 数组常量结束标记</span></span><br><span class="line">    EX_ArrayGetByRef        = <span class="number">0x6B</span>,    <span class="comment">// 通过引用获取数组元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 委托操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_LetMulticastDelegate = <span class="number">0x43</span>,    <span class="comment">// 为多播委托赋值</span></span><br><span class="line">    EX_LetDelegate          = <span class="number">0x44</span>,    <span class="comment">// 为委托赋值</span></span><br><span class="line">    EX_InstanceDelegate     = <span class="number">0x4B</span>,    <span class="comment">// 对委托或普通函数对象的常量引用</span></span><br><span class="line">    EX_AddMulticastDelegate = <span class="number">0x5C</span>,    <span class="comment">// 向多播委托的目标中添加委托</span></span><br><span class="line">    EX_ClearMulticastDelegate = <span class="number">0x5D</span>, <span class="comment">// 清除多播目标中的所有委托</span></span><br><span class="line">    EX_BindDelegate         = <span class="number">0x61</span>,    <span class="comment">// 将对象和名称绑定到委托</span></span><br><span class="line">    EX_RemoveMulticastDelegate = <span class="number">0x62</span>, <span class="comment">// 从多播委托的目标中移除委托</span></span><br><span class="line">    EX_CallMulticastDelegate = <span class="number">0x63</span>,   <span class="comment">// 调用多播委托</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 高级流程控制</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_Skip                 = <span class="number">0x18</span>,    <span class="comment">// 可跳过表达式（条件执行）</span></span><br><span class="line">    EX_PushExecutionFlow    = <span class="number">0x4C</span>,    <span class="comment">// 将地址推送到执行流栈供后续执行</span></span><br><span class="line">    EX_PopExecutionFlow     = <span class="number">0x4D</span>,    <span class="comment">// 继续执行之前推送到执行流栈的最后一个地址</span></span><br><span class="line">    EX_ComputedJump         = <span class="number">0x4E</span>,    <span class="comment">// 计算跳转（由整数值指定代码中的本地地址）</span></span><br><span class="line">    EX_PopExecutionFlowIfNot = <span class="number">0x4F</span>,   <span class="comment">// 条件执行流弹出（条件不成立时执行）</span></span><br><span class="line">    EX_SwitchValue          = <span class="number">0x69</span>,    <span class="comment">// 开关值（多分支选择）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 调试和诊断</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_Breakpoint           = <span class="number">0x50</span>,    <span class="comment">// 断点（仅在编辑器中有效，否则行为类似EX_Nothing）</span></span><br><span class="line">    EX_WireTracepoint       = <span class="number">0x5A</span>,    <span class="comment">// 跟踪点（仅在编辑器中有效）</span></span><br><span class="line">    EX_Tracepoint           = <span class="number">0x5E</span>,    <span class="comment">// 跟踪点（仅在编辑器中有效）</span></span><br><span class="line">    EX_InstrumentationEvent = <span class="number">0x6A</span>,    <span class="comment">// 插装事件（用于性能分析）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">    <span class="comment">// ============================================================================</span></span><br><span class="line">    </span><br><span class="line">    EX_SkipOffsetConst      = <span class="number">0x5B</span>,    <span class="comment">// 代码跳转偏移常量</span></span><br><span class="line">    EX_EndOfScript          = <span class="number">0x53</span>,    <span class="comment">// 脚本代码的最后一个字节</span></span><br><span class="line">    EX_DeprecatedOp4A       = <span class="number">0x4A</span>,    <span class="comment">// 已弃用的操作（保留用于向后兼容）</span></span><br><span class="line">    </span><br><span class="line">    EX_Max                  = <span class="number">0x100</span>,   <span class="comment">// 枚举最大值（用于边界检查）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>UE4/UE5 的蓝图虚拟机（Blueprint Virtual Machine）是一个设计精巧的系统，它将可视化的节点图转化为可执行的游戏逻辑。其核心在于 <strong>将蓝图节点编译成字节码（Bytecode），然后通过一个轻量级的解释器（即虚拟机）来逐条执行这些指令</strong>。</p>
<p>为了帮助你快速构建起对蓝图虚拟机工作流程的整体认知，可以参考下面的这张核心流程图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[蓝图节点图&lt;br&gt;（UEdGraph）] --&gt; B[编译&lt;br&gt;（Compilation）]</span><br><span class="line">    </span><br><span class="line">    subgraph B [编译阶段]</span><br><span class="line">        B1[节点展开与优化] --&gt; B2[生成中间表示&lt;br&gt;（FBlueprintCompiledStatement）] --&gt; B3[生成字节码&lt;br&gt;（EExprToken 序列）]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    B --&gt; C[字节码存储&lt;br&gt;（UFunction::Script）]</span><br><span class="line">    C --&gt; D[运行时执行]</span><br><span class="line">    </span><br><span class="line">    subgraph D [虚拟机执行核心]</span><br><span class="line">        D1[创建栈帧（FFrame）] --&gt; D2[循环读取字节码] --&gt; D3[查找GNatives函数指针] --&gt; D4[执行原生函数]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    D4 --&gt; E[逻辑执行结果]</span><br></pre></td></tr></table></figure>

<h3 id="🔁-从节点到字节码：编译过程"><a href="#🔁-从节点到字节码：编译过程" class="headerlink" title="🔁 从节点到字节码：编译过程"></a>🔁 从节点到字节码：编译过程</h3><p>蓝图虚拟机执行的第一步，是将可视化的节点图转换为它能够理解的指令序列。</p>
<ol>
<li><strong>节点图处理与优化</strong>：编译器（主要由 <code>FKismetCompilerContext</code>驱动）首先会对节点图进行分析和优化。这包括将宏等复合节点<strong>展开</strong>成基础节点，并通过<strong>依赖分析</strong>移除未被任何事件节点连接的“死代码”。</li>
<li><strong>生成中间表示</strong>：处理后的节点图不会被直接翻译成字节码，而是先被转换成一种线性的<strong>中间表示</strong>——<code>FBlueprintCompiledStatement</code>列表。这个列表可以看作是一种平台无关的“汇编指令”，它清晰地描述了操作的顺序和逻辑，为后续的优化和代码生成奠定了基础。值得一提的是，蓝图编译器跳过了传统编译器构建抽象语法树（AST）的步骤，因为节点图本身就已经是一种结构化的、可视化的程序表示。</li>
<li><strong>字节码生成</strong>：最后，一个称为“VM后端”（<code>FKismetCompilerVMBackend</code>）的组件会遍历中间表示列表，为每一条语句<strong>生成</strong>对应的虚拟机字节码。这些字节码是 <code>EExprToken</code>枚举中定义的数字指令，例如 <code>EX_CallMath</code>表示调用一个数学函数。生成的字节码会存储在 <code>UFunction</code>对象的 <code>Script</code>数组成员中。</li>
</ol>
<h3 id="⚙️-运行时核心：虚拟机如何执行字节码"><a href="#⚙️-运行时核心：虚拟机如何执行字节码" class="headerlink" title="⚙️ 运行时核心：虚拟机如何执行字节码"></a>⚙️ 运行时核心：虚拟机如何执行字节码</h3><p>当游戏运行时（例如，一个 <code>Event BeginPlay</code>被触发），虚拟机的执行引擎便开始工作。</p>
<ol>
<li><strong>创建栈帧</strong>：执行一个蓝图函数，首先会创建一个栈帧（<code>FFrame</code>）。这个栈帧是执行上下文的核心，它包含了执行所需的所有关键信息：<ol>
<li><code>UObject* Object</code>: 执行此函数的对象实例（即 <code>this</code>指针）。</li>
<li><code>UFunction* Node</code>: 当前正在执行的函数对象。</li>
<li><code>uint8* Code</code>: 指向当前要执行的字节码的指针（相当于程序计数器PC）。</li>
<li><code>uint8* Locals</code>: 指向该函数局部变量内存块的指针。</li>
<li><code>FFrame* PreviousFrame</code>: 指向上一个栈帧的指针，用于维护调用栈。</li>
</ol>
</li>
<li><strong>指令分派与执行</strong>：执行引擎通过一个循环不断地读取并执行字节码。核心的步进函数是 <code>FFrame::Step()</code>。它的工作流程非常简单高效：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FFrame::Step(UObject* Context, RESULT_DECL) &#123;</span><br><span class="line">    int32 B = *Code++; // 1. 读取当前字节码，并移动Code指针</span><br><span class="line">    (GNatives[B])(Context, *this, RESULT_PARAM); // 2. 查找并执行对应的原生函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>参数与返回值传递</strong>：字节码中不仅包含操作指令，还嵌入了执行所需的数据（如函数参数、常量值）。虚拟机通过 <code>FFrame</code>上的 <code>ReadInt()</code>, <code>ReadFloat()</code>, <code>ReadObject()</code>等方法从 <code>Code</code>流中读取这些数据。函数返回值则通过 <code>RESULT_PARAM</code>指针传递。</li>
</ol>
<h3 id="🔄-蓝图与C-的相互调用"><a href="#🔄-蓝图与C-的相互调用" class="headerlink" title="🔄 蓝图与C++的相互调用"></a>🔄 蓝图与C++的相互调用</h3><p>蓝图虚拟机的强大之处在于它和C++反射系统的无缝集成。</p>
<ul>
<li><strong>C++调用蓝图函数</strong>：当C++代码调用一个蓝图中实现的函数（如 <code>BlueprintImplementableEvent</code>）时，引擎会通过 <code>UObject::ProcessEvent</code>找到对应的 <code>UFunction</code>。如果该函数包含蓝图字节码，就会创建 <code>FFrame</code>并进入上述的虚拟机执行流程。</li>
<li><strong>蓝图调用C++函数</strong>：当蓝图调用一个暴露给蓝图的C++函数（<code>BlueprintCallable</code>）时，对应的字节码（如 <code>EX_FinalFunction</code>）会指向一个由Unreal Header Tool（UHT）自动生成的 <code>execYourFunctionName</code>静态函数。这个函数负责从栈帧（<code>FFrame</code>）中解析出参数，然后调用你编写的C++函数本体。</li>
</ul>
<h3 id="💎-总结与特点"><a href="#💎-总结与特点" class="headerlink" title="💎 总结与特点"></a>💎 总结与特点</h3><p>总而言之，UE蓝图虚拟机的实现可以概括为：“<strong>节点图即代码，FFrame为上下文，GNatives是心脏，C++函数为四肢</strong>”。它不是一个独立的、沉重的模块，而是深度构建在UE本身强大的<code>UObject</code>系统（反射、垃圾回收、序列化）之上的一种轻量级、高效的脚本执行环境。</p>
<p>希望这份总结能帮助你透彻地理解蓝图虚拟机的运作机制。如果你对某个特定细节（比如编译优化或异步节点的处理）还想深入了解，我们可以继续探讨。</p>
<h1 id="蓝图底层"><a href="#蓝图底层" class="headerlink" title="蓝图底层"></a>蓝图底层</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/438501014">https://zhuanlan.zhihu.com/p/438501014</a></p>
<h1 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h1><p>委托</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/460092901">https://zhuanlan.zhihu.com/p/460092901</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/575671003">https://zhuanlan.zhihu.com/p/575671003</a></p>
<p><a target="_blank" rel="noopener" href="https://sarosgame.feishu.cn/wiki/MjIXw31PvifbPnkExVAc1TKSnmg">Delegate的一些简单梳理</a></p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><ul>
<li>1.单播委托: TDelegate模板类，通常用<code>DECLARE_DELEGATE</code>及<code>DECLARE_DELEGATE_XXXXParams</code>宏进行声明，后面的宏表示带XXXX个参数</li>
<li>2.多播委托: TMulticastDelegate模板类，通常用<code>DECLARE_MULTICAST_DELEGATE</code>及<code>DECLARE_MULTICAST_DELEGATE_&lt;Num&gt;Params</code>宏进行声明，后面的宏表示带XXXX个参数</li>
<li>3.动态委托: 继承于TBaseDynamicDelegate，TBaseDynamicMulticastDelegate模板类，通常用<code>DECLARE_DYNAMIC_DELEGATE</code>及<code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code>宏进行声明，分别表示单播与多播，另外还有包含参数个数的宏如<code>DECLARE_DYNAMIC_DELEGATE_OneParam</code>，其本质集成了UObject的反射系统，让其可以注册蓝图实现的函数及支持序列化存储到本机，UFunction只需给函数名称及蓝图支持是其最大的特性，概念上并未逃出前两类，性能和功能弱于前两类。</li>
<li>\4. Event: 其继承多播，不单独讨论了</li>
</ul>
<table>
<thead>
<tr>
<th>委托类型</th>
<th>绑定函数数量</th>
<th>返回值支持</th>
<th>序列化/蓝图支持</th>
<th>主要用途</th>
</tr>
</thead>
<tbody><tr>
<td>单播委托</td>
<td>1个</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
<td>一对一回调，需要返回值时使用</td>
</tr>
<tr>
<td>多播委托</td>
<td>多个</td>
<td>❌ 无返回值</td>
<td>❌ 不支持</td>
<td>一对多通知，如普通事件分发</td>
</tr>
<tr>
<td>动态委托</td>
<td>1个或多个</td>
<td>仅动态单播支持</td>
<td>✅ 支持</td>
<td>与蓝图系统交互，支持序列化</td>
</tr>
</tbody></table>
<h2 id="TDelegate"><a href="#TDelegate" class="headerlink" title="TDelegate"></a>TDelegate</h2><p>TDelegate是UE提供的单播委托，声明委托时目前限定了最多可携带9个参数。支持多种可调用对象（普通函数，成员函数，仿函数，lambda等）到声明函数类型进行转换，同时转换的时还支持额外预保存payload参数，类似std:bind一样。TDelegate委托自己没有成员，使用了策略模式继承于基类FDelegateBase。基类FDelegateBase通过new两次重载提供对委托实例的内存分配，并且提供释放及访问方法，这样将委托本体与真正实例解耦开，委托本身不直接保存实例对象，实例由于有多种类型，通过中间层也可以很好的解决了类型擦除与转换的问题，委托本体的size也比较小，只有12字节，由于对齐原因，占16字节。</p>
<p>委托系统的核心是 <code>IDelegateInstance</code>接口。对于每一种可绑定对象（如全局函数、UObject成员函数、Lambda表达式等），都有一个对应的 <code>TBaseXXXDelegateInstance</code>类来实现此接口（例如 <code>TBaseStaticDelegateInstance</code>, <code>TBaseUObjectMethodDelegateInstance</code>）。这就像定义了一套通用的“插座”标准，无论电器是哪种品牌（函数类型），只要插头符合标准就能使用。</p>
<p>当你调用 <code>BindUObject()</code>或 <code>BindStatic()</code>等方法时，委托内部会通过 <strong>Placement new</strong> 在预分配的内存上创建对应的委托实例对象，并将函数指针、对象指针等信息存储起来。</p>
<p>模板类里定义了一系列的创建函数（Create<strong>）和绑定函数（</strong>Bind），用于代理的构造，还实现了执行代理的方法——Execute，用于代理的执行。</p>
<p>CreateDelegateInstance函数：这是TDelegate的父类TBaseDelegate的一个方法。这里面的实现比较巧妙，大概就是通过Allocate函数把扩大自己内部指针的内存，使得自己TBaseDelegate内部能够放下一个T***DelegateInstance，并且对新申请的内存空间进行类型转换</p>
<p><img src="./../../pic/picture/0073-UEBase/1761188735788-1.png" alt="img"></p>
<p>T***DelegateInstance</p>
<p>委托系统通过不同的绑定方式，智能地管理对象生命周期，防止悬空指针：</p>
<ul>
<li><strong><code>BindRaw</code><strong>：直接绑定原始 C++ 对象指针。</strong>最高效也最危险</strong>，如果对象被销毁后调用委托，会导致程序崩溃。使用时需谨慎。</li>
<li><strong><code>BindUObject</code>****/</strong> <strong><code>BindSP</code><strong>：绑定 <code>UObject</code>或智能指针对象。委托内部会持有对象的</strong>弱引用</strong>。在执行时，可以通过 <code>ExecuteIfBound()</code>安全地检查对象是否依然有效，避免访问已销毁的对象。</li>
<li>**<code>BindLambda</code>**：可以安全地捕获上下文。使用 <code>BindWeakLambda</code>时，同样能对捕获的 <code>UObject</code>进行有效性检查。</li>
</ul>
<p>T***DelegateInstance大致有如下几种，代表不同的策略</p>
<p>TBaseUFunctionDelegateInstance，接收UFunction</p>
<p>TBaseSPMethodDelegateInstance，接收共享引用类型的类的成员函数</p>
<p>TBaseRawMethodDelegateInstance，接收普通类型的类的成员函数</p>
<p>TBaseUObjectMethodDelegateInstance，接收UObject类型的类的成员函数</p>
<p>TBaseStaticDelegateInstance，接收普通C++函数或类的静态函数</p>
<p>TBaseFunctorDelegateInstance，接收Lambda函数</p>
<p>TWeakBaseFunctorDelegateInstance，接收类成员Lambda函数</p>
<p>他们有个父类是TCommonDelegateInstanceState</p>
<p>而这个TCommonDelegateInstanceState才是真正保存绑定函数和函数所在类的地方，包括UserObject记录函数所在类的实例、MethodPtr记录绑定函数、Payload记录参数等</p>
<p><img src="./../../pic/picture/0073-UEBase/1761188735788-2.png" alt="img"></p>
<h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a><strong>Payload</strong></h2><p>UE 委托支持 <strong>Payload</strong> 机制，允许你在绑定时就固定一部分参数。当触发委托时，这些预先绑定的 Payload 参数会排在执行时传入的参数之前，一起传递给目标函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 假设有函数：void MyFunc(int RuntimeParam, float PreBoundParam, FString PreBoundString);</span><br><span class="line">DECLARE_DELEGATE_OneParam(FMyDelegate, int32); // 运行时只接受一个int参数</span><br><span class="line"></span><br><span class="line">FMyDelegate Delegate;</span><br><span class="line">// 绑定时传入两个Payload参数：12.0f 和 &quot;Hello&quot;</span><br><span class="line">Delegate.BindStatic(MyFunc, 12.0f, FString(TEXT(&quot;Hello&quot;)));</span><br><span class="line">// 触发时，参数这样传递：MyFunc(100, 12.0f, &quot;Hello&quot;);</span><br><span class="line">Delegate.ExecuteIfBound(100);</span><br></pre></td></tr></table></figure>

<p>Payload 数据通常使用 <code>TTuple</code>进行存储，并在调用时通过模板技巧展开。<strong>需要注意的是，动态委托不支持 Payload 功能</strong>。</p>
<h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><p>多播代理是一个单独的类型TMulticastDelegate，父类是TMulticastDelegateBase，其实非常简单，里面有一个单播代理的数组InvocationList</p>
<p>同样Bind变成了Add</p>
<p>每次Add一个单播代理对象，会加到数组的最后</p>
<p>在Broadca实际上是以倒序方式依次ExecuteIfSafe每一个单播代理</p>
<h2 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h2><ul>
<li><strong>性能考量</strong>：委托调用涉及虚函数表查找等开销，应避免在性能敏感的循环中频繁调用。</li>
<li><strong>生命周期管理</strong>：务必注意绑定对象的作用域。优先使用 <code>BindUObject</code>和 <code>BindSP</code>等能提供弱引用检查的方式，并在可能的情况下使用 <code>ExecuteIfBound()</code>。</li>
<li><strong>动态委托的代价</strong>：动态委托因为支持序列化和蓝图，其性能通常低于静态和多播委托。</li>
</ul>
<p>希望这份详细的解释能帮助你更好地理解和使用 UE 的委托系统。如果你对某个具体的绑定方式或使用场景有更进一步的疑问，我很乐意继续探讨。</p>
<h1 id="Lyra"><a href="#Lyra" class="headerlink" title="Lyra"></a>Lyra</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shuanger_/article/details/136324453">https://blog.csdn.net/shuanger_/article/details/136324453</a></p>
<h1 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650581265">https://zhuanlan.zhihu.com/p/650581265</a></p>
<p>在虚幻引擎 (Unreal Engine) 中，<strong>Flush（刷新）机制</strong>是一套用于<strong>协调异步操作、确保数据一致性</strong>的核心设计模式。它广泛存在于引擎的各个子系统，其核心思想是：<strong>让一个线程（通常是游戏线程）等待另一个线程（如渲染线程、加载线程）完成特定的异步任务，然后再继续执行，从而避免因数据不同步而导致的错误或卡顿</strong>。</p>
<p>为了让你快速了解其应用场景，下表总结了 Flush 机制在不同系统中的核心作用：</p>
<table>
<thead>
<tr>
<th>系统领域</th>
<th>核心 Flush 操作</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>网络与回放</td>
<td>FlushNetDormancy</td>
<td>唤醒处于休眠状态的 Actor，强制其立即进行一次网络更新，确保客户端状态同步。</td>
</tr>
<tr>
<td>资源与对象管理</td>
<td>异步加载 Flush (如 SetActorLabel触发)</td>
<td>在编辑器下，强制完成所有正在进行的异步资源加载，可能导致卡顿。</td>
</tr>
<tr>
<td>媒体播放</td>
<td>FlushSinks/ Flush</td>
<td>在视频跳转时清空解码器内部缓存，确保从新位置开始解码，可能引起短暂卡顿。</td>
</tr>
<tr>
<td>渲染与实例更新</td>
<td>FlushInstanceUpdateCommands</td>
<td>等待渲染线程完成实例化网格（如 ISMC）的数据更新，确保游戏线程后续操作基于最新数据。</td>
</tr>
</tbody></table>
<h3 id="💡-深入理解-Flush-的工作机制"><a href="#💡-深入理解-Flush-的工作机制" class="headerlink" title="💡 深入理解 Flush 的工作机制"></a>💡 深入理解 Flush 的工作机制</h3><p>Flush 机制通常基于 <strong>“请求-响应”模式</strong>。你可以将其理解为一个<strong>线程间的同步令牌</strong>。</p>
<ol>
<li><strong>请求发起</strong>：当游戏线程需要确保某个异步操作（如渲染数据更新）完成时，会创建一个 <strong><code>FFlushRequest</code></strong> 类的实例。这个实例内部包含一个标志（如布尔值 <code>bCompleted</code>）和一个同步事件（<code>FEvent</code>）。</li>
<li><strong>状态标记</strong>：游戏线程将该请求发送给异步工作线程（如渲染线程），然后可以选择等待。工作线程处理完任务后，会调用请求的 <strong><code>MarkCompleted()</code></strong> 方法，原子性地标记该请求已完成。</li>
<li><strong>等待与继续</strong>：游戏线程通过调用 <strong><code>WaitForCompletion()</code></strong> 方法阻塞自身，直到检测到请求被标记为完成。这确保了在刷新点之后，所有必要的数据都已准备就绪。</li>
</ol>
<p>由于其阻塞特性，不合理地使用 Flush 会带来性能问题。例如，在视频播放器中，每一帧都调用 Flush 来清空样本接收器（<code>FlushSinks</code>）可能会带来不必要的性能开销。</p>
<h3 id="🛠️-实践中的注意事项与优化策略"><a href="#🛠️-实践中的注意事项与优化策略" class="headerlink" title="🛠️ 实践中的注意事项与优化策略"></a>🛠️ 实践中的注意事项与优化策略</h3><ul>
<li><strong>性能权衡</strong>：Flush 是<strong>阻塞操作</strong>。频繁调用或在关键性能路径上不当使用，会迫使游戏线程空闲等待，导致帧率下降或卡顿。因此，要避免在每帧或紧密循环中调用。</li>
<li><strong>网络休眠中的谨慎使用</strong>：对于设置为 <code>DORM_DormantAll</code>的 Actor，在修改其同步属性<strong>之前</strong>调用 <code>FlushNetDormancy</code>是最佳实践。如果修改后才调用，在某些复杂情况下（如修改休眠中的 FastArray），更改可能无法正确同步。</li>
<li><strong>编辑器与运行时差异</strong>：在编辑器模式下，一些操作（如 <code>SetActorLabel</code>）会触发异步加载的 Flush，这可能在 PIE 模式下是不必要的，从而引起卡顿。在打包后的游戏中，这类开销通常不存在。</li>
<li><strong>替代方案</strong>：在设计系统时，可以考虑使用<strong>事件驱动</strong>或<strong>回调函数</strong>等非阻塞方式来进行线程间通知，减少对强制刷新（Flush）的依赖。</li>
</ul>
<h3 id="💎-总结-1"><a href="#💎-总结-1" class="headerlink" title="💎 总结"></a>💎 总结</h3><p>总而言之，Flush 机制是虚幻引擎保障多线程数据安全的基石之一。理解它的原理和应用场景，能帮助你有意识地避免性能陷阱，并正确地在需要确保数据一致性的关键时刻使用它。</p>
<p>希望这些信息能帮助你更好地理解虚幻引擎中的 Flush 机制。如果你有特定的应用场景想深入了解，我们可以继续探讨。</p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><p>欧拉角:</p>
<ul>
<li><p>FRotator：</p>
<ul>
<li><p>pitch()：俯仰，将物体绕X轴旋转（localRotationX）</p>
</li>
<li><p>yaw()：航向，将物体绕Y轴旋转（localRotationY）</p>
</li>
<li><p>roll()：横滚，将物体绕Z轴旋转（localRotationZ）</p>
</li>
</ul>
</li>
</ul>
<p>UE底层能把欧拉角转换为四元数 以免万向节</p>
<p>UE默认旋转顺序为 <strong>Yaw → Pitch → Roll</strong></p>
<p>四元数封装在 **<code>FQuat</code>**中</p>
<ul>
<li><code>FQuat::Slerp()</code>：球面插值（平滑角速度）。</li>
<li><code>FQuat::FastLerp()</code>：快速线性插值（性能优化，轻微精度损失）</li>
</ul>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>actor与uobject的关系 gc 委托有哪些种类 蓝图通信方式 UE有哪些线程 自定义事件与函数的区别 GAS c++的类型转换 静态多态和动态多态 虚继承 右值引用和移动语义 用过哪些脚本语言 大世界流式关卡加载有卡顿怎么解决 同一范围内有大量行为树运行如何优化 游戏内存溢出如何解决</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fragmentary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/03/0073-UEBase/">http://example.com/2025/08/03/0073-UEBase/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">零の領域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ue/">ue</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/04/0074-UELyra/" title="UE Lyra"><img class="cover" src="/img/bg/default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UE Lyra</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/27/0072-UEAPI/" title="UE常见API"><img class="cover" src="/img/bg/default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UE常见API</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/11/10/0085-UeGasUse/" title="ue GAS(持续更新)"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-10</div><div class="title">ue GAS(持续更新)</div></div></a></div><div><a href="/2025/11/07/0084-UeAdapt/" title="UE 适配与多分辨率"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-07</div><div class="title">UE 适配与多分辨率</div></div></a></div><div><a href="/2025/11/06/0083-UeSlate/" title="ue Slate初探"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-06</div><div class="title">ue Slate初探</div></div></a></div><div><a href="/2025/10/13/0081-UeAync/" title="ue 多线程"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-13</div><div class="title">ue 多线程</div></div></a></div><div><a href="/2025/10/11/0082-UeIA/" title="ue 增强输入"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-11</div><div class="title">ue 增强输入</div></div></a></div><div><a href="/2025/09/11/0080-UeGC/" title="ue gc"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="title">ue gc</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg/pixiv_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fragmentary</div><div class="author-info__description">一个摸鱼人的日常博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fragmentary1002"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Fragmentary1002" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://space.bilibili.com/165064718?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fa-solid fa-tv"></i></a><a class="social-icon" href="https://www.youtube.com/@mentaryFrag" target="_blank" title="youtube"><i class="fa-brands fa-youtube"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是一个博客~ 好吧这是我的学习笔记 一个Unity客户端开发者的日常</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FSoftObjectPath"><span class="toc-number">2.</span> <span class="toc-text">FSoftObjectPath</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%80%E3%80%81FSoftObjectPath-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.1.</span> <span class="toc-text">🔍 一、FSoftObjectPath 核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95"><span class="toc-number">2.0.2.</span> <span class="toc-text">⚙️ 二、代码实现与用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%8E%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">1. 声明与编辑器配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">2. 资源加载方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">3. 动态设置路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%96%EF%B8%8F-%E4%B8%89%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8-vs-%E7%A1%AC%E5%BC%95%E7%94%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text">⚖️ 三、软引用 vs. 硬引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%9B%9B%E3%80%81%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.0.4.</span> <span class="toc-text">💡 四、实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">2.0.5.</span> <span class="toc-text">⚠️ 五、常见问题与优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93"><span class="toc-number">2.0.6.</span> <span class="toc-text">💎 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">Actor生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AD-%E6%80%BB%E8%A7%88%EF%BC%9AActor-%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%94%9F%E6%88%90%E8%B7%AF%E5%BE%84"><span class="toc-number">3.0.1.</span> <span class="toc-text">🧭 总览：Actor 的四种主要生成路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9B%94-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%BB%93%E6%9D%9F-End-of-Life"><span class="toc-number">3.0.2.</span> <span class="toc-text">⛔ 生命周期的结束 (End of Life)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.0.3.</span> <span class="toc-text">💎 总结与建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESlateVisibility"><span class="toc-number">4.</span> <span class="toc-text">ESlateVisibility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%85%B3%E9%94%AE%E7%BB%86%E8%8A%82"><span class="toc-number">4.0.1.</span> <span class="toc-text">💡 关键细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A0-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.2.</span> <span class="toc-text">🛠 使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.0.3.</span> <span class="toc-text">🧩 主要应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%8E-%E5%AE%9E%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">4.0.4.</span> <span class="toc-text">💎 实用建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BVM"><span class="toc-number">5.</span> <span class="toc-text">BVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E4%BB%8E%E8%8A%82%E7%82%B9%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9A%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">🔁 从节点到字节码：编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%B8%E5%BF%83%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">5.0.2.</span> <span class="toc-text">⚙️ 运行时核心：虚拟机如何执行字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-%E8%93%9D%E5%9B%BE%E4%B8%8EC-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8"><span class="toc-number">5.0.3.</span> <span class="toc-text">🔄 蓝图与C++的相互调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">5.0.4.</span> <span class="toc-text">💎 总结与特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">蓝图底层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Delegate"><span class="toc-number">7.</span> <span class="toc-text">Delegate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TDelegate"><span class="toc-number">7.2.</span> <span class="toc-text">TDelegate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Payload"><span class="toc-number">7.3.</span> <span class="toc-text">Payload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD"><span class="toc-number">7.4.</span> <span class="toc-text">多播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.5.</span> <span class="toc-text">关键注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lyra"><span class="toc-number">8.</span> <span class="toc-text">Lyra</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flush"><span class="toc-number">9.</span> <span class="toc-text">Flush</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Flush-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">9.0.1.</span> <span class="toc-text">💡 深入理解 Flush 的工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">9.0.2.</span> <span class="toc-text">🛠️ 实践中的注意事项与优化策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%8E-%E6%80%BB%E7%BB%93-1"><span class="toc-number">9.0.3.</span> <span class="toc-text">💎 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">10.</span> <span class="toc-text">数学</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QA"><span class="toc-number">11.</span> <span class="toc-text">QA</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/10/0085-UeGasUse/" title="ue GAS(持续更新)"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue GAS(持续更新)"/></a><div class="content"><a class="title" href="/2025/11/10/0085-UeGasUse/" title="ue GAS(持续更新)">ue GAS(持续更新)</a><time datetime="2025-11-09T16:00:00.000Z" title="发表于 2025-11-10 00:00:00">2025-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/07/0084-UeAdapt/" title="UE 适配与多分辨率"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE 适配与多分辨率"/></a><div class="content"><a class="title" href="/2025/11/07/0084-UeAdapt/" title="UE 适配与多分辨率">UE 适配与多分辨率</a><time datetime="2025-11-06T16:00:00.000Z" title="发表于 2025-11-07 00:00:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/06/0083-UeSlate/" title="ue Slate初探"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue Slate初探"/></a><div class="content"><a class="title" href="/2025/11/06/0083-UeSlate/" title="ue Slate初探">ue Slate初探</a><time datetime="2025-11-05T16:00:00.000Z" title="发表于 2025-11-06 00:00:00">2025-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/23/0000-UeAlsUse/" title="ue Als 使用(占坑)"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue Als 使用(占坑)"/></a><div class="content"><a class="title" href="/2025/10/23/0000-UeAlsUse/" title="ue Als 使用(占坑)">ue Als 使用(占坑)</a><time datetime="2025-10-22T16:00:00.000Z" title="发表于 2025-10-23 00:00:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/13/0081-UeAync/" title="ue 多线程"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue 多线程"/></a><div class="content"><a class="title" href="/2025/10/13/0081-UeAync/" title="ue 多线程">ue 多线程</a><time datetime="2025-10-12T16:00:00.000Z" title="发表于 2025-10-13 00:00:00">2025-10-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Fragmentary</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>