<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>UObject | 零の領域</title><meta name="author" content="Fragmentary"><meta name="copyright" content="Fragmentary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本篇为对于大钊老师以及网上资料的对于Uobject 相关的反射底层实现与源码阅读。 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;22813908?refer&#x3D;insideue4 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1bH4y1k7Wg&#x2F;?spm_id_from&#x3D;333.1391.0.0&amp;vd_source&#x3D;d19e47552f1614194f">
<meta property="og:type" content="article">
<meta property="og:title" content="UObject">
<meta property="og:url" content="http://example.com/2025/08/27/0077-UeUObject/index.html">
<meta property="og:site_name" content="零の領域">
<meta property="og:description" content="前言本篇为对于大钊老师以及网上资料的对于Uobject 相关的反射底层实现与源码阅读。 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;22813908?refer&#x3D;insideue4 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1bH4y1k7Wg&#x2F;?spm_id_from&#x3D;333.1391.0.0&amp;vd_source&#x3D;d19e47552f1614194f">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bg/default_cover.png">
<meta property="article:published_time" content="2025-08-26T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-12T16:48:39.963Z">
<meta property="article:author" content="Fragmentary">
<meta property="article:tag" content="ue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/bg/default_cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/08/27/0077-UeUObject/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UObject',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-13 00:48:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg/pixiv_cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg/default_cover.png')"><nav id="nav"><span id="blog-info"><a href="/" title="零の領域"><span class="site-name">零の領域</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UObject</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-26T16:00:00.000Z" title="发表于 2025-08-27 00:00:00">2025-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-12T16:48:39.963Z" title="更新于 2025-11-13 00:48:39">2025-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ue/">ue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UObject"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇为对于大钊老师以及网上资料的对于Uobject 相关的反射底层实现与源码阅读。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22813908?refer=insideue4">https://zhuanlan.zhihu.com/p/22813908?refer=insideue4</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bH4y1k7Wg/?spm_id_from=333.1391.0.0&amp;vd_source=d19e47552f1614194f0d0b0662850083">https://www.bilibili.com/video/BV1bH4y1k7Wg/?spm_id_from=333.1391.0.0&amp;vd_source=d19e47552f1614194f0d0b0662850083</a></p>
<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24319968">https://zhuanlan.zhihu.com/p/24319968</a></p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-27.png" alt="img"></p>
<p>藉着UObject提供的元数据、反射生成、GC垃圾回收、序列化、编辑器可见、Class Default Object等，UE可以构建一个Object运行的世界。（后续会有一个大长篇深挖UObject）</p>
<h2 id="其他引擎的对象模型情况"><a href="#其他引擎的对象模型情况" class="headerlink" title="其他引擎的对象模型情况"></a>其他引擎的对象模型情况</h2><p>Cocos系列，最早是cocos-iphone扎根于objective-c，几乎是机械翻译了objective-c的内存管理机制，搞出了一个CCObject</p>
<p>Unity 上层脚本C#是基于Mono</p>
<p>其他引擎，用的还是C++提供了的那些，顶多自己再定制一些管理辅助类。</p>
<p>Qt QObject</p>
<p>UE的Object系统无疑是最强大的。实际上UE能实践出这么一套UObject是非常非常了不起的，更何况还有GC和HotReload的黑科技。在大型游戏引擎的领域尝试引入一整套UObject系统，对于整个业界也都是有非常大的启发。</p>
<ul>
<li><p><strong>那么引入一个Object的根基类设计到底有什么深远的影响，我们又付出了什么代价？</strong></p>
</li>
<li><p>得到：</p>
</li>
</ul>
<ol>
<li><strong>万物可追踪。</strong>按照纯面向对象的思想，万物皆是对象。</li>
<li><strong>通用的属性和接口</strong>。Equals、Clone、GetHashCode、ToString、GetName、GetMetaData等等。</li>
<li><strong>统一的<strong><strong>内存</strong></strong>分配释放</strong>。GC，引用计数</li>
<li><strong>统一的序列化模型。</strong>类protobuf，模板化序列化。</li>
<li><strong>统计功能</strong>。哪种对象分配了最多次，哪种对象分配的时间最长，哪种对象存活的时间最长。</li>
<li><strong>调试的便利。</strong>Object基类下的一个子类对象，你可以把地址转换为一个Object指针，然后就可以一目了然的查看对象属性了。</li>
<li><strong>为反射提供便利。</strong>有GetType接口</li>
<li><strong>UI编辑的便利。</strong>和编辑器集成的时候，为了让UI的属性面板控件能编辑各种对象。</li>
</ol>
<ul>
<li>代价</li>
</ul>
<ol>
<li><strong>臃肿的Object。</strong>Object会堆积大量的函数接口和成员属性</li>
<li><strong>不必要的内存负担。</strong>有些类型对象可能一辈子都用不到，用不到的属性，却还占用着内存，就是浪费。</li>
<li><strong>多重继承的限制。</strong>一般有object基类的编程语言，都是直接限制多重继承，改为多重实现接口，避免了数据被继承多份的问题。</li>
<li><strong>类型系统的割裂。</strong>除非是像java和C#那样，对用户隐藏整个背后系统，否则用户在面对原生C++类型和Object类型时，就不得不去思考划分对象类型。</li>
</ol>
<p>这些代价我们也得想办法去尽量降低和规避：</p>
<ol>
<li><strong>针对太过复杂的Object基类。</strong>一个UObject你给我分了三层继承：（UObjectBase-&gt;UObjectBaseUtility-&gt;UObject）</li>
<li><strong>sizeof(UObject)==56。</strong>这个问题已经解决得在可接受范围内了。</li>
<li><strong>规避多重继承。</strong>UE在BP里提供的也是多重继承Interface的方案。在C++层面上，我们只能尽量规避不要多重继承多个UObject子类。</li>
<li><strong>只能多学习了。</strong>C++充当BP的VM。如UCLASS等各种宏的便利，NewObject方便接口，UHT的自动分析生成代码，尽量避免用户直接涉及到UObject的内部细节。</li>
</ol>
<h1 id="类型系统概述"><a href="#类型系统概述" class="headerlink" title="类型系统概述"></a>类型系统概述</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24445322">https://zhuanlan.zhihu.com/p/24445322</a></p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>虽然之上一直用反射的术语来描述我们熟知的那一套运行时得到类型信息的系统，动态创建类对象等，但是其实“反射”只是在“类型系统”之后实现的附加功能。</p>
<p>以后更多用“类型系统”这个更精确的术语来表述object之外的类型信息构建，而用“反射”这个术语来描述运行时得到类型的功能，通过类型信息反过来创建对象，读取修改属性，调用方法的功能行为。反射更多是一种行为能力，更偏向动词。类型系统指的是程序运行空间内构建出来的类型信息树组织，</p>
<h2 id="C-Type"><a href="#C-Type" class="headerlink" title="C# Type"></a>C# Type</h2><p>Unity用C#作为脚本语言，UE本身也是用C#作为编译UBT的实现语言。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = obj.GetType();  <span class="comment">//or typeof(MyClass)</span></span><br></pre></td></tr></table></figure>

<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-13.png" alt="img"></p>
<p>本篇不是C#反射教程（关心的自己去找相关教程），但这里还是简单提一下我们需要关注的：</p>
<ol>
<li>Assembly是程序集的意思，通常指的是一个dll。</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=Module&zhida_source=entity">Module</a>是程序集内部的子模块划分。</li>
<li>Type就是我们最关心的Class对象了，完整描述了一个对象的类型信息。并且Type之间也可以通过BaseType，DeclaringType之类的属性来互相形成Type关系图。</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=ConstructorInfo&zhida_source=entity">ConstructorInfo</a>描述了Type中的构造函数，可以通过调用它来调用特定的构造函数。</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=EventInfo&zhida_source=entity">EventInfo</a>描述了Type中定义的event事件（UE中的delegate大概）</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=FiedInfo&zhida_source=entity">FiedInfo</a>描述了Type中的字段，就是C++的成员变量，得到之后可以动态读取修改值</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=PropertyInfo&zhida_source=entity">PropertyInfo</a>描述了Type中的属性，类比C++中的get/set方法组合，得到后可以获取设置属性值。</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=MethodInfo&zhida_source=entity">MethodInfo</a>描述了Type中的方法。获得方法后就可以动态调用了。</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=ParameterInfo&zhida_source=entity">ParameterInfo</a>描述了方法中的一个个参数。</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=1964795&content_type=Article&match_order=1&q=Attributes&zhida_source=entity">Attributes</a>指的是Type之上附加的特性，这个C++里并没有，可以简单理解为类上的定义的元数据信息。</li>
</ol>
<p>可以看到C#里的Type几乎提供了一切信息数据，简直就像是把编译器编译后的数据都给暴露出来了给你。实际上C#的反射还可以提供其他更高级的功能，比如运行时动态创建出新的类，动态Emit编译代码，不过这些都是后话了。</p>
<h2 id="C-RTTI"><a href="#C-RTTI" class="headerlink" title="C++ RTTI"></a>C++ RTTI</h2><p>C++中的运行时类型系统，我们一般会说RTTI（Run-Time Type Identification），只提供了两个最基本的操作符：</p>
<h3 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h3><p>这个关键字的主要作用就是用于让用户知道是什么类型，并提供一些基本对比和name方法，作用也顶多只是让用户判断从属于不同的类型，所以其实说起来type_info的应用并不广泛，一般来说也只是把它当作编译器提供的一个唯一类型Id。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::type_info&amp; info = <span class="built_in">typeid</span>(MyClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">type_info</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">type_info</span>(type_info <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    type_info&amp; <span class="keyword">operator</span>=(type_info <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">hash_code</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(type_info <span class="type">const</span>&amp; _Other) <span class="type">const</span> <span class="built_in">throw</span>();</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(type_info <span class="type">const</span>&amp; _Other) <span class="type">const</span> <span class="built_in">throw</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">before</span><span class="params">(type_info <span class="type">const</span>&amp; _Other)</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="type">const</span>* <span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用，使用条件是只能用于含有虚函数的类。转换引用失败会抛出bad_cast异常，转换指针失败会返回null。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base* base=<span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* p=<span class="built_in">dynamic_cast</span>&lt;Derived&gt;(base);</span><br><span class="line"><span class="keyword">if</span>(p)&#123;...&#125;<span class="keyword">else</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>dynamic_cast内部机制其实也是利用虚函数表里的类型信息来判断一个基类指针是否指向一个派生类对象。其目的更多是用于在运行时判断对象指针是否为特定一个子类的对象。</p>
<h2 id="C-当前实现反射的方案"><a href="#C-当前实现反射的方案" class="headerlink" title="C++当前实现反射的方案"></a>C++当前实现反射的方案</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>基本思想是采用手动标记。在程序中用手动的方式注册各个类，方法，数据。大概就像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="built_in">Declare_Struct</span>(Test);</span><br><span class="line"> <span class="built_in">Define_Field</span>(<span class="number">1</span>, <span class="type">int</span>, a)</span><br><span class="line"> <span class="built_in">Define_Field</span>(<span class="number">2</span>, <span class="type">int</span>, b)</span><br><span class="line"> <span class="built_in">Define_Field</span>(<span class="number">3</span>, <span class="type">int</span>, c)</span><br><span class="line"> <span class="built_in">Define_Metadata</span>(<span class="number">3</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>举一个Github实现比较优雅的C++RTTI反射库做例子：<a href="https://link.zhihu.com/?target=https://github.com/rttrorg/rttr">rttr</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rttr/registration&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rttr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123; <span class="built_in">MyStruct</span>() &#123;&#125;; <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125;; <span class="type">int</span> data; &#125;;</span><br><span class="line">RTTR_REGISTRATION</span><br><span class="line">&#123;</span><br><span class="line">    registration::<span class="built_in">class_</span>&lt;MyStruct&gt;(<span class="string">&quot;MyStruct&quot;</span>)</span><br><span class="line">         .constructor&lt;&gt;()</span><br><span class="line">         .<span class="built_in">property</span>(<span class="string">&quot;data&quot;</span>, &amp;MyStruct::data)</span><br><span class="line">         .<span class="built_in">method</span>(<span class="string">&quot;func&quot;</span>, &amp;MyStruct::func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，这写得已经非常简洁优雅了。算得上是达到了C++模板应用的巅峰。但是可以看到，仍然需要一个个的手动去定义类并获取方法属性注册。优点是轻量程序内就能直接内嵌，缺点是不适合懒人。</p>
<h3 id="编译器数据分析"><a href="#编译器数据分析" class="headerlink" title="编译器数据分析"></a>编译器数据分析</h3><p>还有些人就想到既然C++编译器编译完整个代码，那肯定是有完整类型信息数据的。那能否把它们转换保存起来供程序使用呢？事实上这也是可行的，比如@vczh的GacUI里就分析了VC编译生成后pdb文件，然后抽取出类型定义的信息实现反射。VC确实也提供了IDiaDataSource COM组件用来读取pdb文件的内容。用法可以参考：<a href="https://link.zhihu.com/?target=http://www.cppblog.com/vczh/archive/2011/12/30/163200.html">GacUI Demo：PDB Viewer（分析pdb文件并获取C++类声明的详细内容）</a>。 理论上来说，只要你能获取到跟编译器同级别的类型信息，你基本上就像是全知了。但是缺点是分析编译器的生成数据，太过依赖平台（比如只能VC编译，换了Clang就是另一套方案），分析提取的过程往往也比较麻烦艰深，在正常的编译前需要多加一个编译流程。但优点也是得到的数据最是全面。 这种方案也因为太过麻烦，所以业内用的人不多。</p>
<h3 id="工具生成代码"><a href="#工具生成代码" class="headerlink" title="工具生成代码"></a>工具生成代码</h3><p>自然的有些人就又想到，既然宏和模板的方法，太过麻烦。那我能不能写一个工具来自动完成呢？</p>
<p>一个好例子就是Qt里面的反射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">　　<span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> Member1 READ Member1 WRITE setMember1 )</span></span></span><br><span class="line"><span class="function">　　<span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> Member2 READ Member2 WRITE setMember2 )</span></span></span><br><span class="line"><span class="function">　　<span class="title">Q_PROPERTY</span><span class="params">(QString MEMBER3 READ Member3 WRITE setMember3 )</span></span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">　　    explicit MyClass(QObject *parent =</span> <span class="number">0</span>);</span><br><span class="line">　　signals:</span><br><span class="line">　　<span class="keyword">public</span> slots:</span><br><span class="line">　　<span class="keyword">public</span>:</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE <span class="type">int</span> <span class="title">Member1</span><span class="params">()</span></span>;</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE <span class="type">int</span> <span class="title">Member2</span><span class="params">()</span></span>;</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE QString <span class="title">Member3</span><span class="params">()</span></span>;</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">setMember1</span><span class="params">( <span class="type">int</span> mem1 )</span></span>;</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">setMember2</span><span class="params">( <span class="type">int</span> mem2 )</span></span>;</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">setMember3</span><span class="params">( <span class="type">const</span> QString&amp; mem3 )</span></span>;</span><br><span class="line">　　　 <span class="function">Q_INVOKABLE <span class="type">int</span> <span class="title">func</span><span class="params">( QString flag )</span></span>;</span><br><span class="line">　　<span class="keyword">private</span>:</span><br><span class="line">　　　 <span class="type">int</span> m_member1;</span><br><span class="line">　　　 <span class="type">int</span> m_member2;</span><br><span class="line">　　　 QString m_member3;</span><br><span class="line">　&#125;;</span><br></pre></td></tr></table></figure>

<p>大概过程是Qt利用基于moc(meta object compiler)实现，用一个元对象编译器在程序编译前，分析C++源文件，识别一些特殊的宏Q_OBJECT、Q_PROPERTY、Q_INVOKABLE……然后生成相应的moc文件，之后再一起全部编译链接。</p>
<h2 id="UE里UHT的方案"><a href="#UE里UHT的方案" class="headerlink" title="UE里UHT的方案"></a>UE里UHT的方案</h2><p>不用多说，你们也能想到UE当前的方案也是如此，实现在C++源文件中空的宏做标记，然后用UHT分析生成generated.h/.cpp文件，之后再一起编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HELLO_API</span> UMyClass : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">        GENERATED_BODY()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        UPROPERTY(BlueprintReadWrite, Category = <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">        <span class="type">float</span> Score;</span><br><span class="line"></span><br><span class="line">        UFUNCTION(BlueprintCallable, Category = <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">CallableFuncTest</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        UFUNCTION(BlueprintNativeEvent, Category = <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">NativeFuncTest</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        UFUNCTION(BlueprintImplementableEvent, Category = <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">ImplementableFuncTest</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完整的C++的语法分析往往是超级复杂的，所以限制是自己写的分析器只能分析一些简单的C++语法规则和宏标记，如果用户使用比较复杂的语法时候，比如用#if /#endif包裹一些声明，就会让自己的分析器出错了，还好这种情况不多。关于多一次编译的问题，也可以通过自定义编译器的编译脚本UBT来规避。</p>
<p>这和C#的Attribute的语法简直差不多一模一样，所以UE也是吸收了C#语法反射的一些优雅写法，并利用上了C++的宏魔法，当然生成的代码里模板肯定也是少不了的。</p>
<h1 id="类型系统设定和结构"><a href="#类型系统设定和结构" class="headerlink" title="类型系统设定和结构"></a>类型系统设定和结构</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24790386">https://zhuanlan.zhihu.com/p/24790386</a></p>
<h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>函数也同样加上宏标记，大概就是类似C#Attribute的语法。在宏的参数可以按照我们自定的语法写上内容。在UE里我们就可以看到这些宏标记：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UPROPERTY(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFUNCTION(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTRUCT(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMETA(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPARAM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENUM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDELEGATE(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCLASS(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_PROLOG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINTERFACE(...) UCLASS()</span></span><br></pre></td></tr></table></figure>

<p><strong>为何是生成代码而不是数据文件？</strong></p>
<p>简单来说就是避免了不一致性，否则又得有机制去保证数据文件和代码能匹配上。同时跨平台需求也很难保证结构间的偏移在各个平台编译器优化的不同导致得差异。所以还不如简单生成代码文件一起编译进去得了。</p>
<p><strong>如果标记应该分析哪个文件？</strong></p>
<p>类A生成了A.generated.h和A.generated.cpp.</p>
<p>最方便的方式莫过于直接让A.h include A.generated.h了。那既然每个需要分析的文件最后都会include这么一个*.generated.h，那自然就可以把它本身就当作一种标记了。</p>
<p>UE目前的方案是每个要分析的文件加上该Include并且规定只能当作最后一个include，因为他也担心会有各种宏定义顺序产生的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FileName.generated.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>Hello类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hello.generated.h&quot;</span></span></span><br><span class="line"><span class="built_in">UClass</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="type">int</span> Count;</span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-14.png" alt="img"></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>类型</th>
<th>主要功能/特点</th>
<th>作用</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>聚合类型（UStruct）</td>
<td>UFunction</td>
<td>仅可包含属性作为函数的输入输出参数</td>
<td>用于定义可被蓝图调用的方法签名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UScriptStruct</td>
<td>仅可包含属性；类似C++中的POD结构体；拥有反射、序列化、复制支持</td>
<td>轻量级UObject；不受GC管理，需手动控制内存</td>
<td>这个实例负责持有该结构体所有的反射元数据（比如有哪些属性、函数等）。可以简单理解为：UStruct 是基类，UScriptStruct 是派生类，负责具体结构体类型的反射信息管理</td>
</tr>
<tr>
<td></td>
<td>UClass</td>
<td>可包含属性和函数；最常用的类型</td>
<td>用于定义对象类型（如Actor、Component等）</td>
<td></td>
</tr>
<tr>
<td>原子类型</td>
<td>UEnum</td>
<td>支持普通枚举和enum class</td>
<td>用于定义枚举类型</td>
<td></td>
</tr>
<tr>
<td></td>
<td>基础类型</td>
<td>int、FString等可通过不同的UProperty子类支持</td>
<td>基础类型无需特别声明，可通过UProperty系统进行反射和序列化</td>
<td></td>
</tr>
<tr>
<td>其他类型</td>
<td>UInterface</td>
<td>生成的类型数据依然用UClass存储。</td>
<td>UClass里通过保存一个TArray&lt; FImplementedInterface &gt; Interfaces数组</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UProperty</td>
<td>为用一个类型定义个字段“type instance;”</td>
<td></td>
<td>单的如UBoolProperty、UStrProperty，复杂的如UMapProperty、UDelegateProperty、UObjectProperty。</td>
</tr>
<tr>
<td></td>
<td>UMetaData</td>
<td>TMap&lt;FName, FString&gt;的键值对</td>
<td>为编辑器提供分类、友好名字、提示等信息，最终发布的时候不会包含此信息。</td>
<td></td>
</tr>
</tbody></table>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hello.generated.h&quot;</span></span></span><br><span class="line"><span class="built_in">UENUM</span>()</span><br><span class="line"><span class="keyword">namespace</span> ESearchCase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">    &#123;</span><br><span class="line">        CaseSensitive,</span><br><span class="line">        IgnoreCase,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EMyEnum</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MY_Dance    <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dance&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    MY_Rain     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Rain&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    MY_Song     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Song&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HELLO_API</span> FMyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_USTRUCT_BODY</span>()</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">    <span class="type">float</span> Score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HELLO_API</span> UMyClass : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="type">float</span> Score;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CallableFuncTest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OutCallableFuncTest</span><span class="params">(<span class="type">float</span>&amp; outParam)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RefCallableFuncTest</span><span class="params">(UPARAM(ref) <span class="type">float</span>&amp; refParam)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NativeFuncTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImplementableFuncTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UINTERFACE</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMyInterface</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_UINTERFACE_BODY</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_IINTERFACE_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BPFunc</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SelfFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思考：为什么还需要基类UField？</strong></p>
<p>UField名字顾名思义，就是不管是声明还是定义，都可以看作是类型系统里的一个字段，或者叫领域也行，术语不同，但能理解到一个更抽象统一的意思就行。</p>
<p><strong>思考：为什么UField要继承于UObject？</strong></p>
<p>UObject作用与在UField作用 ：</p>
<ol>
<li>GC  可有可无</li>
<li>反射 略</li>
<li>编辑器集成 也可以没有</li>
<li>CDO 不需要</li>
<li>序列化 必须有，类型数据当然需要保存下来，比如蓝图创建的类型。</li>
<li>Replicate 用处不大</li>
<li>RPC 也无所谓</li>
<li>自动属性更新 也不需要</li>
<li>统计 可有可无</li>
</ol>
<h1 id="类型系统代码生成"><a href="#类型系统代码生成" class="headerlink" title="类型系统代码生成"></a>类型系统代码生成</h1><p>本篇代码过长，建议观看原文，这边只是简单复述，后期再做修改。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25098685">https://zhuanlan.zhihu.com/p/25098685</a></p>
<p>同一般程序的构建流程需要经过<strong>预处理、编译、汇编、链接</strong>一样，UE为了在内存中模拟构建的过程，在概念上也需要以下几个阶段：<strong>生成，收集，注册，链接</strong>。总体的流程比较繁杂，因此本文首先开始介绍第一阶段，生成。在生成阶段，UHT分析我们的代码，并生成类型系统的相关代码。</p>
<p>Note1：生成的代码和注册的过程会因为HotReload功能的开启与否有些不一样，因此为了最简化流程阐述，我们先关闭HotReload，关闭的方式是在Hello.Build.cs里加上一行：Definitions.Add(“WITH_HOT_RELOAD_CTORS=0”);</p>
<p>Note2：本文开始及后续会简单的介绍一些用到的C++基础知识，但只是点到为止，不做深入探讨。</p>
<h2 id="C-Static-Lazy初始化模式"><a href="#C-Static-Lazy初始化模式" class="headerlink" title="C++ Static Lazy初始化模式"></a>C++ Static Lazy初始化模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Hello* <span class="title">StaticGetHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Hello* obj=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!obj)</span><br><span class="line">    &#123;</span><br><span class="line">        obj=...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="function">Hello&amp; <span class="title">StaticGetHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> Hello <span class="title">obj</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前者非常简单，也没考虑多线程安全，但是在单线程环境下足够用了。用指针的原因是，有一些情况，这些对象的生命周期是由别的地方来管理的，比如UE里的GC，因此这里只static化一个指针。否则的话，还是后者更加简洁和安全。</p>
<h2 id="UHT代码生成"><a href="#UHT代码生成" class="headerlink" title="UHT代码生成"></a>UHT代码生成</h2><p>在C++程序中的预处理是用来对源代码进行宏展开，预编译指令处理，注释删除等操作。</p>
<p>同样的，一旦我们采用了宏标记的方法，不管是怎么个标记语法，我们都需要进行简单或复杂的词法分析，提取出有用的信息，然后生成所需要的代码。</p>
<p>在引擎里创建一个空C++项目命名为Hello，然后创建个不继承的MyClass类。编译，UHT就会为我们生成以下4个文件（位于Hello\Intermediate\Build\Win64\Hello\Inc\Hello）</p>
<ul>
<li>HelloClasses.h：目前无用</li>
<li>MyClass.generated.h：MyClass的生成头文件</li>
<li>Hello.generated.dep.h：Hello.generated.cpp的依赖头文件，也就是顺序包含上述的MyClass.h而已</li>
<li>Hello.generated.cpp：该项目的实现编译单元。</li>
</ul>
<h2 id="UCLASS的生成代码剖析"><a href="#UCLASS的生成代码剖析" class="headerlink" title="UCLASS的生成代码剖析"></a>UCLASS的生成代码剖析</h2><h3 id="MyClass-h"><a href="#MyClass-h" class="headerlink" title="MyClass.h"></a>MyClass.h</h3><p>基础文件样式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//include 一些基础类 与 专门供UHT使用来生成蓝图类型的（现在不用管）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//就是为了引用生成的头文件。</span></span><br><span class="line"><span class="comment">//这里请注意的是，该文件include位置在类声明的前面，</span></span><br><span class="line"><span class="comment">//之后谈到宏处理的时候会用到该信息。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HELLO_API</span> UMyClass : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GENERATED_BODY()，该宏是重中之重，其他的UCLASS宏只是提供信息，不参与编译，而GENERATED_BODY正是把声明和元数据定义关联到一起的枢纽。继续查看宏定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CURRENT_FILE_ID的定义是在MyClass.generated.h的89行：</span></span><br><span class="line"><span class="comment">//这是UHT通过分析文件得到的信息。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT_FILE_ID Hello_Source_Hello_MyClass_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//__LINE__标准宏指向了该宏使用时候的的行数，这里是17。</span></span><br><span class="line"><span class="comment">//加了一个__LINE__宏的目的是为了支持在同一个文件内声明多个类，</span></span><br><span class="line"><span class="comment">//比如在MyClass.h里接着再声明UMyClass2，就可以支持生成不同的宏名称。</span></span><br></pre></td></tr></table></figure>

<p>GENERATED_BODY()  ==》Hello_Source_Hello_MyClass_h_11_GENERATED_BODY</p>
<p>如果MyClass类需要UMyClass(const FObjectInitializer&amp; ObjectInitializer)的构造函数自定义实现，则需要用GENERATED_UCLASS_BODY宏来让最终生成的宏指向</p>
<p>Hello_Source_Hello_MyClass_h_11_GENERATED_BODY_LEGACY（MyClass.generated.h的66行），其最终展开的内容会多一个构造函数的内容实现。</p>
<h3 id="MyClass-generated-h"><a href="#MyClass-generated-h" class="headerlink" title="MyClass.generated.h"></a>MyClass.generated.h</h3><p><strong>代码详见原文</strong></p>
<p>自下而上分析</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>展开宏</th>
<th>定义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CURRENT_FILE_ID</td>
<td>Hello_Source_Hello_MyClass_h</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hello_Source_Hello_MyClass_h_11_GENERATED_BODY</td>
<td>Hello_Source_Hello_MyClass_h_11_PRIVATE_PROPERTY_OFFSET Hello_Source_Hello_MyClass_h_11_RPC_WRAPPERS_NO_PURE_DECLS Hello_Source_Hello_MyClass_h_11_INCLASS_NO_PURE_DECLS  Hello_Source_Hello_MyClass_h_11_ENHANCED_CONSTRUCTORS</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GENERATED_BODY</td>
<td>BODY_MACRO_COMBINE(CURRENT_FILE_ID,,LINE,GENERATED_BODY) Hello_Source_Hello_MyClass_h_11_GENERATED_BODY</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hello_Source_Hello_MyClass_h_11_ENHANCED_CONSTRUCTORS</td>
<td>1. 禁止掉C++11的移动和拷贝构造 2.因 WITH_HOT_RELOAD_CTORS关闭 下面俩个空宏  DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UMyClass); DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UMyClass); 3.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hello_Source_Hello_MyClass_h_11_STANDARD_CONSTRUCTORS</td>
<td>和上行只差 : Super(ObjectInitializer) { } 构造函数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL</td>
<td>#define DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(TClass) \  static void __DefaultConstructor(const FObjectInitializer&amp; X) { new((EInternal*)X.GetObj())TClass(X); }</td>
<td>声明定义了一个构造函数包装器</td>
<td></td>
</tr>
<tr>
<td>DECLARE_CLASS</td>
<td>DECLARE_CLASS(UMyClass, UObject, COMPILED_IN_FLAGS(0), 0, TEXT(“/Script/Hello”), NO_API)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>DECLARE_CLASS</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TClass</td>
<td>类名</td>
</tr>
<tr>
<td>TSuperClass</td>
<td>基类名字</td>
</tr>
<tr>
<td>TStaticFlags</td>
<td>类的属性标记，这里是0，表示最默认，不带任何其他属性。读者可以查看EClassFlags枚举来查看其他定义。</td>
</tr>
<tr>
<td>TStaticCastFlags</td>
<td>指定了该类可以转换为哪些类，这里为0表示不能转为那些默认的类，读者可以自己查看EClassCastFlags声明来查看具体有哪些默认类转换。</td>
</tr>
<tr>
<td>TPackage</td>
<td>类所处于的包名，所有的对象都必须处于一个包中，而每个包都具有一个名字，可以通过该名字来查找。这里是”/Script/Hello”，指定是Script下的Hello，Script可以理解为用户自己的实现，不管是C++还是蓝图，都可以看作是引擎外的一种脚本</td>
</tr>
</tbody></table>
<h3 id="Hello-generated-cpp"><a href="#Hello-generated-cpp" class="headerlink" title="Hello.generated.cpp"></a>Hello.generated.cpp</h3><p>而整个Hello项目会生成一个Hello.generated.cpp</p>
<p><strong>代码详见原文</strong></p>
<p>大部分简单的都注释说明了，本文件的关键点在于IMPLEMENT_CLASS的分析，和上文.h中的DECLARE_CLASS对应，其声明如下：</p>
<p>对照着定义IMPLEMENT_CLASS(UMyClass, 899540749);</p>
<p><strong>代码详见原文</strong></p>
<p>内容也比较简单，就是把该类的信息传进去给GetPrivateStaticClassBody函数。</p>
<h3 id="最后展开结果"><a href="#最后展开结果" class="headerlink" title="最后展开结果"></a>最后展开结果</h3><p>MyClass.h展开</p>
<p><strong>代码详见原文</strong></p>
<p>Hello.generated.cpp展开</p>
<p><strong>代码详见原文</strong></p>
<p>这样.h的声明和.cpp的定义就全都有了。不管定义了多少函数，要记得注册的入口就是那两个static对象在程序启动的时候登记信息，才有了之后的注册。</p>
<h2 id="UENUM的生成代码剖析"><a href="#UENUM的生成代码剖析" class="headerlink" title="UENUM的生成代码剖析"></a>UENUM的生成代码剖析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyEnum.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EMyEnum</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function">MY_Dance         <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dance&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">        MY_Rain         <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Rain&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">        MY_Song                <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Song&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>Z_Construct_UEnum_Hello_EMyEnum的简单封装</p>
<p>ScriptStruct_Hello_StaticRegisterNativesFMyStruct会在程序一启动就调用UScriptStruct::DeferCppStructOps向程序注册该结构的CPP信息（大小，内存对齐等）</p>
<h2 id="USTRUCT的生成代码剖析"><a href="#USTRUCT的生成代码剖析" class="headerlink" title="USTRUCT的生成代码剖析"></a>USTRUCT的生成代码剖析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyStruct.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HELLO_API</span> FMyStruct</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">GENERATED_USTRUCT_BODY</span>()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        <span class="type">float</span> Score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Z_Construct_UScriptStruct_FMyStruct的简单封装</p>
<h2 id="UINTERFACE的生成代码剖析"><a href="#UINTERFACE的生成代码剖析" class="headerlink" title="UINTERFACE的生成代码剖析"></a>UINTERFACE的生成代码剖析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyInterface.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UINTERFACE</span>(BlueprintType)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMyInterface</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">GENERATED_UINTERFACE_BODY</span>()    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">GENERATED_IINTERFACE_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">BPFunc</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GENERATED_UINTERFACE_BODY和GENERATED_IINTERFACE_BODY</p>
<p>可替换为GENERATED_BODY 只不过会多一个构造函数</p>
<p>UMyInterface(const FObjectInitializer&amp; ObjectInitializer)，</p>
<p>不需要这个构造函数，没差别。</p>
<p>我们的类只是继承于IMyInterface，UMyInerface只是作为一个接口类型的载体</p>
<h2 id="UClass中的字段和函数生成代码剖析"><a href="#UClass中的字段和函数生成代码剖析" class="headerlink" title="UClass中的字段和函数生成代码剖析"></a>UClass中的字段和函数生成代码剖析</h2><p>如果UMyClass里多了Property和Function之后又会起什么变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(BlueprintType)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HELLO_API</span> UMyClass : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        <span class="type">float</span> Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">CallableFunc</span><span class="params">()</span></span>;    <span class="comment">//C++实现，蓝图调用</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">NativeFunc</span><span class="params">()</span></span>;  <span class="comment">//C++实现默认版本，蓝图可重载实现</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ImplementableFunc</span><span class="params">()</span></span>;   <span class="comment">//C++不实现，蓝图实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>蓝图虚拟机调用execCallableFunc</p>
<h1 id="类型系统信息收集"><a href="#类型系统信息收集" class="headerlink" title="类型系统信息收集"></a>类型系统信息收集</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26019216">https://zhuanlan.zhihu.com/p/26019216</a></p>
<h2 id="Static-Auto-Register"><a href="#Static-Auto-Register" class="headerlink" title="Static Auto Register"></a>Static Auto Register</h2><p>自动注册模式：工厂+注册。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WHEgqing/article/details/121461936">https://blog.csdn.net/WHEgqing/article/details/121461936</a></p>
<ul>
<li>Register</li>
</ul>
<p>这个缺点是每一次都要添加一行注册。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClassA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClassB.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassFactory::<span class="built_in">Get</span>().<span class="built_in">Register</span>&lt;ClassA&gt;();</span><br><span class="line">    ClassFactory::<span class="built_in">Get</span>().<span class="built_in">Register</span>&lt;ClassB&gt;();[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Auto Register </li>
</ul>
<p>C++ static对象会在main函数之前初始化的特性。</p>
<p>所以在每次初始化的时候去auto注册，只需要Include进对应配的.h.cpp文件。</p>
<p>把因为新添加类而产生的改变行为限制在了新文件本身，对于一些顺序无关的注册行为这种模式尤为合适</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StaticAutoRegister.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TClass&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StaticAutoRegister</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">StaticAutoRegister</span>()</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">Register</span>(TClass::<span class="built_in">StaticClass</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[...]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StaticAutoRegister.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> StaticAutoRegister&lt;MyClass&gt; AutoRegister;</span><br></pre></td></tr></table></figure>

<ul>
<li>Other </li>
</ul>
<p>你可以把StaticAutoRegister声明进MyClass的一个静态成员变量也可以。</p>
<p>但是因为UE都是dll动态链接，若没被加载lib的话再引用lib的话会绕过static初始化以至于报错，类似懒汉模式。或者你可以直接强制去include一下来触发static初始化（？）。</p>
<h2 id="UE-Static-Auto-Register"><a href="#UE-Static-Auto-Register" class="headerlink" title="UE Static Auto Register"></a>UE Static Auto Register</h2><p>都是对该模式的应用，把static变量声明再用宏包装一层，就可以实现一个简单的自动注册流程了。</p>
<h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><ul>
<li>需要解决的问题</li>
</ul>
<p>从上一章收集到的所有元数据要进行保存。</p>
<p>但是这些元数据散落在各自的dll中，我们需要在注册的时候进行收集。</p>
<p>在UE Static Auto Register 中会全部注册一遍，但是先后的依赖问题还需要解决。</p>
<ul>
<li>UE 引擎结构<ul>
<li>Game<ul>
<li>玩家自己的Game模块是处于比较高级的层次的，都是依赖于引擎其他更基础底层的模块。</li>
</ul>
</li>
<li>Module<ul>
<li>UE是以Module来组织引擎结构的，一个个Module可以通过脚本配置来选择性的编译加载。</li>
</ul>
</li>
<li>CoreUObject<ul>
<li>实现Object类型系统的模块</li>
</ul>
</li>
<li>Core<ul>
<li>C++的基础库,最最底层</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此在类型系统注册的过程中，不止要注册玩家的Game模块，同时也要注册CoreUObject本身的一些支持类。</p>
<p>很多人可能会担心这么多模块的静态初始化的顺序正确性如何保证，在c++标准里，不同编译单元的全局静态变量的初始化顺序并没有明确规定，因此实现上完全由编译器自己决定。该问题最好的解决方法是尽可能的避免这种情况，在设计上就让各个变量不互相引用依赖，同时也采用一些二次检测的方式避免重复注册，或者触发一个强制引用来保证前置对象已经被初始化完成。目前在MSVC平台上是先注册玩家的Game模块，接着是CoreUObject，接着再其他，不过这其实无所谓的，只要保证不依赖顺序而结果正确，顺序就并不重要了。</p>
<h2 id="Static的收集"><a href="#Static的收集" class="headerlink" title="Static的收集"></a>Static的收集</h2><p>搜集这边可以后面回头再复习</p>
<p>我们再来分别的看各个类别的结构的信息的收集。从Class（Interface同理）开始，然后是Enum，接着Struct。</p>
<h2 id="Class的收集"><a href="#Class的收集" class="headerlink" title="Class的收集"></a>Class的收集</h2><p>Hello.generated.cpp展开</p>
<p>调用了UClassCompiledInDefer来收集类名字，类大小，CRC信息，并把自己的指针保存进来以便后续调用Register方法。</p>
<p>而UObjectCompiledInDefer（现在暂时不考虑动态类）最重要的收集的信息就是第一个用于构造UClass*对象的函数指针回调</p>
<p>二者其实都只是在一个静态Array里添加信息记录</p>
<p>而在整个引擎里会触发此Class的信息收集的有UCLASS、UINTERFACE、IMPLEMENT_INTRINSIC_CLASS、IMPLEMENT_CORE_INTRINSIC_CLASS，其中UCLASS和UINTERFACE我们上文已经见识过了，而IMPLEMENT_INTRINSIC_CLASS是用于在代码中包装UModel，IMPLEMENT_CORE_INTRINSIC_CLASS是用于包装UField、UClass等引擎内建的类，后两者内部也都调用了IMPLEMENT_CLASS来实现功能。</p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-15.png" alt="img"></p>
<p><strong>思考：为何需要TClassCompiledInDefer和FCompiledInDefer两个静态初始化来登记？</strong></p>
<p><strong>思考：为何需要延迟注册而不是直接在static回调里执行？</strong></p>
<h2 id="Enum的收集"><a href="#Enum的收集" class="headerlink" title="Enum的收集"></a>Enum的收集</h2><p>static阶段会向内存注册一个构造UEnum*的函数指针用于回调.</p>
<p>这里并不需要像UClassCompiledInDefer一样先生成一个UClass*，因为UEnum并不是一个Class，并没有Class那么多功能集合</p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-16.png" alt="img"></p>
<h2 id="Struct的收集"><a href="#Struct的收集" class="headerlink" title="Struct的收集"></a>Struct的收集</h2><p>Struct也和Enum同理，因为并不是一个Class，所以并不需要比较繁琐的两步构造，凭着FPendingStructRegistrant就可以后续一步构造出UScriptStruct*对象；</p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-17.png" alt="img"></p>
<h2 id="Function的收集"><a href="#Function的收集" class="headerlink" title="Function的收集"></a>Function的收集</h2><p>IMPLEMENT_CAST_FUNCTION，定义一些Object的转换函数</p>
<p>IMPLEMENT_VM_FUNCTION，定义一些蓝图虚拟机使用的函数</p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-18.png" alt="img"></p>
<h2 id="UObject的收集"><a href="#UObject的收集" class="headerlink" title="UObject的收集"></a>UObject的收集</h2><p>在最开始的IMPLEMENT_VM_FUNCTION(EX_CallMath, execCallMathFunction)调用上，其内部会紧接着触发UObject::StaticClass()的调用，作为最开始的调用，检测到UClass<em>并未生成，于是接着会转发到GetPrivateStaticClassBody中去生成一个UClass</em></p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295760-19.png" alt="img"></p>
<h1 id="类型系统代码生成重构-UE4CodeGen-Private"><a href="#类型系统代码生成重构-UE4CodeGen-Private" class="headerlink" title="类型系统代码生成重构-UE4CodeGen_Private"></a>类型系统代码生成重构-UE4CodeGen_Private</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在UE4.15版本UE4.17重构了UObjectGlobals.h.cpp</p>
<p>为了解决在生成代码元数据生成的时候会有过度重复的内容。</p>
<p>会导致每个反射文件代码量过大，编译时间过长，Debug降低代码可读性和可调试性。 本篇本质是类型代码生成的补充</p>
<h2 id="UE4CodeGen-Private"><a href="#UE4CodeGen-Private" class="headerlink" title="UE4CodeGen_Private"></a>UE4CodeGen_Private</h2><p>UE在4.17的时候，在UObjectGlobals.h.cpp里增加了一个UE4CodeGen_Private的命名空间，里面添加了一些生成函数。</p>
<p>这些函数都是用来构造元数据结构和添加元数据的。第一个参数都是函数指针，第二个是关键params</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UObjectGlobals.h</span></span><br><span class="line"><span class="keyword">namespace</span> UE4CodeGen_Private</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">COREUOBJECT_API <span class="type">void</span> <span class="title">ConstructUFunction</span><span class="params">(UFunction*&amp; OutFunction, <span class="type">const</span> FFunctionParams&amp; Params)</span></span>;</span><br><span class="line">    <span class="function">COREUOBJECT_API <span class="type">void</span> <span class="title">ConstructUEnum</span><span class="params">(UEnum*&amp; OutEnum, <span class="type">const</span> FEnumParams&amp; Params)</span></span>;</span><br><span class="line">    <span class="function">COREUOBJECT_API <span class="type">void</span> <span class="title">ConstructUScriptStruct</span><span class="params">(UScriptStruct*&amp; OutStruct, <span class="type">const</span> FStructParams&amp; Params)</span></span>;</span><br><span class="line">    <span class="function">COREUOBJECT_API <span class="type">void</span> <span class="title">ConstructUPackage</span><span class="params">(UPackage*&amp; OutPackage, <span class="type">const</span> FPackageParams&amp; Params)</span></span>;</span><br><span class="line">    <span class="function">COREUOBJECT_API <span class="type">void</span> <span class="title">ConstructUClass</span><span class="params">(UClass*&amp; OutClass, <span class="type">const</span> FClassParams&amp; Params)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UObjectGlobals.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> UE4CodeGen_Private</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConstructUProperty</span><span class="params">(UObject* Outer, <span class="type">const</span> FPropertyParamsBase* <span class="type">const</span>*&amp; PropertyArray, int32&amp; NumProperties)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMetaData</span><span class="params">(UObject* Object, <span class="type">const</span> FMetaDataPairParam* MetaDataArray, int32 NumMetaData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：FPropertyParamsBaseWithOffset以及后续为何不继承于FPropertyParamsBase？</strong></p>
<p><strong>思考：为什么生成的代码里大量用了函数指针来返回对象？</strong></p>
<p><strong>思考：生成的代码能否做得更加的清晰高效？</strong></p>
<h1 id="类型系统注册-第一个UClass"><a href="#类型系统注册-第一个UClass" class="headerlink" title="类型系统注册-第一个UClass"></a>类型系统注册-第一个UClass</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57005310">https://zhuanlan.zhihu.com/p/57005310</a></p>
<p>9.17 更新 ： 在B站视频所说 UE5 应该是重构了IMPLEMENT_CLASS 为 IMPLEMENT_CLASS_NO_AUTO_RIGISTER,就不会有第一个CLASS 这篇 但是在main函数动态加载的时候</p>
<p>加载Core会使用到这部分函数</p>
<p>在前面已经对于生成代码与信息收集进行分析过后</p>
<p>类型系统的元数据依旧零散分部在全局变量中，需要去统一去调用。</p>
<p>在注册文章中重点是处理程序启动过程中，怎么吧手机出的信息和函数去调用，最后加载到内存中去构造中类型系统的类型树的。</p>
<h2 id="Static初始化"><a href="#Static初始化" class="headerlink" title="Static初始化"></a>Static初始化</h2><p>在类型信息收集最后的UObject收集中：</p>
<p><code>IMPLEMENT_VM_FUNCTION(EX_CallMath, execCallMathFunction)</code>会触发<code>UObject::StaticClass()</code>的调用，因此作为最开始的调用，会生成第一个UClass*。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_FUNCTION(func) \</span></span><br><span class="line"><span class="meta">static FNativeFunctionRegistrar UObject##func##Registar(UObject::StaticClass(),#func,&amp;UObject::func);</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">IMPLEMENT_VM_FUNCTION</span>(EX_CallMath, execCallMathFunction);<span class="comment">//ScriptCore.cpp里的定义</span></span><br></pre></td></tr></table></figure>

<p><code>IMPLEMENT_CAST_FUNCTION</code>会触发execCallMathFunction,在上面可以看出 构造的时候第一个参数就会触发 <code>UObject::StaticClass()</code> 调用 而后去 调用 <code>GetPrivateStaticClass</code> （在IMPLEMENT_CLASS定义）</p>
<p>在与UObject相关的IMPLEMENT_CLASS在NoExportTypes.h文件中</p>
<h2 id="NoExportTypes-h"><a href="#NoExportTypes-h" class="headerlink" title="NoExportTypes.h"></a>NoExportTypes.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CPP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含一些头文件来让NoExportTypes.gen.cpp可以编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !CPP<span class="comment">//这里面的部分是不参与编译的，所以不会产生定义冲突，但是却可以让UHT分析，因为UHT只是个文本分析器而已。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举的声明，只是加上了宏标记。</span></span><br><span class="line"><span class="comment">//结构的声明，只是加上了宏标记。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//UObject的声明，C++的内容其实不重要，重要的是让UHT分析得到些什么信息</span></span><br><span class="line"><span class="built_in">UCLASS</span>(abstract, noexport)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExecuteUbergraph</span><span class="params">(int32 EntryPoint)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>NoExportTypes.gen.cpp 就和之前生成元数据一样的结构了，会有<code>IMPLEMENT_CLASS(UObject, 1563732853)</code> 的定义</p>
<h2 id="GetPrivateStaticClass"><a href="#GetPrivateStaticClass" class="headerlink" title="GetPrivateStaticClass"></a>GetPrivateStaticClass</h2><p>收集GetPrivateStaticClassBody的信息，里面有需要注意的点是：</p>
<ol>
<li>Package 是构建UClass* 后把该对象的OuterPrivate设定为正确的UPackage*，UObject必须属于某个UPackage。</li>
<li>StaticRegisterNativesUMyClass是宏拼接的在.generated.h和.gen.cpp声明定义</li>
<li>InternalConstructor<UMyClass> 是封装C++构造函数（你没办法去直接获得C++构造函数），在.generated.h会调用（<code>GENERATED_UCLASS_BODY</code>接收FObjectInitializer参数，<code>GENERATED_BODY</code>不接收参数）</li>
<li>Super  是类的基类依赖于基类先构建好UClass<em>。 WithinClass 是对象的Outer对象的类型在UObject</em>在构建好之后应该限制放在哪种Outer下</li>
</ol>
<h2 id="GetPrivateStaticClassBody"><a href="#GetPrivateStaticClassBody" class="headerlink" title="GetPrivateStaticClassBody"></a>GetPrivateStaticClassBody</h2><ol>
<li>全局分配内存器GUObjectAllocator 分配一部分内存，返回的ReturnClass是引用。所以外面的GetPrivateStaticClass可以提前得到值，直接访问UMyClass::StaticClass()也会返回这个值。</li>
<li>调用UClass构造函数，EC_StaticConstructor表示调用特定的重载的构造函数版本。因为是统一管理内存所以应该要GUObjectAllocator 来分配。</li>
<li>InitializePrivateStaticClass会调用InSuperClassFn() -&gt; Super::StaticClass() 和 InWithinClassFn() -&gt; WithinClass::StaticClass() 会堆栈式的加载前置的类型。</li>
<li>RegisterNativeFunc() 就是StaticRegisterNativesUMyClass。用来像UClass里添加Native函数（指的是在C++有函数体实现的函数，而蓝图中的函数和BlueprintImplementableEvent的函数就不是Native函数。）</li>
</ol>
<h2 id="InitializePrivateStaticClass"><a href="#InitializePrivateStaticClass" class="headerlink" title="InitializePrivateStaticClass"></a>InitializePrivateStaticClass</h2><p>初始化</p>
<ol>
<li>设定SuperStruct，在UStruct里的UStruct* SuperStruct的一个变量。</li>
<li>设定ClassWithin，限制Outer的类型。</li>
<li>调用UObjectBase::Register() -&gt; UClassRegisterAllCompiledInClasses注册</li>
</ol>
<h2 id="UObjectBase-Register"><a href="#UObjectBase-Register" class="headerlink" title="UObjectBase::Register"></a>UObjectBase::Register</h2><p>先记录一下信息到一个全局单件Map里和一个全局链表里（LRU结构？）</p>
<p><strong>思考：为何Register只是先记录一下信息？</strong></p>
<p><strong>思考：记录信息为何需要一个TMap加一个链表？</strong></p>
<h2 id="RegisterNativeFunc"><a href="#RegisterNativeFunc" class="headerlink" title="RegisterNativeFunc"></a>RegisterNativeFunc</h2><p>GetPrivateStaticClassBody的最后一步：RegisterNativeFunc的调用</p>
<p>简单的往UClass*里添加Native函数的数据NativeFunctionLookupTable（UClass里的一个成员变量）</p>
<p><strong>思考：为什么这么猴急的需要一开始就往UClass里添加Native函数？</strong></p>
<p><strong>思考：那些非Native的函数怎么办？</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="./../../pic/picture/0077-UEUObject/1761189295760-20.png" alt="img"></p>
<ul>
<li>SuperStruct = NULL，因为UObject上面没有基类了</li>
<li>ClassPrivate = NULL，所属的类型，这个时候还没有设置该值。在以后会设置指向UClass::StaticClass()，因为其本身是一个UClass。</li>
<li>OuterPrivate = NULL，属于的Outer，也还没放进任何Package里。在以后会设置指向“/Script/CoreUObject”的UPackage。</li>
<li>NamePrivate = “None”，还没有设定任何名字。在以后会设置为“Object”</li>
<li>ClassWithin = this，这个倒是已经知道了指向自己，表明一个UObject可以放在任何UObject下。</li>
<li>PropertiesSize = sizeof(UObject) = 56，所以一个最简单的UObject的大小是56字节</li>
</ul>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-21.png" alt="img"></p>
<h1 id="类型系统注册-CoreUObject模块加载"><a href="#类型系统注册-CoreUObject模块加载" class="headerlink" title="类型系统注册-CoreUObject模块加载"></a>类型系统注册-CoreUObject模块加载</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57611137">https://zhuanlan.zhihu.com/p/57611137</a></p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>UE整体启动流程 绿色部分涉及CoreUObject</p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-22.png" alt="img"></p>
<ul>
<li>Static初始化: 前文说的收集过程</li>
<li>WinMain: 以Windows为例子 是LaunchWindows.cpp 的程序入口</li>
<li>GuardedMain:程序循环 其中Engine开头的函数 简单调用到 GEngineLoop</li>
<li>FEngineLoop::PreInit : 涉及UObject启动的最开始（重点关注）</li>
</ul>
<h2 id="FEngineLoop-PreInit"><a href="#FEngineLoop-PreInit" class="headerlink" title="FEngineLoop::PreInit"></a>FEngineLoop::PreInit</h2><p>UE是建立在UObject对象系统上的，其他模块要启动的话，那么就要CoreUObject模块初始化完成。因此在引擎循环的预初始化部分就得开始加载CoreUObject了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">FEngineLoop::PreInit</span><span class="params">(<span class="type">const</span> TCHAR* CmdLine)</span></span>&#123;<span class="comment">//...</span></span><br><span class="line">    <span class="built_in">LoadCoreModules</span>();  <span class="comment">//加载CoreUObject模块</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//LoadPreInitModules();   //加载一些PreInit的模块，比如Engine，Renderer</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">AppInit</span>();  <span class="comment">//程序初始化</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">ProcessNewlyLoadedUObjects</span>();   <span class="comment">//处理最近加载的对象</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//LoadStartupModules();   //自己写的LoadingPhase为PreDefault的模块在这个时候加载</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    GUObjectArray.<span class="built_in">CloseDisregardForGC</span>();    <span class="comment">//对象池启用，最开始是关闭的</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//NotifyRegistrationComplete();   //注册完成事件通知，完成Package加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> LoadCoreModules() 会调用FModuleManager::Get().LoadModule(TEXT(“CoreUObject”))</p>
<p>从而触发FCoreUObjectModule::StartupModule()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FCoreUObjectModule</span> : <span class="keyword">public</span> FDefaultModuleImpl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartupModule</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Register all classes that have been loaded so far. This is required for CVars to work.</span></span><br><span class="line">        <span class="built_in">UClassRegisterAllCompiledInClasses</span>();   <span class="comment">//注册所有编译进来的类，此刻大概有1728多个</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InitUObject</span><span class="params">()</span></span>;</span><br><span class="line">        FCoreDelegates::OnInit.<span class="built_in">AddStatic</span>(InitUObject);  <span class="comment">//先注册个回调，后续会在AppInit里被调用</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UClassRegisterAllCompiledInClasses"><a href="#UClassRegisterAllCompiledInClasses" class="headerlink" title="UClassRegisterAllCompiledInClasses"></a>UClassRegisterAllCompiledInClasses</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UClassRegisterAllCompiledInClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TArray&lt;FFieldCompiledInInfo*&gt;&amp; DeferredClassRegistration = <span class="built_in">GetDeferredClassRegistration</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> FFieldCompiledInInfo* Class : DeferredClassRegistration)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的Class其实是TClassCompiledInDefer&lt;TClass&gt;</span></span><br><span class="line">        UClass* RegisteredClass = Class-&gt;<span class="built_in">Register</span>();    <span class="comment">//return TClass::StaticClass();</span></span><br><span class="line">    &#125;</span><br><span class="line">    DeferredClassRegistration.<span class="built_in">Empty</span>();  <span class="comment">//前面返回的是引用，因此这里可以清空数据。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="type">static</span> TArray&lt;FFieldCompiledInInfo*&gt;&amp; <span class="title">GetDeferredClassRegistration</span><span class="params">()</span>    <span class="comment">//返回可变引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> TArray&lt;FFieldCompiledInInfo*&gt; DeferredClassRegistration; <span class="comment">//单件模式</span></span><br><span class="line">    <span class="keyword">return</span> DeferredClassRegistration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上篇有提到这个函数，接下来直接上原文</p>
<ol>
<li><code>GetDeferredClassRegistration()</code>里的元素是之前收集文章里讲的静态初始化的时候添加进去的，在XXX.gen.cpp里用static TClassCompiledInDefer这种形式添加。</li>
<li><code>TClassCompiledInDefer&lt;TClass&gt;::Register()</code>内部只是简单的转调<code>TClass::StaticClass()</code>。</li>
<li><code>TClass::StaticClass()</code>是在XXX.generated.h里的<code>DECLARE_CLASS</code>宏里定义的，内部只是简单的转到<code>GetPrivateStaticClass(TPackage)</code>。</li>
<li><code>GetPrivateStaticClass(TPackage)</code>的函数是实现是在<code>IMPLEMENT_CLASS</code>宏里。其内部会真正调用到<code>GetPrivateStaticClassBody</code>。这个函数的内部会创建出UClass对象并调用Register()，在上篇已经具体讲解过了。</li>
<li>总结这里的逻辑就是对之前收集到的所有的XXX.gen.cpp里定义的类，都触发一次其UClass的构造，其实也只有UObject比较特殊，会在Static初始化的时候就触发构造。因此这个过程其实是类型系统里每一个类的UClass的创建过程。</li>
<li>这个函数会被调用多次，在后续的<code>ProcessNewlyLoadedUObjects</code>的里仍然会触发该调用。在<code>FCoreUObjectModule::StartupModule()</code>的这次调用是最先的，这个时候加载编译进来的的类都是引擎启动一开始就链接进来的。</li>
</ol>
<p><strong>思考：猜猜看最先生成的是哪几个类？</strong></p>
<p><strong>思考：Struct和Enum的注册为何在这一个阶段无体现？</strong></p>
<h1 id="类型系统注册-InitUObject"><a href="#类型系统注册-InitUObject" class="headerlink" title="类型系统注册-InitUObject"></a>类型系统注册-InitUObject</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58244447">https://zhuanlan.zhihu.com/p/58244447</a></p>
<p>这边代码看原文</p>
<p>接上文AppInit</p>
<h2 id="AppInit"><a href="#AppInit" class="headerlink" title="AppInit"></a>AppInit</h2><p>这一步最重要的是最后一步用一个多播委托通知了程序初始化事件</p>
<h2 id="InitUObject"><a href="#InitUObject" class="headerlink" title="InitUObject"></a>InitUObject</h2><p>主要的是ProcessNewlyLoadedUObjects的注册。</p>
<p>我们需要在每次UE编译Module出的dll中的native类构造类型对象（定义新的UClass*对象），根据C++机制每次动态加载一个dll会触发static变量初始化，这样就会得到我们需要的元数据。</p>
<p>这边ProcessNewlyLoadedUObjects会调用多次</p>
<h2 id="StaticUObjectInit"><a href="#StaticUObjectInit" class="headerlink" title="StaticUObjectInit"></a>StaticUObjectInit</h2><p>在UObjectBaseInit（）后已经可以NewObject了，代表UObject系统的成功建立。</p>
<p>GObjTransientPkg: 一个全局变量，代表所有没有Outer对象都放在这个包里面</p>
<p>若在NewObject时没有提供Outer 则返回这个临时包，符合UObject对象必须在UPackage里的一贯基本原则</p>
<h2 id="UObjectBaseInit"><a href="#UObjectBaseInit" class="headerlink" title="UObjectBaseInit"></a>UObjectBaseInit</h2><ol>
<li>Init了UObject的内存分配存储系统和对象的Hash系统<ol>
<li>GUObjectAllocator.AllocatePermanentObjectPool(SizeOfPermanentObjectPool);<em>//初始化对象分配器</em>    </li>
<li>GUObjectArray.AllocateObjectPool(MaxUObjects, MaxObjectsNotConsideredByGC, bPreAllocateUObjectArray);<em>//初始化对象管理数组</em></li>
</ol>
</li>
<li>创建了异步加载线程，用来后续Package(uasset)的加载。</li>
<li>GObjInitialized=true，这样在后续就可以用<code>bool UObjectInitialized()</code>来判断对象系统是否可用。</li>
<li>继续转发到<code>UObjectProcessRegistrants</code>来把注册项一一处理。</li>
</ol>
<h2 id="UObjectProcessRegistrants"><a href="#UObjectProcessRegistrants" class="headerlink" title="UObjectProcessRegistrants"></a>UObjectProcessRegistrants</h2><p>遍历FPendingRegistrant 为节点的链表</p>
<p>由GFirstPendingRegistrant和GLastPendingRegistrant 定义</p>
<p>用UObjectForceRegistration来注册</p>
<p>在每一次注册的时候会调用DequeuePendingAutoRegistrants去提取（因为可能会依赖别的模块的东西）会触发另一个依赖Module的加载，递归新的依赖注册项。</p>
<h2 id="UObjectForceRegistration"><a href="#UObjectForceRegistration" class="headerlink" title="UObjectForceRegistration"></a>UObjectForceRegistration</h2><p>UObjectForceRegistration 可能多个地方调用</p>
<ol>
<li>对于用 UObjectProcessRegistrants 手动注册</li>
<li>在UClass::CreateDefaultObject() 中调用 UObjectForceRegistration(ParentClass) 确认基类注册完成</li>
<li>在 UE4CodeGen_Private::ConstructUClass() 中 调用UObjectForceRegistration(NewClass) 保证对象已经注册。</li>
</ol>
<h2 id="UObjectBase-DeferredRegister"><a href="#UObjectBase-DeferredRegister" class="headerlink" title="UObjectBase::DeferredRegister"></a>UObjectBase::DeferredRegister</h2><p>Deferred是延迟的意思 真正注册的地方DeferredRegister </p>
<ol>
<li>延迟注册DeferredRegister 区别与UObjectBase::Register ，指的是在对象系统初始化后的注册（GUObjectAllocator和GUObjectArray） 在Register的时候还不能去NewObject和 加载Package 在初始化之后就可以使用UObject的功能了。这边才可以开始CreatePackage</li>
<li>Register，是指代码中class生成对应的UClass*对象并注册到全局对象数组中。</li>
</ol>
<p>所以总结起来这里所做的是创建出UClass<em>的Outer指向的Package，并设置ClassPrivate（这里都是UClass</em>对象，所以其实都是UClass::StaticClass()）。然后在AddObject里设置NamePrivate。因此这步之后这些一个个UClass<em>对象才有名字，之间的联系才算完整。 但同时也需要注意的是，这些UClass</em>对象里仍然没有UProperty和UFunciton，下一篇来讲解这些的构造生成。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>后续再补充</p>
<h1 id="类型系统构造-再次触发-ProcessNewlyLoadedUObjects"><a href="#类型系统构造-再次触发-ProcessNewlyLoadedUObjects" class="headerlink" title="类型系统构造-再次触发-ProcessNewlyLoadedUObjects"></a>类型系统构造-再次触发-ProcessNewlyLoadedUObjects</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58868952">https://zhuanlan.zhihu.com/p/58868952</a></p>
<p>上文是UObject系统的初始化和各UClass*对象的初级构造，本篇为FEngineLoop::PreInit()中AppInit（）的下一个重要函数ProcessNewlyLoadedUObjects，注意在模块加载后再次触发。需要清楚：一是它是重复调用多次的，二是它的内部流程是一个完整的流程。</p>
<h2 id="ProcessNewlyLoadedUObjects"><a href="#ProcessNewlyLoadedUObjects" class="headerlink" title="ProcessNewlyLoadedUObjects"></a>ProcessNewlyLoadedUObjects</h2><ol>
<li>UClassRegisterAllCompiledInClasses 前文介绍过，为每个编译Class调用 TClassStaticClass（）来构建出UClass*对象</li>
<li>收集到的全局数据：class，struct，enum</li>
<li>UObjectProcessRegistrants 前文介绍过 为生成的UClass* 注册，生成其Package。 这边调用目的是在后续操作之前必须要相关类型的UClass* 对象已注册完毕</li>
<li>UObjectLoadAllCompiledInStructs() 生成UEnum和UScriptStruct对象。</li>
<li>UObjectLoadAllCompiledInDefaultProperties（）对UClass* 继续构造和创建COD</li>
<li>最后一步判断如果有新UClass*对象生成了，并且现在不在初始化载入阶段（GIsInitialLoad初始=true，只有在后续开启GC后才=false表示初始化载入过程结束了），用AssembleReferenceTokenStreams为UClass创建引用记号流（一种辅助GC分析对象引用的数据结构，挖坑留待以后讲GC的时候讲解。）。所以第一次的<code>FEngineLoop::PreInit()</code>里的ProcessNewlyLoadedUObjects并不会触发AssembleReferenceTokenStreams的调用但也会在后续的GUObjectArray.CloseDisregardForGC()里面调用AssembleReferenceTokenStreams。只有后续模块动态加载后触发的ProcessNewlyLoadedUObjects才会AssembleReferenceTokenStreams。通过这个判断保证了在两种情况下，AssembleReferenceTokenStreams只会被调用一次。</li>
</ol>
<p><strong>思考：为何ProcessNewlyLoadedUObjects函数里前面的步骤总有一种既视感？</strong></p>
<h2 id="UObjectLoadAllCompiledInStructs"><a href="#UObjectLoadAllCompiledInStructs" class="headerlink" title="UObjectLoadAllCompiledInStructs"></a>UObjectLoadAllCompiledInStructs</h2><p>构造UEnum和UScriptStruct</p>
<ol>
<li>先创建EnumRegistrant.PackageName后创建StructRegistrant.PackageName，在创建前查找是否存在。</li>
<li>MoveTemp触发TArray中右移引用赋，把原数据迁移到目标数组中。</li>
<li>先enum再struct的调用其注册函数RegisterFn()。（Z_Construct开头的函数）</li>
<li>因为需要顺序注册所以总是先enum再struct，基础类型先构造，struct可以包含enum，反之不行。</li>
</ol>
<h2 id="UObjectLoadAllCompiledInDefaultProperties"><a href="#UObjectLoadAllCompiledInDefaultProperties" class="headerlink" title="UObjectLoadAllCompiledInDefaultProperties"></a>UObjectLoadAllCompiledInDefaultProperties</h2><p>UClass*对象构造</p>
<ol>
<li>从GetDeferredCompiledInRegistration()的数组中MoveTemp来遍历。</li>
<li>用Registrant（）构造，指向Z_Construct_UClass_UMyClass的函数</li>
<li>将对象放在，对应的Package的对应的三个数组中</li>
<li>3个数组依次手动构造CDO对象，顺序是CoreUObject、Engine和其他。</li>
<li>因为Class中可包含struct和enum所以Class更晚构造。</li>
</ol>
<h2 id="CloseDisregardForGC"><a href="#CloseDisregardForGC" class="headerlink" title="CloseDisregardForGC"></a>CloseDisregardForGC</h2><p>开始GC，之前一直都是在初始化载入阶段。</p>
<p>这个阶段构造的类型UClass*对象和CDO对象，及其属于的UPackage对象，都是属于引擎底层的必要对象。</p>
<p>在游戏大退的时候才会被销毁。会OpenForDisregardForGC=true（GC关闭）</p>
<p>类型系统都构建完了之后，就可以打开GC了，因为后续可能就会NewObject了</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol>
<li>大部分是不言自明的，从左到右是类型信息的收集和消费过程。从上到下是依据代码的执行顺序。</li>
<li>’2. 红色箭头代表数据的产生添加，蓝色箭头代表数据的消费使用。这二者一起表达了类型信息的数据流向。 </li>
<li>浅蓝色箭头和矩形，代表内存中UClass*以及类型对象的创建和构造。 </li>
<li>信息收集里黄色的3个矩形，代表它们的数据会一直在内存中，用来做查找用，不会被清空。</li>
</ol>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-23.png" alt="img"></p>
<h1 id="类型系统构造-构造绑定链接"><a href="#类型系统构造-构造绑定链接" class="headerlink" title="类型系统构造-构造绑定链接"></a>类型系统构造-构造绑定链接</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59553490">https://zhuanlan.zhihu.com/p/59553490</a></p>
<p>在上篇介绍了类型注册的最后阶段，为每一个enum、struct、class都进行了一次RegisterFn调用（忘了调用时机的请翻阅前文)，而这些RegisterFn其实都指向生成代码里的函数。本篇就来讲解这个里面的类型对象生成和构造。 按照生成顺序，也是调用顺序，一一讲解UEnum和UScriptStruct的生成，以及UClass的继续构造。 </p>
<h2 id="UEnum"><a href="#UEnum" class="headerlink" title="UEnum"></a>UEnum</h2><p>把MyEnum_StaticEnum注册给了RegisterFn。调用的时候，内部的GetStaticEnum会调用参赛里的Z_Construct_UEnum_Hello_MyEnum。而Z_Construct_UEnum_Hello_MyEnum内部其实比较简单，定义了枚举项参数和枚举参数，最终发给UE4CodeGen_Private::ConstructUEnum调用。</p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-24.png" alt="img"></p>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-25.png" alt="img"></p>
<h1 id="类型系统-总结"><a href="#类型系统-总结" class="headerlink" title="类型系统-总结"></a>类型系统-总结</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60291730">https://zhuanlan.zhihu.com/p/60291730</a></p>
<p>一个UClass*要经历这么几个阶段：</p>
<ol>
<li>内存构造。刚创建出来一块白纸一般的内存，简单的调用了UClass的构造函数。UE里一个对象的构造，构造函数的调用只是个起点而已。</li>
<li>注册。给自己一个名字，把自己登记在对象系统中。这步是通过DeferredRegister而不是Register完成的。</li>
<li>对象构造。往对象里填充属性、函数、接口和元数据的信息。这步我们应该记得是在gen.cpp里的那些函数完成的。</li>
<li>绑定链接。属性函数都有了，把它们整理整理，尽量优化一下存储结构，为以后的使用提供更高性能和便利。</li>
<li>CDO创建。既然类型已经有了，那就万事俱备只差国家包分配一个类默认对象了。每个UClass都有一个CDO（Class Default Object），有了CDO，相当于有了一个存档备份和参照，其他对象就心不慌。</li>
<li>引用记号流构建。一个Class是怎么样有可能引用其他别的对象的，这棵引用树怎么样构建的高效，也是GC中一个非常重要的话题。有了引用记号流，就可以对一个对象高效的分析它引用了其他多少对象。</li>
</ol>
<h2 id="UMetaData"><a href="#UMetaData" class="headerlink" title="UMetaData"></a>UMetaData</h2><p>只在Editor模式下使用，在所有的类型对象Construct的一步就是AddMetaData。</p>
<ol>
<li>UMetaData是属于UPackage关联，而不是绑定在某个UField中。</li>
<li>UMetaData在Runtime是被略过去的。</li>
<li>UMetaData是个对象。</li>
</ol>
<ul>
<li>UMetaData的定义<ul>
<li>TMap&lt; FWeakObjectPtr, TMap&lt;FName, FString&gt; &gt; ObjectMetaDataMap;<ul>
<li>对象关联的键值对。</li>
<li>FWeakObjectPtr 弱指针引用UObject对象，这样就不会阻碍GC</li>
<li>FName，key只用固定的一些Category，Tooltip这些</li>
<li>FString，val爱写啥写啥。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>思考：为何不把Map&lt;FName,FString&gt; MetaDataMap直接放进UObject里？</strong></p>
<h2 id="GRegisterCast和GRegisterNative的作用"><a href="#GRegisterCast和GRegisterNative的作用" class="headerlink" title="GRegisterCast和GRegisterNative的作用"></a>GRegisterCast<em>和GRegisterNative</em>的作用</h2><p><code>IMPLEMENT_CAST_FUNCTION</code>收集到GRegisterCast，<code>IMPLEMENT_VM_FUNCTION</code>收集到GRegisterNative。</p>
<p>这些其实就是一些函数用来做对象的转换和蓝图虚拟机的一些基础函数。把虚拟机里运行的指令码和真正的函数指针绑定起来。</p>
<h2 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h2><p>UE利用这些枚举标志来判断对象的状态和特征。 重要的有：</p>
<ul>
<li>EObjectFlags:对象本身的标志。 </li>
<li>ElnternalObjectFlags:对象存储的标志, GC的时候用来检查可达性。</li>
<li>EObjectMarkt：用来额外标记对象特征的标志，用在序列化过程中标识状态</li>
<li>EClassFlags:类的标志,定义了一个类的特征。 </li>
<li>EClassCastFlags:类之间的转换,可以快速的测试一个类是否可以转换成某种类型。 </li>
<li>EStructFlags:结构的特征标志。 </li>
<li>EFunctionFlags:函数的特征标志。</li>
<li> EPropertyFlags：属性的特征标志。</li>
</ul>
<h1 id="类型系统-反射实战"><a href="#类型系统-反射实战" class="headerlink" title="类型系统-反射实战"></a>类型系统-反射实战</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61042237">https://zhuanlan.zhihu.com/p/61042237</a></p>
<table>
<thead>
<tr>
<th>功能类别</th>
<th>核心函数/类</th>
<th>主要作用</th>
<th>常用场景示例</th>
</tr>
</thead>
<tbody><tr>
<td>获取类型信息</td>
<td>UYourClass::StaticClass() UObjectInstance-&gt;GetClass()</td>
<td>获取一个类或对象实例的 UClass（运行时类信息元数据）<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,3,7</a></td>
<td>获取类的名称、判断继承关系、用于后续的属性和函数遍历。</td>
</tr>
<tr>
<td></td>
<td>UStruct::StaticStruct()</td>
<td>获取结构体的 UScriptStruct 元数据<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,3</a></td>
<td>获取结构体的类型信息。</td>
</tr>
<tr>
<td></td>
<td>FindObject<UClass>/<UEnum>(ANY_PACKAGE, TEXT(“Name”), true)</td>
<td>根据名称在任意包中查找 UClass 或 UEnum 反射对象<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">5,7</a></td>
<td>动态查找已知名称的类或枚举类型。</td>
</tr>
<tr>
<td>遍历字段</td>
<td>TFieldIterator<FProperty>(SomeUClass)</td>
<td>遍历一个 UClass 或 UScriptStruct 的所有反射属性（FProperty）<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,3,7</a></td>
<td>动态查看一个类的所有属性名称和类型。</td>
</tr>
<tr>
<td></td>
<td>TFieldIterator<UFunction>(SomeUClass)</td>
<td>遍历一个 UClass 的所有反射函数（UFunction）<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,3</a></td>
<td>动态查看一个类的所有函数名称。</td>
</tr>
<tr>
<td>查看继承</td>
<td>UStruct::GetSuperStruct()</td>
<td>获取当前 UClass 或 UScriptStruct 的父类/父结构体指针<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>遍历类的继承链。</td>
</tr>
<tr>
<td></td>
<td>UClass::IsChildOf(OtherUClass)</td>
<td>判断一个类是否是另一个类的子类<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>检查类型的继承关系。</td>
</tr>
<tr>
<td></td>
<td>GetDerivedClasses(BaseUClass, OutArray, bRecursive)</td>
<td>获取所有派生自某个基类的 UClass 列表<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>查找游戏中所有特定类型的类（如所有武器类）。</td>
</tr>
<tr>
<td>属性值操作</td>
<td>FProperty::ContainerPtrToValuePtr<void>(ObjectInstance)</td>
<td>获取某个对象实例中特定属性值的内存地址<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>为动态获取或设置属性值做准备。</td>
</tr>
<tr>
<td></td>
<td>FFloatProperty::GetPropertyValue(ValuePtr) FStrProperty::SetPropertyValue(ValuePtr, NewValue)</td>
<td>（通过具体属性类型的类）从内存地址读取或写入属性值<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>动态获取或设置特定类型的属性值。</td>
</tr>
<tr>
<td></td>
<td>FProperty::ImportText(*InString, ValuePtr, nullptr, nullptr)</td>
<td>将字符串值转换并导入到属性值的内存地址中<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>从文本文件（如 CSV）中读取数据并动态设置到对象属性上。</td>
</tr>
<tr>
<td>反射调用函数</td>
<td>UClass::FindFunctionByName(“FunctionName”)</td>
<td>根据函数名称查找并获取 UFunction<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,3,7</a></td>
<td>为动态调用函数做准备。</td>
</tr>
<tr>
<td></td>
<td>UObject::ProcessEvent(UFunction, Params)</td>
<td>让对象实例执行指定的 UFunction<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,3,6,7</a></td>
<td>动态调用蓝图暴露的函数或事件。</td>
</tr>
<tr>
<td>对象与GC</td>
<td>GetObjectsOfClass(SomeUClass, OutArray)</td>
<td>获取世界中所有属于特定 UClass 的对象实例<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">7</a></td>
<td>查找场景中所有特定的 Actor。</td>
</tr>
<tr>
<td></td>
<td>NewObject<UYourClass>()</td>
<td>动态创建一个支持反射的 UObject 实例<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">3</a></td>
<td>在运行时生成对象。</td>
</tr>
</tbody></table>
<ul>
<li><strong>基础与依赖</strong>：上述多数函数都基于 Unreal Header Tool (UHT) 生成的反射数据。你的 C++ 类必须使用 <code>UCLASS()</code>, <code>UFUNCTION()</code>, <code>UPROPERTY()</code> 等宏并包含 <code>.generated.h</code> 文件，这些函数才能正确工作。</li>
<li><strong>性能注意</strong>：运行时反射操作（如遍历字段、<code>FindFunctionByName</code>、<code>ProcessEvent</code>）比直接的 C++ 调用开销更大，应避免在性能敏感的循环（如 <code>Tick</code>）中频繁使用。</li>
<li><strong>安全注意</strong>：使用 <code>ContainerPtrToValuePtr</code> 和手动构建 <code>ProcessEvent</code> 参数时，务必确保类型和内存操作的正确性，否则可能导致崩溃。</li>
</ul>
<h1 id="视频流程梳理"><a href="#视频流程梳理" class="headerlink" title="视频流程梳理"></a>视频流程梳理</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bH4y1k7Wg/?share_source=copy_web&amp;vd_source=42dfbaf08c560ddd9e83bed118ff917d%EF%BC%89">https://www.bilibili.com/video/BV1bH4y1k7Wg/?share_source=copy_web&amp;vd_source=42dfbaf08c560ddd9e83bed118ff917d）</a></p>
<h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>参考C# 反射</p>
<h2 id="UHT生成文件"><a href="#UHT生成文件" class="headerlink" title="UHT生成文件"></a>UHT生成文件</h2><ol>
<li>.h 文件<ol>
<li>GENERATED_BODY() <ol>
<li>生成另一个宏FID_ProjectCppTest_Source_ProjectCppTest_Public_Myobject_h_15_GENERATED_BODY</li>
<li>FID_ProjectCppTest_Source_ProjectCppTest_Public_MyObject_h_15_ACCESSORS 注册natives 函数 在函数体cpp文件中</li>
<li>DECLARE_CLASS 声明一系列重载运算符与StaticClass（）</li>
</ol>
</li>
</ol>
</li>
<li>.cpp文件<ol>
<li>构造函数<ol>
<li>Z_Construct_UClass_UMyObject()</li>
<li> Z_Construct_UPackage_Script_ProjectCppTest()</li>
</ol>
</li>
<li>IMPLEMENT_CLASS_NO_AUTO_REGISTRATION（UMyobject）宏 （UE5.2 更新过）<ol>
<li>以前UE4版本调用的是IMPLEMENT_CLASS</li>
<li>重要定义了 Z_Registration_Info_UClass_MyObject 结构</li>
<li>以及定义了 GetPrivateStaticClass （）函数 这个函数是执行真正注册行为，在StaticClass（）函数中调用</li>
</ol>
</li>
<li>Z_Construct_UClass_UMyObject_Static 宏<ol>
<li>静态结构体，包含了函数UFUNCTION和成员变量UPROPERTY</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Static-自动注册"><a href="#Static-自动注册" class="headerlink" title="Static 自动注册"></a>Static 自动注册</h2><p>C++ Static 自动注册模式，根据C++ static对象会在main函数之前初始化的特性</p>
<p>最后走到RegisterCompiledInInfo（）  </p>
<p>利用FClassDeferredRegistry::Get().AddRegistration（）</p>
<p>收集到 TDeferredRegistry&lt;&gt; 中 </p>
<p>后在main 函数构造的时候去构造UClass 对象 和 CDO</p>
<p>（可能与上文不符合的是这边上文讲了UE4会构造第一个UCALSS ，UE5可能没有）</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>在static静态初始化后 main初始化后的动态初始化流程</p>
<p>UE程序入口 LaunchWindows.cpp  </p>
<ul>
<li><p>WinMain（）开始</p>
</li>
<li><p>调用LaunchWindowsStartup（）</p>
</li>
<li><p>GuardedMain(CmdLine); 游戏循环逻辑</p>
</li>
<li><p>EnginePreInit(CmdLine); </p>
</li>
<li><p>PreInit(CmdLine);</p>
<ul>
<li>PreInitPreStartupScreen(CmdLine); <ul>
<li>LoadCoreModules()<ul>
<li>FModuleManager::Get().LoadModule(TEXT(“CoreUObject”)) != nullptr;   </li>
<li>生成CoreMoudule -&gt; class FCoreUobjectModule : public FDefaultModuleImpl<ul>
<li>在里面调用StartupModule（）<ul>
<li>UClassRegisterAllCompiledInClasses();<ul>
<li>for (const FClassDeferredRegistry::FRegistrant&amp; Registrant : Registry.GetRegistrations（）） </li>
<li>注释: 前面Static 自动注册 添加的静态数据遍历</li>
<li>UClass* RegisteredClass = FClassDeferredRegistry: :InnerRegister(Registrant);</li>
<li>注释: 这里的Class其实是TClassCompiledInDefer<TClass> -&gt; return TClass::StaticClass();</li>
<li>在前面UHT生成文件中DECLARE_CLASS 注册过的函数 最后到达GetPrivateStaticClass （）</li>
<li>注释: GetPrivateStaticClass（） 函数体在 .cpp 中 的IMPLEMENT_CLASS_NO_AUTO_REGISTRATION 宏 调用 GetPrivateStaticClassBody（）</li>
<li>GetPrivateStaticClassBody（）<ul>
<li>是真的创建对象，为其创建内存空间 </li>
<li>ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UClass), alignof(UClass), true);</li>
<li>InitializePrivateStaticClass（） 初始化操作 <ul>
<li>指定父类class </li>
<li>简单注册到LRU结构中UObjectBase::Register（）</li>
</ul>
</li>
<li>RegisterNativeFunc();<ul>
<li>函数指针 传入 void UMyObject::StaticRegisterNativesUMyObject()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>InitUObject();<ul>
<li>FCoreDelegates::OnInit.AddStatic();  -&gt;添加委托 在AppInit 初始化完成调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AppInit();</p>
<ul>
<li>完成时候 会广播委托 FCoreDelegates::OnInit.Broadcast();   -&gt; 调用StartupModule()中的 InitUObject（）</li>
</ul>
</li>
<li><p>InitUObject（） 上文有一整个章节讲这个</p>
<ul>
<li>添加 ProcessNewlyLoadedUObjects() 委托</li>
<li>StaticUObjectInit（）<ul>
<li>UObjectBaseInit（）<ul>
<li>内存分配器和Hash管理器 AllocatePermanentobjectPool 和 AllocateObjectPool （这俩步完成就可以NewObject了？）</li>
<li>UObjectProcessRegistrants();<ul>
<li>从前面全局LRU的链表结构中获取TArray</li>
<li>遍历TArray 调用UObjectForceRegistration（）<ul>
<li>调用 DeferredRegister（） -&gt; 创建真正的Package </li>
<li>再取一次链表 </li>
<li>（因为怕有依赖问题，可能依赖于其他Module从而加载底层Module，也可能会有其他Module已经注册好，数据会变化）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>新建默认临时Package -&gt; GobjTransientPkg = Newobject<UPackage>(nullptr, TEXT(“/Engine/Transient”), RF_Transient);<ul>
<li>没有指定Package 的话会加入这个默认临时Package （GobjTransientPkg ）中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ProcessNewlyLoadedUObjects（）</p>
<ul>
<li>俩种情况会调用 <ul>
<li>PreInit（）调用  默认加载对象已经默认已经加载的对象</li>
<li>加载完成Module调用 加载Module中的对象</li>
</ul>
</li>
<li>遍历Module中所有U对象<ul>
<li><p>调用UObjectProcessRegistrants（）（前面有讲到过）</p>
</li>
<li><p>UObjectLoadAllCompiledInStructs(); （对Struct处理）</p>
</li>
<li><p>UObjectLoadAllCompiledInDefaultProperties（）</p>
<ul>
<li><p>分成三个数组 NewClasses NewClassesInCoreUObject NewClassesInEngine</p>
</li>
<li><p>调用 DoPendingOuterRegistrations（）</p>
<ul>
<li>调用OuterRegister（）<ul>
<li>实际上return Registrant.OuterRegisterFn（）</li>
<li>是函数指针，指向的是Z_Construct_UClass_UMyObject()，即为ConstructUClass（）<ul>
<li>ConstructUClass（）会完善所有信息 构造所有对象 UCLASS 对象会所有构造完毕</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>前面构造完毕UCLASS对象会对每一个对象赋值 CDO</p>
<ul>
<li><p>CDO可以获取对象备份</p>
</li>
<li><p>也可以变成单例</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>AssembleReferenceTokenStream(); 获取引用链 GC会使用这个函数</li>
</ul>
</li>
</ul>
<p><img src="./../../pic/picture/0077-UEUObject/1761189295761-26.png" alt="img"></p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>看原文</p>
<p>一个UClass*要经历这么几个阶段。。。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fragmentary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/27/0077-UeUObject/">http://example.com/2025/08/27/0077-UeUObject/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">零の領域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ue/">ue</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/27/0078-UeUBT/" title="ue 编译相关"><img class="cover" src="/img/bg/default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ue 编译相关</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/15/0076-UEPython/" title="UE Python"><img class="cover" src="/img/bg/default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UE Python</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/11/10/0085-UeGasUse/" title="ue GAS(持续更新)"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-10</div><div class="title">ue GAS(持续更新)</div></div></a></div><div><a href="/2025/11/07/0084-UeAdapt/" title="UE 适配与多分辨率"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-07</div><div class="title">UE 适配与多分辨率</div></div></a></div><div><a href="/2025/11/06/0083-UeSlate/" title="ue Slate初探"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-06</div><div class="title">ue Slate初探</div></div></a></div><div><a href="/2025/10/13/0081-UeAync/" title="ue 多线程"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-13</div><div class="title">ue 多线程</div></div></a></div><div><a href="/2025/10/11/0082-UeIA/" title="ue 增强输入"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-11</div><div class="title">ue 增强输入</div></div></a></div><div><a href="/2025/09/11/0080-UeGC/" title="ue gc"><img class="cover" src="/img/bg/default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="title">ue gc</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg/pixiv_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fragmentary</div><div class="author-info__description">一个摸鱼人的日常博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Fragmentary1002"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Fragmentary1002" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://space.bilibili.com/165064718?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fa-solid fa-tv"></i></a><a class="social-icon" href="https://www.youtube.com/@mentaryFrag" target="_blank" title="youtube"><i class="fa-brands fa-youtube"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是一个博客~ 好吧这是我的学习笔记 一个Unity客户端开发者的日常</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">开篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E6%93%8E%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%83%85%E5%86%B5"><span class="toc-number">2.1.</span> <span class="toc-text">其他引擎的对象模型情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">类型系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">类型系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Type"><span class="toc-number">3.2.</span> <span class="toc-text">C# Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-RTTI"><span class="toc-number">3.3.</span> <span class="toc-text">C++ RTTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeid"><span class="toc-number">3.3.1.</span> <span class="toc-text">typeid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">3.3.2.</span> <span class="toc-text">dynamic_cast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%BD%93%E5%89%8D%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">3.4.</span> <span class="toc-text">C++当前实现反射的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.4.2.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">3.4.3.</span> <span class="toc-text">编译器数据分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.4.</span> <span class="toc-text">工具生成代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UE%E9%87%8CUHT%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.</span> <span class="toc-text">UE里UHT的方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%AE%9A%E5%92%8C%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">类型系统设定和结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A"><span class="toc-number">4.1.</span> <span class="toc-text">设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">类型系统代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Static-Lazy%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">C++ Static Lazy初始化模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UHT%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">5.2.</span> <span class="toc-text">UHT代码生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UCLASS%E7%9A%84%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">UCLASS的生成代码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyClass-h"><span class="toc-number">5.3.1.</span> <span class="toc-text">MyClass.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyClass-generated-h"><span class="toc-number">5.3.2.</span> <span class="toc-text">MyClass.generated.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-generated-cpp"><span class="toc-number">5.3.3.</span> <span class="toc-text">Hello.generated.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E5%B1%95%E5%BC%80%E7%BB%93%E6%9E%9C"><span class="toc-number">5.3.4.</span> <span class="toc-text">最后展开结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UENUM%E7%9A%84%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">UENUM的生成代码剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USTRUCT%E7%9A%84%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">5.5.</span> <span class="toc-text">USTRUCT的生成代码剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UINTERFACE%E7%9A%84%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">5.6.</span> <span class="toc-text">UINTERFACE的生成代码剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UClass%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">5.7.</span> <span class="toc-text">UClass中的字段和函数生成代码剖析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-number">6.</span> <span class="toc-text">类型系统信息收集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Auto-Register"><span class="toc-number">6.1.</span> <span class="toc-text">Static Auto Register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UE-Static-Auto-Register"><span class="toc-number">6.2.</span> <span class="toc-text">UE Static Auto Register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E9%9B%86"><span class="toc-number">6.3.</span> <span class="toc-text">收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">6.4.</span> <span class="toc-text">Static的收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">6.5.</span> <span class="toc-text">Class的收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">6.6.</span> <span class="toc-text">Enum的收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Struct%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">6.7.</span> <span class="toc-text">Struct的收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">6.8.</span> <span class="toc-text">Function的收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObject%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">6.9.</span> <span class="toc-text">UObject的收集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E9%87%8D%E6%9E%84-UE4CodeGen-Private"><span class="toc-number">7.</span> <span class="toc-text">类型系统代码生成重构-UE4CodeGen_Private</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">7.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UE4CodeGen-Private"><span class="toc-number">7.2.</span> <span class="toc-text">UE4CodeGen_Private</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%B3%A8%E5%86%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAUClass"><span class="toc-number">8.</span> <span class="toc-text">类型系统注册-第一个UClass</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Static%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.1.</span> <span class="toc-text">Static初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NoExportTypes-h"><span class="toc-number">8.2.</span> <span class="toc-text">NoExportTypes.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetPrivateStaticClass"><span class="toc-number">8.3.</span> <span class="toc-text">GetPrivateStaticClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetPrivateStaticClassBody"><span class="toc-number">8.4.</span> <span class="toc-text">GetPrivateStaticClassBody</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InitializePrivateStaticClass"><span class="toc-number">8.5.</span> <span class="toc-text">InitializePrivateStaticClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectBase-Register"><span class="toc-number">8.6.</span> <span class="toc-text">UObjectBase::Register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegisterNativeFunc"><span class="toc-number">8.7.</span> <span class="toc-text">RegisterNativeFunc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%B3%A8%E5%86%8C-CoreUObject%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="toc-number">9.</span> <span class="toc-text">类型系统注册-CoreUObject模块加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">9.1.</span> <span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FEngineLoop-PreInit"><span class="toc-number">9.2.</span> <span class="toc-text">FEngineLoop::PreInit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UClassRegisterAllCompiledInClasses"><span class="toc-number">9.3.</span> <span class="toc-text">UClassRegisterAllCompiledInClasses</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%B3%A8%E5%86%8C-InitUObject"><span class="toc-number">10.</span> <span class="toc-text">类型系统注册-InitUObject</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AppInit"><span class="toc-number">10.1.</span> <span class="toc-text">AppInit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InitUObject"><span class="toc-number">10.2.</span> <span class="toc-text">InitUObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StaticUObjectInit"><span class="toc-number">10.3.</span> <span class="toc-text">StaticUObjectInit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectBaseInit"><span class="toc-number">10.4.</span> <span class="toc-text">UObjectBaseInit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectProcessRegistrants"><span class="toc-number">10.5.</span> <span class="toc-text">UObjectProcessRegistrants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectForceRegistration"><span class="toc-number">10.6.</span> <span class="toc-text">UObjectForceRegistration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectBase-DeferredRegister"><span class="toc-number">10.7.</span> <span class="toc-text">UObjectBase::DeferredRegister</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9E%84%E9%80%A0-%E5%86%8D%E6%AC%A1%E8%A7%A6%E5%8F%91-ProcessNewlyLoadedUObjects"><span class="toc-number">11.</span> <span class="toc-text">类型系统构造-再次触发-ProcessNewlyLoadedUObjects</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ProcessNewlyLoadedUObjects"><span class="toc-number">11.1.</span> <span class="toc-text">ProcessNewlyLoadedUObjects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectLoadAllCompiledInStructs"><span class="toc-number">11.2.</span> <span class="toc-text">UObjectLoadAllCompiledInStructs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UObjectLoadAllCompiledInDefaultProperties"><span class="toc-number">11.3.</span> <span class="toc-text">UObjectLoadAllCompiledInDefaultProperties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CloseDisregardForGC"><span class="toc-number">11.4.</span> <span class="toc-text">CloseDisregardForGC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">11.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9E%84%E9%80%A0-%E6%9E%84%E9%80%A0%E7%BB%91%E5%AE%9A%E9%93%BE%E6%8E%A5"><span class="toc-number">12.</span> <span class="toc-text">类型系统构造-构造绑定链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UEnum"><span class="toc-number">12.1.</span> <span class="toc-text">UEnum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">类型系统-总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UMetaData"><span class="toc-number">13.1.</span> <span class="toc-text">UMetaData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GRegisterCast%E5%92%8CGRegisterNative%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">GRegisterCast和GRegisterNative的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flags"><span class="toc-number">13.3.</span> <span class="toc-text">Flags</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-%E5%8F%8D%E5%B0%84%E5%AE%9E%E6%88%98"><span class="toc-number">14.</span> <span class="toc-text">类型系统-反射实战</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">视频流程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">15.1.</span> <span class="toc-text">反射的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UHT%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6"><span class="toc-number">15.2.</span> <span class="toc-text">UHT生成文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C"><span class="toc-number">15.3.</span> <span class="toc-text">Static 自动注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">15.4.</span> <span class="toc-text">实现流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">15.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/10/0085-UeGasUse/" title="ue GAS(持续更新)"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue GAS(持续更新)"/></a><div class="content"><a class="title" href="/2025/11/10/0085-UeGasUse/" title="ue GAS(持续更新)">ue GAS(持续更新)</a><time datetime="2025-11-09T16:00:00.000Z" title="发表于 2025-11-10 00:00:00">2025-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/07/0084-UeAdapt/" title="UE 适配与多分辨率"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE 适配与多分辨率"/></a><div class="content"><a class="title" href="/2025/11/07/0084-UeAdapt/" title="UE 适配与多分辨率">UE 适配与多分辨率</a><time datetime="2025-11-06T16:00:00.000Z" title="发表于 2025-11-07 00:00:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/06/0083-UeSlate/" title="ue Slate初探"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue Slate初探"/></a><div class="content"><a class="title" href="/2025/11/06/0083-UeSlate/" title="ue Slate初探">ue Slate初探</a><time datetime="2025-11-05T16:00:00.000Z" title="发表于 2025-11-06 00:00:00">2025-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/23/0000-UeAlsUse/" title="ue Als 使用(占坑)"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue Als 使用(占坑)"/></a><div class="content"><a class="title" href="/2025/10/23/0000-UeAlsUse/" title="ue Als 使用(占坑)">ue Als 使用(占坑)</a><time datetime="2025-10-22T16:00:00.000Z" title="发表于 2025-10-23 00:00:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/13/0081-UeAync/" title="ue 多线程"><img src="/img/bg/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ue 多线程"/></a><div class="content"><a class="title" href="/2025/10/13/0081-UeAync/" title="ue 多线程">ue 多线程</a><time datetime="2025-10-12T16:00:00.000Z" title="发表于 2025-10-13 00:00:00">2025-10-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Fragmentary</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>